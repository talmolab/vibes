<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Camera Calibration</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>Multi-Camera Calibration</h1>
    <p class="description">Load multi-view calibration videos, detect ChArUco boards, and compute camera calibration parameters.</p>

    <div class="error-msg" id="errorMsg"></div>

    <div class="main-layout no-videos" id="mainLayout">
        <!-- Floating Video Panel (left side) -->
        <div class="video-panel hidden" id="videoPanel">
            <div class="video-panel-header">
                <h2>Video Preview</h2>
                <p>Synchronized multi-view display</p>
            </div>

            <div class="video-grid" id="videoGrid">
                <!-- Video cells will be added dynamically -->
            </div>

            <div class="seekbar-container" id="seekbarContainer" style="display: none;">
                <div class="seekbar" id="seekbar">
                    <div class="seekbar-progress" id="seekbarProgress"></div>
                    <div class="seekbar-thumb" id="seekbarThumb"></div>
                </div>
                <div class="frame-info">
                    <span>Frame: <span id="currentFrame">0</span> / <span id="totalFrames">0</span></span>
                    <span>Time: <span id="currentTime">0:00.000</span></span>
                </div>
            </div>

            <div class="controls" id="videoControls" style="display: none;">
                <button id="playBtn">Play</button>
                <button id="prevFrameBtn" class="secondary">◀</button>
                <button id="nextFrameBtn" class="secondary">▶</button>
                <button id="prev10Btn" class="secondary">◀◀</button>
                <button id="next10Btn" class="secondary">▶▶</button>
            </div>

            <div class="overlay-controls" id="overlayControls" style="display: none;">
                <h3>Overlays:</h3>
                <div class="overlay-checkboxes">
                    <label class="overlay-checkbox">
                        <input type="checkbox" id="detectionsOverlayCheck" checked>
                        <span>Detections</span>
                    </label>
                    <label class="overlay-checkbox">
                        <input type="checkbox" id="intrinsicsOverlayCheck" checked>
                        <span>Intrinsics</span>
                    </label>
                    <label class="overlay-checkbox">
                        <input type="checkbox" id="extrinsicsOverlayCheck" checked>
                        <span>Extrinsics</span>
                    </label>
                </div>
            </div>

            <div class="hotkeys" style="padding: 10px 12px; font-size: 11px;">
                <h3 style="font-size: 12px; margin: 0 0 8px 0;">Keyboard Shortcuts</h3>
                <div class="hotkeys-grid" style="gap: 4px;">
                    <div class="hotkey"><span class="hotkey-key" style="min-width: 60px;">← / →</span><span class="hotkey-desc">±1 frame</span></div>
                    <div class="hotkey"><span class="hotkey-key" style="min-width: 60px;">↑ / ↓</span><span class="hotkey-desc">±10 frames</span></div>
                    <div class="hotkey"><span class="hotkey-key" style="min-width: 60px;">Space</span><span class="hotkey-desc">Play/Pause</span></div>
                    <div class="hotkey"><span class="hotkey-key" style="min-width: 60px;">[ / ]</span><span class="hotkey-desc">Reproj frames</span></div>
                    <div class="hotkey"><span class="hotkey-key" style="min-width: 60px;">+ / -</span><span class="hotkey-desc">Zoom all</span></div>
                    <div class="hotkey"><span class="hotkey-key" style="min-width: 60px;">0</span><span class="hotkey-desc">Reset zoom</span></div>
                    <div class="hotkey"><span class="hotkey-key" style="min-width: 60px;">Scroll</span><span class="hotkey-desc">Zoom video</span></div>
                    <div class="hotkey"><span class="hotkey-key" style="min-width: 60px;">Dbl-click</span><span class="hotkey-desc">Reset video</span></div>
                </div>
            </div>
        </div>

        <!-- Resize Handle -->
        <div class="resize-handle" id="resizeHandle">
            <div class="resize-handle-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>

        <!-- Pipeline Panel (right side, scrollable) -->
        <div class="pipeline-panel" id="pipelinePanel">

    <!-- STAGE 1: Video Loading -->
    <div class="stage" id="stage1">
        <div class="stage-header" onclick="toggleStage('stage1')">
            <div class="stage-title">
                <span class="stage-number">1</span>
                <h2>Load Multi-View Videos</h2>
            </div>
            <div style="display: flex; align-items: center; gap: 15px;">
                <span class="stage-status" id="stage1Status">Not started</span>
                <span class="stage-expand">▼</span>
            </div>
        </div>
        <div class="stage-content">
            <p>Load synchronized calibration videos from multiple camera views.</p>

            <div class="config-panel">
                <h3>Data Source</h3>
                <div class="config-row">
                    <button id="loadTestDataBtn">Load Test Data (sleap-anipose minimal_session)</button>
                    <button id="loadFolderBtn" class="secondary">Load Custom Folder</button>
                </div>
            </div>

            <div class="view-list" id="viewList">
                <p style="color: #888;">No videos loaded. Click "Load Test Data" to begin.</p>
            </div>
        </div>
    </div>

    <!-- STAGE 2: Board Detection -->
    <div class="stage collapsed" id="stage2">
        <div class="stage-header" onclick="toggleStage('stage2')">
            <div class="stage-title">
                <span class="stage-number">2</span>
                <h2>Detect Landmarks</h2>
            </div>
            <div style="display: flex; align-items: center; gap: 15px;">
                <span class="stage-status" id="stage2Status">Waiting for videos</span>
                <span class="stage-expand">▼</span>
            </div>
        </div>
        <div class="stage-content">
            <p>Configure ChArUco board parameters and detect corners across frames.</p>

            <div class="config-panel">
                <h3>Board Configuration</h3>
                <div class="config-row">
                    <div class="config-item">
                        <label>Board X:</label>
                        <input type="number" id="boardX" value="8" min="3" max="20">
                    </div>
                    <div class="config-item">
                        <label>Board Y:</label>
                        <input type="number" id="boardY" value="11" min="3" max="20">
                    </div>
                    <div class="config-item">
                        <label>Square Length (mm):</label>
                        <input type="number" id="squareLength" value="24" step="0.1">
                    </div>
                    <div class="config-item">
                        <label>Marker Length (mm):</label>
                        <input type="number" id="markerLength" value="18.75" step="0.1">
                    </div>
                </div>
                <div class="config-row">
                    <div class="config-item">
                        <label>Dictionary:</label>
                        <select id="arucoDict">
                            <option value="DICT_4X4_50">4x4 (50)</option>
                            <option value="DICT_4X4_100">4x4 (100)</option>
                            <option value="DICT_4X4_250">4x4 (250)</option>
                            <option value="DICT_4X4_1000" selected>4x4 (1000)</option>
                            <option value="DICT_5X5_50">5x5 (50)</option>
                            <option value="DICT_5X5_100">5x5 (100)</option>
                            <option value="DICT_5X5_250">5x5 (250)</option>
                            <option value="DICT_5X5_1000">5x5 (1000)</option>
                            <option value="DICT_6X6_50">6x6 (50)</option>
                            <option value="DICT_6X6_100">6x6 (100)</option>
                            <option value="DICT_6X6_250">6x6 (250)</option>
                            <option value="DICT_6X6_1000">6x6 (1000)</option>
                        </select>
                    </div>
                </div>
                <button id="detectCurrentBtn" disabled>Detect Current Frame</button>
            </div>

            <div class="config-panel">
                <h3>Batch Detection</h3>
                <div class="config-row">
                    <div class="config-item">
                        <label>Target Samples:</label>
                        <input type="number" id="targetSamples" value="50" min="10" max="500">
                    </div>
                    <div class="config-item">
                        <label>Computed Stride:</label>
                        <span id="computedStride">-</span>
                    </div>
                </div>
                <button id="runDetectionBtn" disabled>Run Batch Detection</button>
                <div id="detectionProgress" class="progress-container">
                    <div class="progress-bar"></div>
                    <div class="progress-text">0%</div>
                </div>
            </div>

            <div id="detectionResults" style="display: none;">
                <h3>Detection Results</h3>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Frame</th>
                            <th>Back</th>
                            <th>Mid</th>
                            <th>Side</th>
                            <th>Top</th>
                            <th>Common Points</th>
                        </tr>
                    </thead>
                    <tbody id="detectionTableBody">
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- STAGE 3: Intrinsics -->
    <div class="stage collapsed" id="stage3">
        <div class="stage-header" onclick="toggleStage('stage3')">
            <div class="stage-title">
                <span class="stage-number">3</span>
                <h2>Compute Intrinsics</h2>
            </div>
            <div style="display: flex; align-items: center; gap: 15px;">
                <span class="stage-status" id="stage3Status">Waiting for detections</span>
                <span class="stage-expand">▼</span>
            </div>
        </div>
        <div class="stage-content">
            <p>Estimate camera intrinsic parameters (focal length, principal point, distortion).</p>

            <div class="config-panel">
                <h3>Filtering</h3>
                <div class="config-row">
                    <div class="config-item">
                        <label>Min Corners per Frame:</label>
                        <input type="number" id="minCorners" value="6" min="4" max="50">
                    </div>
                </div>
            </div>

            <div class="controls">
                <button id="computeIntrinsicsBtn" disabled>Compute Intrinsics</button>
                <div id="intrinsicsProgress" class="progress-container">
                    <div class="progress-bar"></div>
                    <div class="progress-text">0%</div>
                </div>
            </div>

            <div id="intrinsicsResults" style="display: none;">
                <div class="exclusion-gallery" id="intrinsicsExclusionGallery" style="display: none;">
                    <div class="exclusion-gallery-header">
                        <h3>Calibration Frames</h3>
                        <div class="exclusion-stats" id="intrinsicsExclusionStats">0 / 0 excluded</div>
                    </div>
                    <p style="color: #888; font-size: 12px; margin: 0 0 10px 0;">
                        Click frames to view, click ✕ to exclude. Excluded frames are dimmed but still shown for comparison. Press X to toggle exclusion.
                    </p>
                    <div class="exclusion-controls">
                        <button id="clearIntrinsicsExclusionsBtn" class="secondary">Clear Exclusions</button>
                    </div>
                    <div class="exclusion-grid" id="intrinsicsExclusionGrid">
                        <!-- Thumbnails will be added dynamically -->
                    </div>
                </div>

                <h3>Intrinsic Parameters</h3>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Camera</th>
                            <th>fx</th>
                            <th>fy</th>
                            <th>cx</th>
                            <th>cy</th>
                            <th>k1</th>
                            <th>k2</th>
                            <th>RMS Error</th>
                        </tr>
                    </thead>
                    <tbody id="intrinsicsTableBody">
                    </tbody>
                </table>

                <h3>Reprojection Error Distribution</h3>
                <p style="color: #888; font-size: 13px; margin-bottom: 10px;">
                    Per-image reprojection errors (RMS pixels). Hover over points to view that image's reprojection.
                </p>
                <div id="swarmPlotContainer" style="background: #1a1a1a; border-radius: 8px; padding: 15px; position: relative;">
                    <canvas id="swarmPlotCanvas" width="800" height="250"></canvas>
                    <div id="swarmTooltip" style="display: none; position: absolute; background: rgba(0,0,0,0.9); color: #fff; padding: 6px 10px; border-radius: 4px; font-size: 12px; pointer-events: none; z-index: 100;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- STAGE 4: Extrinsics -->
    <div class="stage collapsed" id="stage4">
        <div class="stage-header" onclick="toggleStage('stage4')">
            <div class="stage-title">
                <span class="stage-number">4</span>
                <h2>Compute Extrinsics</h2>
            </div>
            <div style="display: flex; align-items: center; gap: 15px;">
                <span class="stage-status" id="stage4Status">Waiting for intrinsics</span>
                <span class="stage-expand">▼</span>
            </div>
        </div>
        <div class="stage-content">
            <p>Estimate camera extrinsic parameters (rotation, translation) relative to a reference camera.</p>

            <div class="config-panel">
                <h3>Reference Camera</h3>
                <div class="config-row">
                    <div class="config-item">
                        <label>Reference View:</label>
                        <select id="referenceCamera">
                            <option value="0">back</option>
                        </select>
                    </div>
                    <div class="config-item">
                        <label>Min Covisible Points:</label>
                        <input type="number" id="minCovisible" value="10" min="4" max="50">
                    </div>
                </div>
            </div>

            <div class="config-panel">
                <h3>Bundle Adjustment Settings</h3>
                <div class="config-row">
                    <div class="config-item">
                        <label>Max Iterations:</label>
                        <input type="number" id="sbaMaxIterations" value="100" min="1" max="1000">
                    </div>
                    <div class="config-item">
                        <label>Robust Loss:</label>
                        <select id="sbaRobustLoss">
                            <option value="huber" selected>Huber</option>
                            <option value="cauchy">Cauchy</option>
                            <option value="none">None</option>
                        </select>
                    </div>
                    <div class="config-item">
                        <label>Loss Parameter:</label>
                        <input type="number" id="sbaLossParam" value="1.0" min="0.01" max="100" step="0.1">
                    </div>
                    <div class="config-item">
                        <label>Outlier Threshold (px):</label>
                        <input type="number" id="sbaOutlierThreshold" value="30" min="0" max="100" step="1">
                        <span style="color: #888; font-size: 11px;">0 = disabled</span>
                    </div>
                </div>
                <div class="config-row">
                    <div class="config-item">
                        <label>Optimize:</label>
                        <div style="display: flex; gap: 15px; align-items: center;">
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                <input type="checkbox" id="sbaOptExtrinsics" checked>
                                <span>Extrinsics</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                <input type="checkbox" id="sbaOptIntrinsics" checked>
                                <span>Intrinsics</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                <input type="checkbox" id="sbaOptPoints" checked>
                                <span>3D Points</span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="config-row">
                    <div class="config-item">
                        <label>Convergence Tolerances:</label>
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px;">
                                Cost:
                                <input type="number" id="sbaCostTol" value="1e-6" step="1e-7" style="width: 80px;">
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px;">
                                Param:
                                <input type="number" id="sbaParamTol" value="1e-8" step="1e-9" style="width: 80px;">
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px;">
                                Gradient:
                                <input type="number" id="sbaGradTol" value="1e-10" step="1e-11" style="width: 80px;">
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="controls">
                <button id="computeExtrinsicsBtn" disabled>Compute Extrinsics</button>
                <button id="runBundleBtn" class="secondary" disabled>Refine (Bundle Adjustment)</button>
                <div id="extrinsicsProgress" class="progress-container">
                    <div class="progress-bar"></div>
                    <div class="progress-text">0%</div>
                </div>
            </div>

            <div id="extrinsicsResults" style="display: none;">
                <div class="exclusion-gallery" id="extrinsicsExclusionGallery" style="display: none;">
                    <div class="exclusion-gallery-header">
                        <h3>Multi-View Frames</h3>
                        <div class="exclusion-stats" id="extrinsicsExclusionStats">0 / 0 excluded</div>
                    </div>
                    <p style="color: #888; font-size: 12px; margin: 0 0 10px 0;">
                        Click frames to view, click ✕ to exclude. Excluded frames won't be used for calibration. Press X to toggle exclusion.
                    </p>
                    <div class="exclusion-controls">
                        <button id="clearExtrinsicsExclusionsBtn" class="secondary">Clear Exclusions</button>
                    </div>
                    <div class="exclusion-grid" id="extrinsicsExclusionGrid">
                        <!-- Thumbnails will be added dynamically -->
                    </div>
                </div>

                <h3>Extrinsic Parameters</h3>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Camera</th>
                            <th>Rx</th>
                            <th>Ry</th>
                            <th>Rz</th>
                            <th>Tx</th>
                            <th>Ty</th>
                            <th>Tz</th>
                        </tr>
                    </thead>
                    <tbody id="extrinsicsTableBody">
                    </tbody>
                </table>

                <h3>Cross-View Reprojection Error</h3>
                <p style="color: #888; font-size: 13px; margin-bottom: 10px;">
                    Triangulated 3D points reprojected to each camera. Lower error = better multi-view consistency.
                </p>
                <div id="extrinsicsSwarmContainer" style="background: #1a1a1a; border-radius: 8px; padding: 15px; position: relative;">
                    <canvas id="extrinsicsSwarmCanvas" width="800" height="250"></canvas>
                    <div id="extrinsicsSwarmTooltip" style="display: none; position: absolute; background: rgba(0,0,0,0.9); color: #fff; padding: 6px 10px; border-radius: 4px; font-size: 12px; pointer-events: none; z-index: 100;"></div>
                </div>
            </div>

            <div id="viz3dContainer" style="height: 400px; background: #000; border-radius: 8px; margin: 15px 0; display: none;">
                <!-- Three.js visualization will go here -->
            </div>
        </div>
    </div>

    <!-- STAGE 5: Export -->
    <div class="stage collapsed" id="stage5">
        <div class="stage-header" onclick="toggleStage('stage5')">
            <div class="stage-title">
                <span class="stage-number">5</span>
                <h2>Export Results</h2>
            </div>
            <div style="display: flex; align-items: center; gap: 15px;">
                <span class="stage-status" id="stage5Status">Waiting for calibration</span>
                <span class="stage-expand">▼</span>
            </div>
        </div>
        <div class="stage-content">
            <p>Export calibration in TOML format and raw data for bundle adjustment.</p>

            <div class="controls">
                <button id="exportTomlBtn" disabled>Export calibration.toml</button>
                <button id="exportSbaJsonBtn" class="secondary" disabled>Export SBA Data (JSON)</button>
            </div>

            <div id="exportPreview">
                <h3>calibration.toml</h3>
                <pre id="tomlPreview" style="background: #1a1a1a; padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 12px; max-height: 400px; overflow-y: auto; color: #888;"># Complete intrinsic and extrinsic calibration to generate TOML</pre>
            </div>
        </div>
    </div>

        </div> <!-- End pipeline-panel -->
    </div> <!-- End main-layout -->

    <!-- Diagnostic Console -->
    <div class="diagnostic-console">
        <div class="diagnostic-header">
            <h3>Diagnostic Log</h3>
            <div>
                <button id="copyLogBtn">Copy</button>
                <button id="clearLogBtn">Clear</button>
            </div>
        </div>
        <div class="diagnostic-body" id="logBody"></div>
    </div>

    <!-- mp4box.js for demuxing -->
    <script src="https://cdn.jsdelivr.net/npm/mp4box@0.5.2/dist/mp4box.all.min.js"></script>
    <script src="video.js"></script>
    <script src="calibration.js"></script>
    <script src="export.js"></script>
    <script src="exclusion-gallery.js"></script>
    <script src="overlays.js"></script>

    <!-- OpenCV.js for computer vision -->
    <script async id="opencvScript" src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCVReady()"></script>

    <script>
        // ============================================
        // Global State
        // ============================================
        const state = {
            views: [],           // Array of view objects with decoder, canvas, etc.
            currentFrame: 0,
            totalFrames: 0,
            fps: 30,
            isPlaying: false,
            playInterval: null,
            opencvReady: false,
            detections: [],      // Detection results per frame
            intrinsics: {},      // Per-camera intrinsic parameters
            extrinsics: {},      // Per-camera extrinsic parameters
            showOverlay: true,
            // Frame exclusions - frames to exclude from calibration (but still shown for assessment)
            exclusions: {
                // Per-camera exclusions for intrinsics (calibration frame indices, not video frames)
                intrinsics: {},  // {cameraName: Set of calibration frame indices}
                // Frame exclusions for extrinsics (video frame numbers)
                extrinsics: new Set(),
            },
            // Thumbnails for exclusion gallery
            frameThumbnails: {},  // {frame: dataURL}
        };

        // Test data paths (relative to vibe root)
        const TEST_DATA_BASE = 'sample_session';
        const TEST_VIEWS = [
            { name: 'back', path: `${TEST_DATA_BASE}/back.mp4` },
            { name: 'mid', path: `${TEST_DATA_BASE}/mid.mp4` },
            { name: 'side', path: `${TEST_DATA_BASE}/side.mp4` },
            { name: 'top', path: `${TEST_DATA_BASE}/top.mp4` },
        ];

        // Video controller (initialized after state, uses hoisted functions)
        const videoController = new VideoController(state, {
            updateSeekbar: function() { updateSeekbar(); },
            drawOverlays: function(frameIndex) { drawAllOverlays(frameIndex); },
            updateGalleryHighlights: function() {
                updateIntrinsicsGalleryCurrentHighlight();
                updateExtrinsicsGalleryCurrentHighlight();
            },
            onPlaybackStateChange: function(isPlaying) {
                document.getElementById('playBtn').textContent = isPlaying ? 'Pause' : 'Play';
            },
            log: function(msg, level) { log(msg, level); }
        });

        // ============================================
        // Logging System
        // ============================================
        const logBody = document.getElementById('logBody');
        const MAX_LOG_ENTRIES = 200;

        function log(msg, level = 'info') {
            const time = new Date().toLocaleTimeString('en-US', {
                hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3
            });
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">${time}</span><span class="log-msg ${level}">${escapeHtml(msg)}</span>`;
            logBody.appendChild(entry);

            while (logBody.children.length > MAX_LOG_ENTRIES) {
                logBody.removeChild(logBody.firstChild);
            }
            logBody.scrollTop = logBody.scrollHeight;

            // Also log to console for debugging
            console.log(`[${level}] ${msg}`);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        document.getElementById('copyLogBtn').addEventListener('click', () => {
            const lines = Array.from(logBody.querySelectorAll('.log-entry')).map(entry => {
                const time = entry.querySelector('.log-time').textContent;
                const msg = entry.querySelector('.log-msg').textContent;
                return `${time} ${msg}`;
            });
            navigator.clipboard.writeText(lines.join('\n')).then(() => {
                log('Log copied to clipboard', 'success');
            });
        });

        document.getElementById('clearLogBtn').addEventListener('click', () => {
            logBody.innerHTML = '';
            log('Log cleared', 'info');
        });

        // ============================================
        // Stage Toggle
        // ============================================
        function toggleStage(stageId) {
            const stage = document.getElementById(stageId);
            stage.classList.toggle('collapsed');
        }

        function setStageStatus(stageId, status, className = '') {
            const statusEl = document.getElementById(`${stageId}Status`);
            statusEl.textContent = status;
            statusEl.className = 'stage-status ' + className;
        }

        // ============================================
        // Error Display
        // ============================================
        function showError(msg) {
            const errorMsg = document.getElementById('errorMsg');
            errorMsg.textContent = msg;
            errorMsg.style.display = 'block';
            log(msg, 'error');
        }

        function hideError() {
            document.getElementById('errorMsg').style.display = 'none';
        }

        // Progress bar utility functions
        function showProgress(progressId) {
            const container = document.getElementById(progressId);
            if (container) {
                container.classList.add('active');
                updateProgress(progressId, 0);
            }
        }

        function updateProgress(progressId, percent, text = null) {
            const container = document.getElementById(progressId);
            if (!container) return;
            const bar = container.querySelector('.progress-bar');
            const textEl = container.querySelector('.progress-text');
            if (bar) bar.style.width = `${percent}%`;
            if (textEl) textEl.textContent = text || `${Math.round(percent)}%`;
        }

        function hideProgress(progressId) {
            const container = document.getElementById(progressId);
            if (container) {
                container.classList.remove('active');
            }
        }

        // ============================================
        // OpenCV.js Ready Handler
        // ============================================
        function onOpenCVReady() {
            state.opencvReady = true;
            log('OpenCV.js loaded successfully', 'success');

            // Enable detection buttons if videos are loaded
            if (state.views.length > 0) {
                document.getElementById('detectCurrentBtn').disabled = false;
                document.getElementById('runDetectionBtn').disabled = false;
            }
        }

        // Check if OpenCV is ready
        if (typeof cv !== 'undefined') {
            onOpenCVReady();
        }

        // ============================================
        // Multi-View Video Loading
        // ============================================
        async function loadTestData() {
            hideError();
            log('Loading test data from sleap-anipose minimal_session...', 'info');
            setStageStatus('stage1', 'Loading...', 'active');

            // Update view list UI
            const viewList = document.getElementById('viewList');
            viewList.innerHTML = TEST_VIEWS.map(v => `
                <div class="view-item">
                    <span class="view-status loading"></span>
                    <span class="view-name">${v.name}</span>
                    <span class="view-path">${v.path}</span>
                </div>
            `).join('');

            const videoGrid = document.getElementById('videoGrid');
            videoGrid.innerHTML = '';
            videoGrid.style.display = 'grid';

            // Show video panel
            document.getElementById('videoPanel').classList.remove('hidden');
            document.getElementById('mainLayout').classList.remove('no-videos');

            state.views = [];

            for (let i = 0; i < TEST_VIEWS.length; i++) {
                const view = TEST_VIEWS[i];
                try {
                    const decoder = new OnDemandVideoDecoder({ cacheSize: 30, lookahead: 5 });
                    const info = await decoder.init(view.path);

                    // Create video cell
                    const cell = document.createElement('div');
                    cell.className = 'video-cell';
                    cell.innerHTML = `
                        <canvas id="canvas-${view.name}"></canvas>
                        <div class="video-label">${view.name}</div>
                        <div class="video-metrics" id="metrics-${view.name}">
                            ${info.width}x${info.height} @ ${info.fps.toFixed(1)} fps | ${info.totalFrames} frames
                        </div>
                    `;
                    videoGrid.appendChild(cell);

                    const canvas = cell.querySelector('canvas');
                    canvas.width = info.width;
                    canvas.height = info.height;

                    state.views.push({
                        name: view.name,
                        decoder: decoder,
                        canvas: canvas,
                        ctx: canvas.getContext('2d'),
                        info: info,
                    });

                    // Setup zoom handlers for this video
                    videoController.setupZoomHandlers(view.name, canvas);

                    // Update status indicator
                    viewList.children[i].querySelector('.view-status').classList.remove('loading');
                    viewList.children[i].querySelector('.view-status').classList.add('loaded');

                    log(`Loaded ${view.name}: ${info.width}x${info.height}, ${info.totalFrames} frames`, 'success');

                } catch (err) {
                    viewList.children[i].querySelector('.view-status').classList.remove('loading');
                    viewList.children[i].querySelector('.view-status').classList.add('error');
                    log(`Failed to load ${view.name}: ${err.message}`, 'error');
                }
            }

            if (state.views.length > 0) {
                // Use minimum frame count across all views
                state.totalFrames = Math.min(...state.views.map(v => v.info.totalFrames));
                state.fps = state.views[0].info.fps;
                state.currentFrame = 0;

                document.getElementById('totalFrames').textContent = state.totalFrames;
                document.getElementById('seekbarContainer').style.display = 'block';
                document.getElementById('videoControls').style.display = 'flex';

                // Show first frame
                await videoController.seekToFrame(0);

                setStageStatus('stage1', `${state.views.length} views loaded`, 'complete');
                setStageStatus('stage2', 'Ready', '');

                // Expand stage 2 and enable detection if OpenCV ready
                document.getElementById('stage2').classList.remove('collapsed');
                if (state.opencvReady) {
                    document.getElementById('detectCurrentBtn').disabled = false;
                    document.getElementById('runDetectionBtn').disabled = false;
                }

                // Show overlay controls section
                document.getElementById('overlayControls').style.display = 'block';

                // Update reference camera dropdown
                const refCamSelect = document.getElementById('referenceCamera');
                refCamSelect.innerHTML = state.views.map((v, i) =>
                    `<option value="${i}">${v.name}</option>`
                ).join('');

                log(`All views loaded. Total synchronized frames: ${state.totalFrames}`, 'success');
            } else {
                setStageStatus('stage1', 'Failed', 'error');
                showError('Failed to load any video views');
            }
        }

        // ============================================
        // Frame Navigation (seekToFrame moved to VideoController in video.js)
        // ============================================
        function updateSeekbar() {
            const progress = state.totalFrames > 0 ? (state.currentFrame / state.totalFrames) * 100 : 0;
            document.getElementById('seekbarProgress').style.width = progress + '%';
            document.getElementById('seekbarThumb').style.left = progress + '%';
            document.getElementById('currentFrame').textContent = state.currentFrame;

            const time = state.currentFrame / state.fps;
            const mins = Math.floor(time / 60);
            const secs = (time % 60).toFixed(3);
            document.getElementById('currentTime').textContent = `${mins}:${secs.padStart(6, '0')}`;
        }

        // ============================================
        // Playback Controls (moved to VideoController in video.js)
        // ============================================

        // ============================================
        // Event Listeners
        // ============================================
        document.getElementById('loadTestDataBtn').addEventListener('click', loadTestData);

        document.getElementById('playBtn').addEventListener('click', () => videoController.togglePlayback());
        document.getElementById('prevFrameBtn').addEventListener('click', () => videoController.seekToFrame(state.currentFrame - 1));
        document.getElementById('nextFrameBtn').addEventListener('click', () => videoController.seekToFrame(state.currentFrame + 1));
        document.getElementById('prev10Btn').addEventListener('click', () => videoController.seekToFrame(state.currentFrame - 10));
        document.getElementById('next10Btn').addEventListener('click', () => videoController.seekToFrame(state.currentFrame + 10));

        // Seekbar scrubbing (logic moved to VideoController)
        function updateSeekbarVisual(frame) {
            const progress = state.totalFrames > 0 ? (frame / state.totalFrames) * 100 : 0;
            document.getElementById('seekbarProgress').style.width = progress + '%';
            document.getElementById('seekbarThumb').style.left = progress + '%';
            document.getElementById('currentFrame').textContent = frame;
        }
        videoController.setupSeekbar(document.getElementById('seekbar'), updateSeekbarVisual);

        // Keyboard shortcuts (logic moved to VideoController)
        videoController.setupKeyboardHandlers();

        // Update computed stride when target samples changes
        document.getElementById('targetSamples').addEventListener('input', () => {
            const target = parseInt(document.getElementById('targetSamples').value) || 50;
            const stride = Math.max(1, Math.floor(state.totalFrames / target));
            document.getElementById('computedStride').textContent = stride;
        });

        // ============================================
        // ChArUco Board Detection (OpenCV.js)
        // ============================================

        // getArucoDictId - use from calibration.js

        function getBoardConfig() {
            return {
                boardX: parseInt(document.getElementById('boardX').value) || 8,
                boardY: parseInt(document.getElementById('boardY').value) || 11,
                squareLength: parseFloat(document.getElementById('squareLength').value) || 24.0,
                markerLength: parseFloat(document.getElementById('markerLength').value) || 18.75,
                dictName: document.getElementById('arucoDict').value,
            };
        }

        // createCharucoBoard, detectCharuco - use from calibration.js

        function detectCharucoInView(viewIndex, config) {
            const view = state.views[viewIndex];
            if (!view) return null;

            // Get current frame as ImageData
            const imageData = view.ctx.getImageData(0, 0, view.canvas.width, view.canvas.height);

            // Use detectCharuco from calibration.js
            const result = detectCharuco(imageData, config);
            result.viewName = view.name;

            return result;
        }

        async function detectCurrentFrame() {
            if (!state.opencvReady) {
                showError('OpenCV.js not loaded yet');
                return;
            }

            if (state.views.length === 0) {
                showError('No videos loaded');
                return;
            }

            log(`Detecting ChArUco board on frame ${state.currentFrame}...`, 'info');
            const config = getBoardConfig();
            log(`Board config: ${config.boardX}x${config.boardY}, dict=${config.dictName}`, 'info');

            // IMPORTANT: Re-render clean video frames before detection
            // The canvas may have overlays drawn on it which would confuse ArUco detection
            const frameResults = await Promise.all(
                state.views.map(view => view.decoder.getFrame(state.currentFrame))
            );
            for (let i = 0; i < state.views.length; i++) {
                const result = frameResults[i];
                const view = state.views[i];
                if (result && result.bitmap) {
                    view.ctx.clearRect(0, 0, view.canvas.width, view.canvas.height);
                    view.ctx.drawImage(result.bitmap, 0, 0);
                }
            }

            const results = [];
            for (let i = 0; i < state.views.length; i++) {
                try {
                    const result = await detectCharucoInView(i, config);
                    results.push(result);
                    log(`${result.viewName}: ${result.numMarkers} markers, ${result.numCharucoCorners} corners (${result.detectTime.toFixed(0)}ms)`,
                        result.numCharucoCorners > 0 ? 'success' : 'warn');
                } catch (err) {
                    log(`${state.views[i].name}: Detection failed - ${err.message}`, 'error');
                    results.push({ viewName: state.views[i].name, error: err.message });
                }
            }

            // Store and visualize results
            state.currentDetection = results;

            if (state.showOverlay) {
                drawDetectionOverlay(results, state);
            }

            return results;
        }

        // Combined overlay drawing function used by VideoController
        function drawAllOverlays(frameIndex) {
            // Sync all overlay state flags with checkbox values
            const detectionsCheck = document.getElementById('detectionsOverlayCheck');
            const intrinsicsCheck = document.getElementById('intrinsicsOverlayCheck');
            const extrinsicsCheck = document.getElementById('extrinsicsOverlayCheck');
            if (detectionsCheck) state.showOverlay = detectionsCheck.checked;
            if (intrinsicsCheck) state.showReprojection = intrinsicsCheck.checked;
            if (extrinsicsCheck) state.showExtrinsicsReproj = extrinsicsCheck.checked;

            // Draw overlays in phases to ensure proper layering:
            // Phase 1: Detection overlay (circles with IDs)
            // Phase 2: All reprojection circles
            // Phase 3: All reprojection markers (on top of circles)
            // Phase 4: Unified legend

            // Phase 1: Draw detection overlay if enabled
            if (state.showOverlay && state.detections.length > 0) {
                const frameDetection = state.detections.find(d => d.frame === frameIndex);
                if (frameDetection) {
                    const results = state.views.map(view => {
                        const viewResult = frameDetection.views[view.name];
                        return viewResult || null;
                    });
                    drawDetectionOverlay(results, state);
                }
            }

            // Phase 2: Draw reprojection circles (both intrinsics and extrinsics)
            if (state.showReprojection && Object.keys(state.intrinsics).length > 0) {
                try {
                    drawReprojectionOverlay(state, 'circles');
                } catch (err) {
                    console.error('Error drawing intrinsics circles:', err);
                }
            }
            if (state.showExtrinsicsReproj && state.extrinsicsReprojData && state.extrinsicsReprojData.length > 0) {
                drawExtrinsicsReprojectionOverlay(state, 'circles');
            }

            // Phase 3: Draw reprojection markers (on top of all circles)
            if (state.showReprojection && Object.keys(state.intrinsics).length > 0) {
                try {
                    drawReprojectionOverlay(state, 'markers');
                } catch (err) {
                    console.error('Error drawing intrinsics markers:', err);
                }
            }
            if (state.showExtrinsicsReproj && state.extrinsicsReprojData && state.extrinsicsReprojData.length > 0) {
                drawExtrinsicsReprojectionOverlay(state, 'markers');
            }

            // Phase 4: Draw unified legend
            drawOverlayLegends(state);
        }

        async function runBatchDetection() {
            if (!state.opencvReady || state.views.length === 0) return;

            const targetSamples = parseInt(document.getElementById('targetSamples').value) || 50;
            const stride = Math.max(1, Math.floor(state.totalFrames / targetSamples));
            const config = getBoardConfig();

            // Calculate total frames to process
            const totalToProcess = Math.ceil(state.totalFrames / stride);

            log(`Starting batch detection: ${targetSamples} target samples, stride=${stride}`, 'info');
            setStageStatus('stage2', 'Detecting...', 'active');
            showProgress('detectionProgress');
            document.getElementById('runDetectionBtn').disabled = true;

            state.detections = [];
            const tableBody = document.getElementById('detectionTableBody');
            tableBody.innerHTML = '';
            document.getElementById('detectionResults').style.display = 'block';

            let processedFrames = 0;
            for (let frame = 0; frame < state.totalFrames; frame += stride) {
                // Seek to frame
                await videoController.seekToFrame(frame);

                // Detect in all views
                const frameResults = {
                    frame: frame,
                    views: {},
                    commonCorners: 0,
                };

                let minCorners = Infinity;
                for (let i = 0; i < state.views.length; i++) {
                    try {
                        const result = await detectCharucoInView(i, config);
                        frameResults.views[state.views[i].name] = result;
                        minCorners = Math.min(minCorners, result.numCharucoCorners);
                    } catch (err) {
                        frameResults.views[state.views[i].name] = { error: err.message, numCharucoCorners: 0 };
                        minCorners = 0;
                    }
                }
                frameResults.commonCorners = minCorners === Infinity ? 0 : minCorners;

                state.detections.push(frameResults);

                // Add to table
                const row = document.createElement('tr');
                row.dataset.frame = frame;
                row.innerHTML = `
                    <td>${frame}</td>
                    ${state.views.map(v => {
                        const r = frameResults.views[v.name];
                        const n = r ? r.numCharucoCorners : 0;
                        const cls = n > 6 ? 'color: #4ade80' : (n > 0 ? 'color: #fbbf24' : 'color: #888');
                        return `<td style="${cls}">${n}</td>`;
                    }).join('')}
                    <td style="${frameResults.commonCorners > 6 ? 'color: #4ade80; font-weight: bold' : ''}">${frameResults.commonCorners}</td>
                `;
                row.addEventListener('click', async () => {
                    await videoController.seekToFrame(frame);
                    // Highlight row
                    tableBody.querySelectorAll('tr').forEach(r => r.classList.remove('selected'));
                    row.classList.add('selected');
                });
                tableBody.appendChild(row);

                processedFrames++;
                const percent = (processedFrames / totalToProcess) * 100;
                updateProgress('detectionProgress', percent, `${processedFrames}/${totalToProcess} frames`);
            }

            hideProgress('detectionProgress');
            const goodFrames = state.detections.filter(d => d.commonCorners >= 6).length;
            log(`Batch detection complete: ${processedFrames} frames, ${goodFrames} with sufficient corners`, 'success');
            setStageStatus('stage2', `${goodFrames} good frames`, 'complete');
            setStageStatus('stage3', 'Ready', '');

            // Enable intrinsics computation and re-enable detection button
            document.getElementById('computeIntrinsicsBtn').disabled = false;
            document.getElementById('runDetectionBtn').disabled = false;

            // Redraw current frame to show detection overlay
            await videoController.seekToFrame(state.currentFrame);
        }

        // Detection event listeners
        document.getElementById('detectCurrentBtn').addEventListener('click', detectCurrentFrame);
        document.getElementById('detectionsOverlayCheck').addEventListener('change', (e) => {
            state.showOverlay = e.target.checked;
            log(`Detection overlay ${state.showOverlay ? 'enabled' : 'disabled'}`, 'info');
            videoController.seekToFrame(state.currentFrame);
        });
        document.getElementById('runDetectionBtn').addEventListener('click', runBatchDetection);

        // ============================================
        // Intrinsic Calibration (core logic in calibration.js)
        // ============================================

        async function computeIntrinsicsForView(viewIndex, config, minCorners) {
            const viewName = state.views[viewIndex].name;
            const viewInfo = state.views[viewIndex].info;
            const imageSize = { width: viewInfo.width, height: viewInfo.height };

            log(`Computing intrinsics for ${viewName}...`, 'info');

            // Extract view detections from global detections
            const viewDetections = [];
            for (const detection of state.detections) {
                const viewResult = detection.views[viewName];
                if (!viewResult || viewResult.error) continue;
                viewDetections.push({
                    frame: detection.frame,
                    charucoCorners: viewResult.charucoCorners,
                    charucoIds: viewResult.charucoIds,
                    numCharucoCorners: viewResult.numCharucoCorners
                });
            }

            // Get exclusions for this view
            const exclusions = state.exclusions.intrinsics[viewName] || new Set();

            if (exclusions.size > 0) {
                log(`${viewName}: ${exclusions.size} frames excluded`, 'info');
            }

            try {
                // Use computeIntrinsicsForCamera from calibration.js
                const result = computeIntrinsicsForCamera(viewDetections, imageSize, config, minCorners, exclusions);

                if (!result) {
                    log(`${viewName}: Insufficient frames with detections`, 'error');
                    return null;
                }

                // Add viewName to result
                result.viewName = viewName;

                log(`${viewName}: Using ${result.framesUsed} frames for calibration`, 'info');
                log(`${viewName}: RMS=${result.rmsError.toFixed(4)}, fx=${result.fx.toFixed(1)}, fy=${result.fy.toFixed(1)}, cx=${result.cx.toFixed(1)}, cy=${result.cy.toFixed(1)}`, 'success');
                log(`${viewName}: Distortion k1=${result.k1.toFixed(6)}, k2=${result.k2.toFixed(6)}, p1=${result.p1.toFixed(6)}, p2=${result.p2.toFixed(6)}, k3=${result.k3.toFixed(6)}`, 'info');

                return result;

            } catch (err) {
                log(`${viewName}: Calibration failed - ${err.message}`, 'error');
                console.error('Calibration error:', err);
                return null;
            }
        }

        async function computeAllIntrinsics() {
            if (state.detections.length === 0) {
                showError('No detections available. Run batch detection first.');
                return;
            }

            const minCorners = parseInt(document.getElementById('minCorners').value) || 6;
            const config = getBoardConfig();
            const totalCameras = state.views.length;

            log(`Computing intrinsics for all cameras (min corners: ${minCorners})...`, 'info');
            setStageStatus('stage3', 'Computing...', 'active');
            showProgress('intrinsicsProgress');
            document.getElementById('computeIntrinsicsBtn').disabled = true;

            state.intrinsics = {};
            const tableBody = document.getElementById('intrinsicsTableBody');
            tableBody.innerHTML = '';
            document.getElementById('intrinsicsResults').style.display = 'block';

            let successCount = 0;
            for (let i = 0; i < state.views.length; i++) {
                updateProgress('intrinsicsProgress', ((i + 0.5) / totalCameras) * 100, `Camera ${i + 1}/${totalCameras}`);
                const result = await computeIntrinsicsForView(i, config, minCorners);
                if (result) {
                    state.intrinsics[state.views[i].name] = result;
                    successCount++;

                    // Add to table
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td><strong>${result.viewName}</strong></td>
                        <td>${result.fx.toFixed(2)}</td>
                        <td>${result.fy.toFixed(2)}</td>
                        <td>${result.cx.toFixed(2)}</td>
                        <td>${result.cy.toFixed(2)}</td>
                        <td>${result.k1.toFixed(6)}</td>
                        <td>${result.k2.toFixed(6)}</td>
                        <td style="color: ${result.rmsError < 1 ? '#4ade80' : (result.rmsError < 2 ? '#fbbf24' : '#ff6b6b')}">${result.rmsError.toFixed(4)}</td>
                    `;
                    tableBody.appendChild(row);
                }
                updateProgress('intrinsicsProgress', ((i + 1) / totalCameras) * 100, `Camera ${i + 1}/${totalCameras}`);
            }

            // Draw swarm plot after all intrinsics are computed
            if (successCount > 0) {
                drawSwarmPlot(state);
            }

            hideProgress('intrinsicsProgress');
            document.getElementById('computeIntrinsicsBtn').disabled = false;

            if (successCount === state.views.length) {
                log(`Intrinsic calibration complete for all ${successCount} cameras`, 'success');
                setStageStatus('stage3', 'Complete', 'complete');
                setStageStatus('stage4', 'Ready', '');

                // Enable extrinsics computation
                document.getElementById('computeExtrinsicsBtn').disabled = false;

                // Draw reprojection overlay if checkbox is checked
                if (document.getElementById('intrinsicsOverlayCheck').checked) {
                    state.showReprojection = true;
                    // Try to preserve current frame if it has calibration data
                    const firstIntrinsics = Object.values(state.intrinsics)[0];
                    if (firstIntrinsics && firstIntrinsics.frameIndices) {
                        const currentIdx = firstIntrinsics.frameIndices.indexOf(state.currentFrame);
                        if (currentIdx !== -1) {
                            state.reprojectionFrameIndex = currentIdx;
                        } else {
                            state.reprojectionFrameIndex = 0;
                        }
                    }
                    // Redraw current frame with overlay (don't navigate away)
                    await videoController.seekToFrame(state.currentFrame);
                }

                // Expand stage 4
                document.getElementById('stage4').classList.remove('collapsed');
            } else {
                log(`Intrinsic calibration completed for ${successCount}/${state.views.length} cameras`, 'warn');
                setStageStatus('stage3', `${successCount}/${state.views.length} complete`, 'error');

                // Draw reprojection overlay if checkbox is checked and any cameras succeeded
                if (successCount > 0 && document.getElementById('intrinsicsOverlayCheck').checked) {
                    state.showReprojection = true;
                    // Try to preserve current frame if it has calibration data
                    const firstIntrinsics = Object.values(state.intrinsics)[0];
                    if (firstIntrinsics && firstIntrinsics.frameIndices) {
                        const currentIdx = firstIntrinsics.frameIndices.indexOf(state.currentFrame);
                        if (currentIdx !== -1) {
                            state.reprojectionFrameIndex = currentIdx;
                        } else {
                            state.reprojectionFrameIndex = 0;
                        }
                    }
                    // Redraw current frame with overlay (don't navigate away)
                    await videoController.seekToFrame(state.currentFrame);
                }
            }

            // Build the exclusion gallery after intrinsics are computed
            if (successCount > 0) {
                await buildIntrinsicsExclusionGallery();
            }
        }

        // Intrinsics event listeners
        document.getElementById('computeIntrinsicsBtn').addEventListener('click', computeAllIntrinsics);

        // ============================================
        // Reprojection Visualization
        // ============================================

        // State for reprojection visualization
        state.showReprojection = false;
        state.reprojectionFrameIndex = 0;

        async function setIntrinsicsOverlay(enabled) {
            state.showReprojection = enabled;

            if (enabled) {
                log('Intrinsics reprojection overlay enabled. Use [ and ] to navigate frames.', 'info');
            } else {
                log('Intrinsics reprojection overlay disabled', 'info');
            }
            // Redraw current frame with updated overlay state
            await videoController.seekToFrame(state.currentFrame);
        }

        async function navigateReprojectionFrame(delta) {
            if (!state.showReprojection || Object.keys(state.intrinsics).length === 0) return;

            const firstIntrinsics = Object.values(state.intrinsics)[0];
            const maxFrames = firstIntrinsics.objectPoints.length;

            state.reprojectionFrameIndex = (state.reprojectionFrameIndex + delta + maxFrames) % maxFrames;

            // Get the actual video frame number for this reprojection index
            const videoFrame = firstIntrinsics.frameIndices ? firstIntrinsics.frameIndices[state.reprojectionFrameIndex] : state.reprojectionFrameIndex;
            log(`Viewing reprojection frame ${state.reprojectionFrameIndex + 1}/${maxFrames} (video frame ${videoFrame})`, 'info');

            // Seek to the correct video frame (overlay drawn automatically)
            await videoController.seekToFrame(videoFrame);
        }

        // Add keyboard navigation for reprojection frames
        document.addEventListener('keydown', (e) => {
            if (state.showReprojection) {
                if (e.key === '[') {
                    navigateReprojectionFrame(-1);
                } else if (e.key === ']') {
                    navigateReprojectionFrame(1);
                }
            }
        });

        document.getElementById('intrinsicsOverlayCheck').addEventListener('change', (e) => {
            setIntrinsicsOverlay(e.target.checked);
        });

        // ============================================
        // Swarm Plot Visualization
        // ============================================

        // Store swarm plot dot positions for hover detection
        state.swarmDots = [];

        // Initialize swarm plot hover after DOM is ready
        setupSwarmPlotHover(state, videoController);

        // ============================================
        // Frame Exclusion Management (uses exclusion-gallery.js)
        // ============================================
        // Setup exclusion keyboard shortcuts and event listeners
        setupExclusionKeyboardShortcut();
        setupExclusionEventListeners();

        // ============================================
        // Extrinsic Calibration
        // ============================================

        // buildCovisibilityGraph - use from calibration.js
        // getMatchedPointsForFrame - use from calibration.js
        // computeBoardPose - use from calibration.js
        // computeRelativePose - use from calibration.js
        // findPoseChain - use from calibration.js

        async function computeAllExtrinsics() {
            if (Object.keys(state.intrinsics).length === 0) {
                showError('No intrinsics available. Compute intrinsics first.');
                return;
            }

            const minCovisible = parseInt(document.getElementById('minCovisible').value) || 10;
            const refCamIndex = parseInt(document.getElementById('referenceCamera').value) || 0;
            const refViewName = state.views[refCamIndex].name;
            const config = getBoardConfig();
            const viewNames = state.views.map(v => v.name);

            log(`Computing extrinsics with reference camera: ${refViewName}`, 'info');
            setStageStatus('stage4', 'Computing...', 'active');
            showProgress('extrinsicsProgress');
            document.getElementById('computeExtrinsicsBtn').disabled = true;

            updateProgress('extrinsicsProgress', 10, 'Building covisibility...');

            // Build covisibility graph (filter excluded frames, use calibration.js function)
            const filteredDetections = state.detections.filter(d => !isExtrinsicsFrameExcluded(d.frame));
            const graph = buildCovisibilityGraph(filteredDetections, viewNames, minCovisible);

            // Log covisibility
            for (const view1 of viewNames) {
                for (const view2 of viewNames) {
                    if (view1 < view2) {
                        const count = graph[view1][view2].length;
                        log(`Covisibility ${view1}-${view2}: ${count} frames`, count > 0 ? 'info' : 'warn');
                    }
                }
            }

            updateProgress('extrinsicsProgress', 20, 'Finding pose chain...');

            // Find path from reference to all other cameras (use calibration.js function)
            const parent = findPoseChain(graph, refViewName, viewNames);

            // Check if all cameras are reachable
            for (const viewName of viewNames) {
                if (viewName !== refViewName && !parent[viewName]) {
                    log(`Camera ${viewName} not reachable from ${refViewName}!`, 'error');
                }
            }

            updateProgress('extrinsicsProgress', 30, 'Computing poses...');

            // Compute absolute extrinsics using calibration.js
            const result = computeAbsoluteExtrinsics(graph, parent, filteredDetections, config, state.intrinsics, refViewName, viewNames);
            state.extrinsics = result.extrinsics;

            // Log computed poses
            for (const viewName of viewNames) {
                if (viewName === refViewName) continue;
                const ext = state.extrinsics[viewName];
                if (ext) {
                    log(`${viewName}: R=[${ext.rvec.map(v => v.toFixed(4)).join(', ')}], T=[${ext.tvec.map(v => v.toFixed(2)).join(', ')}]`, 'success');
                }
            }

            // Update extrinsics table
            const tableBody = document.getElementById('extrinsicsTableBody');
            tableBody.innerHTML = '';
            document.getElementById('extrinsicsResults').style.display = 'block';

            for (const viewName of viewNames) {
                const ext = state.extrinsics[viewName];
                if (!ext) continue;

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><strong>${ext.viewName}</strong></td>
                    <td>${ext.rvec[0].toFixed(6)}</td>
                    <td>${ext.rvec[1].toFixed(6)}</td>
                    <td>${ext.rvec[2].toFixed(6)}</td>
                    <td>${ext.tvec[0].toFixed(2)}</td>
                    <td>${ext.tvec[1].toFixed(2)}</td>
                    <td>${ext.tvec[2].toFixed(2)}</td>
                `;
                tableBody.appendChild(row);
            }

            // Log exclusion info
            const excludedCount = state.exclusions.extrinsics.size;
            if (excludedCount > 0) {
                log(`Extrinsic calibration complete (${excludedCount} frames excluded)`, 'success');
            } else {
                log(`Extrinsic calibration complete`, 'success');
            }

            updateProgress('extrinsicsProgress', 85, 'Computing reprojection...');

            // Compute cross-view reprojection errors (includes all frames for assessment)
            log('Computing cross-view reprojection errors...', 'info');
            // computeCrossViewReprojectionErrors - use from calibration.js (uses viewNames from above)
            state.extrinsicsReprojData = await computeCrossViewReprojectionErrors(state.detections, viewNames, state.intrinsics, state.extrinsics);
            if (state.extrinsicsReprojData.length > 0) {
                const totalPoints = state.extrinsicsReprojData.reduce((sum, f) => sum + f.pointErrors.length, 0);
                log(`Cross-view reprojection: ${totalPoints} points triangulated across ${state.extrinsicsReprojData.length} frames`, 'success');
                drawExtrinsicsSwarmPlot(state);

                // Draw extrinsics reprojection overlay if checkbox is checked
                if (document.getElementById('extrinsicsOverlayCheck').checked) {
                    state.showExtrinsicsReproj = true;
                    // Try to preserve current frame if it has extrinsics data
                    const currentIdx = state.extrinsicsReprojData.findIndex(d => d.frame === state.currentFrame);
                    if (currentIdx !== -1) {
                        state.extrinsicsReprojFrameIndex = currentIdx;
                    } else {
                        state.extrinsicsReprojFrameIndex = 0;
                    }
                    // Redraw current frame with overlay (don't navigate away)
                    await videoController.seekToFrame(state.currentFrame);
                }

                // Build the exclusion gallery
                await buildExtrinsicsExclusionGallery();
            } else {
                log('No cross-view reprojection data available', 'warn');
            }

            hideProgress('extrinsicsProgress');
            document.getElementById('computeExtrinsicsBtn').disabled = false;

            setStageStatus('stage4', 'Complete', 'complete');
            setStageStatus('stage5', 'Ready', '');

            // Enable export and update preview
            document.getElementById('exportTomlBtn').disabled = false;
            document.getElementById('exportSbaJsonBtn').disabled = false;
            document.getElementById('runBundleBtn').disabled = false;
            doUpdateTomlPreview();

            // Expand stage 5
            document.getElementById('stage5').classList.remove('collapsed');
        }

        // Extrinsics event listeners
        document.getElementById('computeExtrinsicsBtn').addEventListener('click', computeAllExtrinsics);

        // ============================================
        // Cross-View Reprojection Visualization
        // ============================================

        // State for extrinsics reprojection
        state.showExtrinsicsReproj = false;
        state.extrinsicsReprojFrameIndex = 0;
        state.extrinsicsReprojData = null;
        state.extrinsicsSwarmDots = [];

        // triangulatePoint - use from calibration.js
        // projectPoint - use from calibration.js
        // computeCrossViewReprojectionErrors - use from calibration.js

        async function setExtrinsicsOverlay(enabled) {
            state.showExtrinsicsReproj = enabled;

            if (enabled) {
                log('Extrinsics reprojection overlay enabled. Use [ and ] to navigate frames.', 'info');
            } else {
                log('Extrinsics reprojection overlay disabled', 'info');
            }
            // Redraw current frame with updated overlay state
            await videoController.seekToFrame(state.currentFrame);
        }

        async function navigateExtrinsicsReprojFrame(delta) {
            if (!state.showExtrinsicsReproj || !state.extrinsicsReprojData || state.extrinsicsReprojData.length === 0) return;

            const maxFrames = state.extrinsicsReprojData.length;
            state.extrinsicsReprojFrameIndex = (state.extrinsicsReprojFrameIndex + delta + maxFrames) % maxFrames;

            // Get the video frame for this extrinsics reprojection index
            const videoFrame = state.extrinsicsReprojData[state.extrinsicsReprojFrameIndex].frame;
            log(`Viewing extrinsics reprojection frame ${state.extrinsicsReprojFrameIndex + 1}/${maxFrames} (video frame ${videoFrame})`, 'info');

            // Seek to the correct video frame (overlay drawn automatically)
            await videoController.seekToFrame(videoFrame);
        }

        // Keyboard navigation for extrinsics reprojection
        document.addEventListener('keydown', (e) => {
            if (state.showExtrinsicsReproj) {
                if (e.key === '{') {
                    navigateExtrinsicsReprojFrame(-1);
                } else if (e.key === '}') {
                    navigateExtrinsicsReprojFrame(1);
                }
            }
        });

        setupExtrinsicsSwarmHover(state, videoController);
        document.getElementById('extrinsicsOverlayCheck').addEventListener('change', (e) => {
            setExtrinsicsOverlay(e.target.checked);
        });

        // ============================================
        // TOML Export (uses export.js module)
        // ============================================

        function doUpdateTomlPreview() {
            updateTomlPreview(state, state.views.map(v => v.name));
        }

        function doExportToml() {
            const viewNames = state.views.map(v => v.name);
            exportToml(state, viewNames);
            setStageStatus('stage5', 'Exported', 'complete');
        }

        // Export event listener
        document.getElementById('exportTomlBtn').addEventListener('click', doExportToml);

        // ============================================
        // SBA JSON Export (uses export.js module)
        // ============================================

        function doExportSbaJson() {
            const viewNames = state.views.map(v => v.name);
            const config = getBoardConfig();
            exportSbaJson(state, viewNames, config);
        }

        document.getElementById('exportSbaJsonBtn').addEventListener('click', doExportSbaJson);

        // ============================================
        // Bundle Adjustment (SBA) Integration
        // ============================================

        // Update intrinsics table from current state
        function updateIntrinsicsTable() {
            const tableBody = document.getElementById('intrinsicsTableBody');
            tableBody.innerHTML = '';
            for (const viewName of state.views.map(v => v.name)) {
                const result = state.intrinsics[viewName];
                if (!result) continue;
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><strong>${result.viewName || viewName}</strong></td>
                    <td>${result.fx.toFixed(2)}</td>
                    <td>${result.fy.toFixed(2)}</td>
                    <td>${result.cx.toFixed(2)}</td>
                    <td>${result.cy.toFixed(2)}</td>
                    <td>${result.k1.toFixed(6)}</td>
                    <td>${result.k2.toFixed(6)}</td>
                    <td style="color: ${result.rmsError < 1 ? '#4ade80' : (result.rmsError < 2 ? '#fbbf24' : '#ff6b6b')}">${result.rmsError.toFixed(4)}</td>
                `;
                tableBody.appendChild(row);
            }
        }

        // Update extrinsics table from current state
        function updateExtrinsicsTable() {
            const tableBody = document.getElementById('extrinsicsTableBody');
            tableBody.innerHTML = '';
            for (const viewName of state.views.map(v => v.name)) {
                const ext = state.extrinsics[viewName];
                if (!ext) continue;
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><strong>${ext.viewName || viewName}</strong></td>
                    <td>${ext.rvec[0].toFixed(6)}</td>
                    <td>${ext.rvec[1].toFixed(6)}</td>
                    <td>${ext.rvec[2].toFixed(6)}</td>
                    <td>${ext.tvec[0].toFixed(2)}</td>
                    <td>${ext.tvec[1].toFixed(2)}</td>
                    <td>${ext.tvec[2].toFixed(2)}</td>
                `;
                tableBody.appendChild(row);
            }
        }

        // SBA helper wrappers (uses calibration.js module functions)
        function doPrepareSbaInput() {
            const viewNames = state.views.map(v => v.name);
            const config = getBoardConfig();
            // Pass generateSbaJsonOutput from export.js to prepareSbaInput from calibration.js
            return prepareSbaInput(state, viewNames, config, generateSbaJsonOutput);
        }

        function doApplySbaResults(sbaResult, cameraNames) {
            applySbaResults(sbaResult, state, cameraNames);
        }

        // Main SBA handler
        async function runSbaRefinement() {
            const btn = document.getElementById('runBundleBtn');
            btn.disabled = true;
            btn.textContent = 'Running SBA...';

            showProgress('extrinsicsProgress');
            updateProgress('extrinsicsProgress', 0, 'Preparing data...');

            try {
                // Prepare input data
                const sbaInput = doPrepareSbaInput();
                if (!sbaInput) {
                    throw new Error('Failed to prepare SBA input data');
                }
                log(`SBA input: ${sbaInput.metadata.num_cameras} cameras, ` +
                    `${sbaInput.metadata.num_points} points, ` +
                    `${sbaInput.metadata.num_observations} observations`, 'info');

                updateProgress('extrinsicsProgress', 10, 'Loading WASM module...');

                // Dynamically import the SBA module from CDN
                const { runBundleAdjustment, initSBA } = await import(
                    'https://cdn.jsdelivr.net/npm/@talmolab/sba-solver-wasm@0.2.0/wrapper.js'
                );

                updateProgress('extrinsicsProgress', 15, 'Initializing solver...');
                await initSBA();

                updateProgress('extrinsicsProgress', 20, 'Running optimization...');

                // Read SBA settings from UI
                const sbaConfig = {
                    max_iterations: parseInt(document.getElementById('sbaMaxIterations').value) || 100,
                    robust_loss: document.getElementById('sbaRobustLoss').value || 'huber',
                    robust_loss_param: parseFloat(document.getElementById('sbaLossParam').value) || 1.0,
                    optimize_extrinsics: document.getElementById('sbaOptExtrinsics').checked,
                    optimize_points: document.getElementById('sbaOptPoints').checked,
                    optimize_intrinsics: document.getElementById('sbaOptIntrinsics').checked,
                    outlier_threshold: parseFloat(document.getElementById('sbaOutlierThreshold').value) || 0,
                    reference_camera: parseInt(document.getElementById('referenceCamera').value) || 0,
                    cost_tolerance: parseFloat(document.getElementById('sbaCostTol').value) || 1e-6,
                    parameter_tolerance: parseFloat(document.getElementById('sbaParamTol').value) || 1e-8,
                    gradient_tolerance: parseFloat(document.getElementById('sbaGradTol').value) || 1e-10
                };

                log(`SBA config: ${sbaConfig.max_iterations} iters, ${sbaConfig.robust_loss} loss (${sbaConfig.robust_loss_param}), ` +
                    `outlier=${sbaConfig.outlier_threshold}px, ref_cam=${sbaConfig.reference_camera}`, 'info');

                // Run bundle adjustment
                const result = await runBundleAdjustment({
                    cameras: sbaInput.cameras,
                    points: sbaInput.points,
                    observations: sbaInput.observations,
                    point_to_frame: sbaInput.point_to_frame
                }, sbaConfig);

                updateProgress('extrinsicsProgress', 80, 'Applying results...');

                // Log results
                const improvement = ((result.initial_cost - result.final_cost) / result.initial_cost * 100);
                log(`SBA completed: ${result.iterations} iterations, ` +
                    `cost ${result.initial_cost.toFixed(2)} → ${result.final_cost.toFixed(2)} ` +
                    `(${improvement.toFixed(1)}% improvement)`, 'success');

                if (result.num_observations_filtered > 0) {
                    log(`Filtered ${result.num_observations_filtered} outlier observations`, 'info');
                }

                // Apply refined parameters to state
                doApplySbaResults(result, sbaInput.metadata.camera_names);

                updateProgress('extrinsicsProgress', 90, 'Updating visualizations...');

                // Recompute cross-view reprojection errors with refined params (use calibration.js function)
                const viewNamesForReproj = state.views.map(v => v.name);
                state.extrinsicsReprojData = await computeCrossViewReprojectionErrors(state.detections, viewNamesForReproj, state.intrinsics, state.extrinsics);

                // Update UI tables and galleries
                updateIntrinsicsTable();
                updateExtrinsicsTable();
                drawSwarmPlot(state);
                drawExtrinsicsSwarmPlot(state);
                await buildExtrinsicsExclusionGallery();
                doUpdateTomlPreview();

                updateProgress('extrinsicsProgress', 100, 'Complete!');

                log(`Bundle Adjustment complete! Cost reduction: ${improvement.toFixed(1)}%`, 'success');

            } catch (err) {
                console.error('SBA error:', err);
                log(`Bundle Adjustment Error: ${err.message}`, 'error');
            } finally {
                hideProgress('extrinsicsProgress');
                btn.disabled = false;
                btn.textContent = 'Refine (Bundle Adjustment)';
            }
        }

        document.getElementById('runBundleBtn').addEventListener('click', runSbaRefinement);

        // ============================================
        // Resize Handle
        // ============================================
        const resizeHandle = document.getElementById('resizeHandle');
        const videoPanel = document.getElementById('videoPanel');
        const mainLayout = document.getElementById('mainLayout');
        let isResizing = false;

        resizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizeHandle.classList.add('dragging');
            mainLayout.classList.add('resizing');
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;

            const containerRect = mainLayout.getBoundingClientRect();
            const newWidth = e.clientX - containerRect.left;
            const containerWidth = containerRect.width;

            // Clamp between 20% and 80%
            const minWidth = containerWidth * 0.2;
            const maxWidth = containerWidth * 0.8;
            const clampedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));

            const percentage = (clampedWidth / containerWidth) * 100;
            videoPanel.style.width = percentage + '%';
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                resizeHandle.classList.remove('dragging');
                mainLayout.classList.remove('resizing');
            }
        });

        // ============================================
        // Initialize
        // ============================================
        log('Multi-Camera Calibration GUI initialized', 'info');
        log('Waiting for OpenCV.js to load...', 'info');

        // Check WebCodecs support
        if (!('VideoDecoder' in window)) {
            showError('WebCodecs API not supported in this browser. Please use Chrome, Edge, or a recent Firefox.');
        }
    </script>
</body>
</html>
