<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Event Annotator</title>
    <style>
        * { box-sizing: border-box; }
        body { font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 20px; background: #1a1a1a; color: #e0e0e0; }
        h1 { margin-bottom: 0.5rem; color: #fff; }
        .description { color: #aaa; margin-top: 0; font-size: 14px; }
        .container { max-width: 1200px; margin: 0 auto; }
        .controls { background: #2a2a2a; padding: 10px; border-radius: 8px; margin: 15px 0; text-align: center; }
        button { background: #667eea; color: white; border: none; padding: 6px 14px; border-radius: 6px; font-size: 13px; cursor: pointer; margin: 3px; }
        button:hover { background: #5568d3; }
        button:disabled { background: #444; cursor: not-allowed; }
        .canvas-container { position: relative; background: #000; border-radius: 8px 8px 0 0; overflow: hidden; margin: 15px 0 0 0; height: 45vh; min-height: 200px; cursor: grab; }
        .canvas-container:active { cursor: grabbing; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: crisp-edges; }
        .resize-handle { height: 8px; background: #2a2a2a; border-radius: 0 0 8px 8px; cursor: ns-resize; display: flex; justify-content: center; align-items: center; margin-bottom: 10px; }
        .resize-handle:hover { background: #3a3a3a; }
        .resize-handle::after { content: ''; width: 40px; height: 3px; background: #555; border-radius: 2px; }
        .seekbar-container { background: #2a2a2a; padding: 12px 15px; border-radius: 8px; margin: 10px 0; }
        .seekbar { width: 100%; height: 6px; background: #444; border-radius: 3px; position: relative; cursor: pointer; margin: 8px 0; }
        .seekbar-progress { height: 100%; background: #667eea; border-radius: 3px; width: 0%; pointer-events: none; }
        .seekbar-thumb { position: absolute; width: 14px; height: 14px; background: white; border-radius: 50%; top: 50%; transform: translate(-50%, -50%); left: 0%; pointer-events: none; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .playback-controls { display: flex; justify-content: center; align-items: center; gap: 5px; margin-top: 8px; }
        .playback-controls button { width: 28px; height: 28px; padding: 0; font-size: 11px; }
        .control-separator { width: 1px; height: 18px; background: #444; margin: 0 6px; }
        .timeline-container { background: #2a2a2a; padding: 12px 15px; border-radius: 8px; margin: 10px 0; }
        .timeline-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .timeline-header h3 { margin: 0; font-size: 13px; color: #fff; }
        .timeline-track { position: relative; height: 28px; background: #333; border-radius: 4px; margin: 6px 0; cursor: crosshair; }
        .timeline-track-label { position: absolute; left: 6px; top: 50%; transform: translateY(-50%); font-size: 10px; color: #888; z-index: 10; pointer-events: none; }
        .timeline-playhead { position: absolute; width: 2px; height: 100%; background: #fff; top: 0; pointer-events: none; z-index: 20; }
        .timeline-segment { position: absolute; height: 100%; border-radius: 4px; opacity: 0.8; cursor: pointer; transition: opacity 0.15s; }
        .timeline-segment:hover { opacity: 1; }
        .timeline-segment.selected { opacity: 1; box-shadow: 0 0 0 2px #fff; }
        .timeline-segment.active { opacity: 1; animation: marquee-pulse 0.4s infinite; border: 2px dashed rgba(255,255,255,0.8); }
        @keyframes marquee-pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .annotation-status { background: #2a2a2a; padding: 8px 15px; border-radius: 8px; margin: 10px 0; display: flex; align-items: center; gap: 12px; font-size: 13px; flex-wrap: wrap; }
        .status-label { color: #888; }
        .status-value { font-weight: bold; }
        .status-idle { color: #888; }
        .status-painting { color: #4ade80; }
        .event-types { background: #2a2a2a; padding: 12px 15px; border-radius: 8px; margin: 10px 0; }
        .event-types h3 { margin: 0 0 8px 0; font-size: 13px; color: #fff; }
        .event-type-buttons { display: flex; flex-wrap: wrap; gap: 6px; }
        .event-type-btn { display: flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 5px; cursor: pointer; font-size: 12px; }
        .event-type-btn:hover { transform: translateY(-1px); }
        .event-type-btn .hotkey { background: rgba(0,0,0,0.3); padding: 2px 5px; border-radius: 3px; font-size: 10px; font-family: monospace; }
        .info-row { display: flex; gap: 10px; margin: 10px 0; }
        .metrics { flex: 1; background: #2a2a2a; padding: 10px 15px; border-radius: 8px; font-family: monospace; font-size: 11px; }
        .metrics h3 { margin: 0 0 6px 0; font-size: 12px; color: #ccc; font-family: system-ui; }
        .metric { margin: 3px 0; }
        .metric-label { color: #667eea; }
        .hotkeys { background: #2a2a2a; padding: 12px 15px; border-radius: 8px; margin: 15px 0; font-size: 12px; }
        .hotkeys h3 { margin: 0 0 8px 0; color: #fff; font-size: 13px; }
        .hotkeys-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 4px 12px; }
        .hotkey { display: flex; gap: 6px; }
        .hotkey-key { color: #667eea; font-family: monospace; min-width: 65px; }
        .hotkey-desc { color: #aaa; }
        .error-msg { background: #4a2020; border: 1px solid #ff6b6b; color: #ff6b6b; padding: 10px 15px; border-radius: 8px; margin: 10px 0; display: none; font-size: 13px; }
        @media (max-width: 600px) { body { padding: 10px; } .info-row { flex-direction: column; } }
    </style>
</head>
<body>
    <div class="container">
        <h1>Video Event Annotator</h1>
        <p class="description">Frame-accurate event annotation with zoom/pan. Press hotkeys to paint segments.</p>
        <div class="controls">
            <input type="file" id="fileInput" accept="video/mp4,video/webm,.mp4,.webm" style="display: none;">
            <input type="file" id="importInput" accept=".json" style="display: none;">
            <button id="loadBtn">Load Video</button>
            <button id="demoBtn">Load Demo</button>
            <button id="importBtn" disabled>Import</button>
            <button id="exportBtn" disabled>Export</button>
            <button id="clearBtn" disabled>Clear</button>
        </div>
        <div class="error-msg" id="errorMsg"></div>
        <div class="canvas-container" id="canvasContainer" style="display: none;"><canvas id="canvas"></canvas></div>
        <div class="resize-handle" id="resizeHandle" style="display: none;"></div>
        <div class="seekbar-container" id="seekbarContainer" style="display: none;">
            <div class="seekbar" id="seekbar"><div class="seekbar-progress" id="seekbarProgress"></div><div class="seekbar-thumb" id="seekbarThumb"></div></div>
            <div class="playback-controls">
                <button id="firstFrameBtn" title="First frame">|&#10094;</button>
                <button id="prevFrameBtn" title="Previous frame">&#10094;</button>
                <button id="playBtn">&#9654;</button>
                <button id="nextFrameBtn" title="Next frame">&#10095;</button>
                <button id="lastFrameBtn" title="Last frame">&#10095;|</button>
                <span class="control-separator"></span>
                <button id="zoomOutBtn" title="Zoom out">&#8722;</button>
                <button id="zoomInBtn" title="Zoom in">+</button>
                <button id="resetZoomBtn" title="Reset view">&#8634;</button>
            </div>
        </div>
        <div class="annotation-status" id="annotationStatus" style="display: none;">
            <span class="status-label">Mode:</span><span class="status-value status-idle" id="modeDisplay">IDLE</span>
            <span class="status-label">Frame:</span><span class="status-value" id="frameDisplay">0 / 0</span>
            <span id="paintingInfo" style="display: none;"><span class="status-label">Painting:</span><span class="status-value status-painting" id="paintingDisplay"></span></span>
        </div>
        <div class="timeline-container" id="timelineContainer" style="display: none;">
            <div class="timeline-header"><h3>Event Timeline</h3><span id="selectedSegmentInfo" style="font-size: 11px; color: #888;"></span></div>
            <div id="timelineTracks"></div>
        </div>
        <div class="event-types" id="eventTypesContainer" style="display: none;">
            <h3>Event Types (press hotkey to annotate)</h3>
            <div class="event-type-buttons" id="eventTypeButtons"></div>
        </div>
        <div class="info-row" id="infoRow" style="display: none;">
            <div class="metrics"><h3>Video</h3><div class="metric"><span class="metric-label">File:</span> <span id="metricFile">-</span></div><div class="metric"><span class="metric-label">Size:</span> <span id="metricRes">-</span></div><div class="metric"><span class="metric-label">FPS:</span> <span id="metricFps">-</span></div></div>
            <div class="metrics"><h3>Annotations</h3><div class="metric"><span class="metric-label">Segments:</span> <span id="metricSegments">0</span></div><div class="metric"><span class="metric-label">Tracks:</span> <span id="metricTracks">0</span></div></div>
        </div>
        <div class="hotkeys">
            <h3>Keyboard Shortcuts</h3>
            <div class="hotkeys-grid">
                <div class="hotkey"><span class="hotkey-key">&#8592;/&#8594;</span><span class="hotkey-desc">&#177;1 frame</span></div>
                <div class="hotkey"><span class="hotkey-key">Ctrl+&#8592;/&#8594;</span><span class="hotkey-desc">&#177;30 frames</span></div>
                <div class="hotkey"><span class="hotkey-key">Home/End</span><span class="hotkey-desc">First/Last</span></div>
                <div class="hotkey"><span class="hotkey-key">Space</span><span class="hotkey-desc">Play/Pause</span></div>
                <div class="hotkey"><span class="hotkey-key">&#8593;/&#8595;</span><span class="hotkey-desc">Zoom</span></div>
                <div class="hotkey"><span class="hotkey-key">Wheel</span><span class="hotkey-desc">Zoom</span></div>
                <div class="hotkey"><span class="hotkey-key">Drag</span><span class="hotkey-desc">Pan</span></div>
                <div class="hotkey"><span class="hotkey-key">W R E</span><span class="hotkey-desc">Events</span></div>
                <div class="hotkey"><span class="hotkey-key">X</span><span class="hotkey-desc">Eraser</span></div>
                <div class="hotkey"><span class="hotkey-key">Escape</span><span class="hotkey-desc">Cancel</span></div>
                <div class="hotkey"><span class="hotkey-key">Delete</span><span class="hotkey-desc">Remove</span></div>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/mp4box@0.5.2/dist/mp4box.all.min.js"></script>
    <script>
        const state = {
            videoDecoder: null, currentFrame: 0, totalFrames: 0, fps: 0, fileName: '', videoInfo: null, isPlaying: false, playInterval: null,
            mode: 'idle', activeAnnotation: null, selectedSegmentId: null,
            eventTypes: [
                { id: 'walking', name: 'Walking', hotkey: 'w', color: '#4ade80', trackId: 'track1' },
                { id: 'running', name: 'Running', hotkey: 'r', color: '#60a5fa', trackId: 'track1' },
                { id: 'eating', name: 'Eating', hotkey: 'e', color: '#f472b6', trackId: 'track2' },
                { id: 'no_event', name: 'Eraser', hotkey: 'x', color: '#444', trackId: null, isEraser: true },
            ],
            tracks: [{ id: 'track1', name: 'Activity' }, { id: 'track2', name: 'Feeding' }],
            segments: [],
        };

        // Zoom/Pan state
        let scale = 1, offsetX = 0, offsetY = 0, isDragging = false, dragStartX = 0, dragStartY = 0, currentBitmap = null;
        let lastContainerWidth = 0, lastContainerHeight = 0;

        class VideoDecoder {
            constructor(opts = {}) { this.cacheSize = opts.cacheSize || 60; this.lookahead = opts.lookahead || 30; this.cache = new Map(); this.samples = []; this.keyframeIndices = []; this.decoder = null; this.config = null; this.videoTrack = null; this.mp4boxFile = null; this.file = null; this.fileSize = 0; this.isDecoding = false; }
            async init(file) {
                this.file = file; this.fileSize = file.size; this.mp4boxFile = MP4Box.createFile();
                const ready = new Promise((res, rej) => { this.mp4boxFile.onError = rej; this.mp4boxFile.onReady = res; });
                let offset = 0, resolved = false; ready.then(() => resolved = true);
                while (offset < this.fileSize && !resolved) { const buf = await this.readChunk(offset, 1024 * 1024); buf.fileStart = offset; const next = this.mp4boxFile.appendBuffer(buf); offset = next === undefined ? offset + buf.byteLength : next; await new Promise(r => setTimeout(r, 0)); }
                const info = await ready; if (!info.videoTracks.length) throw new Error('No video tracks');
                this.videoTrack = info.videoTracks[0]; const trak = this.mp4boxFile.getTrackById(this.videoTrack.id); const desc = this.getCodecDesc(trak);
                const codec = this.videoTrack.codec.startsWith('vp08') ? 'vp8' : this.videoTrack.codec;
                this.config = { codec, codedWidth: this.videoTrack.video.width, codedHeight: this.videoTrack.video.height }; if (desc) this.config.description = desc;
                const support = await window.VideoDecoder.isConfigSupported(this.config); if (!support.supported) throw new Error(`Codec ${codec} not supported`);
                this.extractSamples(); const dur = this.videoTrack.duration / this.videoTrack.timescale; this.fps = this.samples.length / dur;
                return { codec, width: this.videoTrack.video.width, height: this.videoTrack.video.height, totalFrames: this.samples.length, fps: this.fps };
            }
            async readChunk(off, size) { return await this.file.slice(off, Math.min(off + size, this.fileSize)).arrayBuffer(); }
            getCodecDesc(trak) { for (const e of trak.mdia.minf.stbl.stsd.entries) { const box = e.avcC || e.hvcC || e.vpcC || e.av1C; if (box) { const s = new DataStream(undefined, 0, DataStream.BIG_ENDIAN); box.write(s); return new Uint8Array(s.buffer, 8); } } return null; }
            extractSamples() { const info = this.mp4boxFile.getTrackSamplesInfo(this.videoTrack.id); if (!info?.length) throw new Error('No samples'); const ts = this.videoTrack.timescale; this.samples = info.map((s, i) => ({ offset: s.offset, size: s.size, timestamp: s.cts * 1e6 / ts, duration: s.duration * 1e6 / ts, isKeyframe: s.is_sync, cts: s.cts, decodeIndex: i })).sort((a, b) => a.cts - b.cts); this.samples.forEach((s, i) => { if (s.isKeyframe) this.keyframeIndices.push(i); }); }
            findKeyframeBefore(idx) { let r = 0; for (const k of this.keyframeIndices) { if (k <= idx) r = k; else break; } return r; }
            async getFrame(idx) { if (idx < 0 || idx >= this.samples.length) return null; if (this.cache.has(idx)) { const bmp = this.cache.get(idx); this.cache.delete(idx); this.cache.set(idx, bmp); return { bitmap: bmp, fromCache: true }; } if (this.isDecoding) { await new Promise(r => { const c = () => this.isDecoding ? setTimeout(c, 10) : r(); c(); }); if (this.cache.has(idx)) return { bitmap: this.cache.get(idx), fromCache: true }; } const kf = this.findKeyframeBefore(idx); const end = Math.min(idx + this.lookahead, this.samples.length - 1); await this.decodeRange(kf, end, idx); const bmp = this.cache.get(idx); return bmp ? { bitmap: bmp, fromCache: false } : null; }
            async decodeRange(start, end, target) { this.isDecoding = true; try { if (this.decoder) try { this.decoder.close(); } catch (e) {} let minDI = Infinity, maxDI = -Infinity; for (let i = start; i <= end; i++) { minDI = Math.min(minDI, this.samples[i].decodeIndex); maxDI = Math.max(maxDI, this.samples[i].decodeIndex); } const toFeed = []; for (let i = 0; i < this.samples.length; i++) { const s = this.samples[i]; if (s.decodeIndex >= minDI && s.decodeIndex <= maxDI) toFeed.push({ pi: i, s }); } toFeed.sort((a, b) => a.s.decodeIndex - b.s.decodeIndex); const dataMap = new Map(); for (const { s } of toFeed) dataMap.set(s.decodeIndex, new Uint8Array(await this.readChunk(s.offset, s.size))); const tsMap = new Map(); for (const { pi, s } of toFeed) tsMap.set(Math.round(s.timestamp), pi); const halfC = Math.floor(this.cacheSize / 2), cStart = Math.max(start, target - halfC), cEnd = Math.min(end, target + halfC); await new Promise((res, rej) => { let cnt = 0; this.decoder = new window.VideoDecoder({ output: f => { let fi = tsMap.get(Math.round(f.timestamp)); if (fi === undefined) { let best = Infinity; for (const [t, i] of tsMap) { const d = Math.abs(t - f.timestamp); if (d < best) { best = d; fi = i; } } } if (fi !== undefined && fi >= cStart && fi <= cEnd) { createImageBitmap(f).then(b => { this.addToCache(fi, b); f.close(); if (++cnt >= toFeed.length) res(); }).catch(() => { f.close(); if (++cnt >= toFeed.length) res(); }); } else { f.close(); if (++cnt >= toFeed.length) res(); } }, error: e => e.name === 'AbortError' ? res() : rej(e) }); this.decoder.configure(this.config); for (const { s } of toFeed) { this.decoder.decode(new EncodedVideoChunk({ type: s.isKeyframe ? 'key' : 'delta', timestamp: s.timestamp, duration: s.duration, data: dataMap.get(s.decodeIndex) })); } this.decoder.flush(); }); } finally { this.isDecoding = false; } }
            addToCache(idx, bmp) { if (this.cache.size >= this.cacheSize) { const first = this.cache.keys().next().value; this.cache.get(first).close(); this.cache.delete(first); } this.cache.set(idx, bmp); }
            close() { if (this.decoder) this.decoder.close(); for (const b of this.cache.values()) b.close(); this.cache.clear(); }
        }

        const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d'), canvasContainer = document.getElementById('canvasContainer');
        const seekbar = document.getElementById('seekbar'), seekbarProgress = document.getElementById('seekbarProgress'), seekbarThumb = document.getElementById('seekbarThumb');
        const playBtn = document.getElementById('playBtn'), errorMsg = document.getElementById('errorMsg'), resizeHandle = document.getElementById('resizeHandle');
        const getEventType = id => state.eventTypes.find(e => e.id === id);
        const getEventTypeByHotkey = k => state.eventTypes.find(e => e.hotkey.toLowerCase() === k.toLowerCase());
        const showError = m => { errorMsg.textContent = m; errorMsg.style.display = 'block'; };
        const hideError = () => { errorMsg.style.display = 'none'; };

        function getVideoGeometry() { if (!currentBitmap) return { baseScale: 1, drawX: 0, drawY: 0 }; const cw = canvasContainer.clientWidth, ch = canvasContainer.clientHeight, va = currentBitmap.width / currentBitmap.height, ca = cw / ch; let baseScale, drawX, drawY; if (va > ca) { baseScale = cw / currentBitmap.width; drawX = 0; drawY = (ch - currentBitmap.height * baseScale) / 2; } else { baseScale = ch / currentBitmap.height; drawX = (cw - currentBitmap.width * baseScale) / 2; drawY = 0; } return { baseScale, drawX, drawY }; }
        function constrainOffset() { if (!currentBitmap) return; const cw = canvasContainer.clientWidth, ch = canvasContainer.clientHeight, { baseScale, drawX, drawY } = getVideoGeometry(); const sw = currentBitmap.width * baseScale * scale, sh = currentBitmap.height * baseScale * scale, minV = 0.25, minVX = sw * minV, minVY = sh * minV; offsetX = Math.max(minVX - sw - drawX, Math.min(cw - minVX - drawX, offsetX)); offsetY = Math.max(minVY - sh - drawY, Math.min(ch - minVY - drawY, offsetY)); }
        function zoomToPoint(px, py, newScale) { const { baseScale, drawX, drawY } = getVideoGeometry(), es = baseScale * scale; const vx = (px - offsetX - drawX) / es, vy = (py - offsetY - drawY) / es; const nes = baseScale * newScale; offsetX = px - drawX - vx * nes; offsetY = py - drawY - vy * nes; scale = newScale; constrainOffset(); }

        async function loadVideo(file) {
            hideError(); try {
                state.fileName = file.name; if (state.videoDecoder) state.videoDecoder.close();
                state.videoDecoder = new VideoDecoder({ cacheSize: 60, lookahead: 30 });
                state.videoInfo = await state.videoDecoder.init(file); state.totalFrames = state.videoInfo.totalFrames; state.fps = state.videoInfo.fps;
                state.currentFrame = 0; state.segments = []; state.mode = 'idle'; state.activeAnnotation = null; state.selectedSegmentId = null;
                scale = 1; offsetX = 0; offsetY = 0;
                canvasContainer.style.display = 'block'; resizeHandle.style.display = 'flex';
                document.getElementById('seekbarContainer').style.display = 'block'; document.getElementById('annotationStatus').style.display = 'flex';
                document.getElementById('timelineContainer').style.display = 'block'; document.getElementById('eventTypesContainer').style.display = 'block';
                document.getElementById('infoRow').style.display = 'flex'; document.getElementById('exportBtn').disabled = false;
                document.getElementById('importBtn').disabled = false; document.getElementById('clearBtn').disabled = false;
                lastContainerWidth = canvasContainer.clientWidth; lastContainerHeight = canvasContainer.clientHeight;
                renderEventTypeButtons(); renderTimelineTracks(); updateMetrics(); updateStatusDisplay(); await seekToFrame(0);
            } catch (err) { console.error(err); showError('Error: ' + err.message); }
        }

        document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('fileInput').addEventListener('change', e => { if (e.target.files[0]) loadVideo(e.target.files[0]); });
        document.getElementById('demoBtn').addEventListener('click', async () => { try { showError('Loading...'); const r = await fetch('/video-player/mice.mp4'); if (!r.ok) throw new Error('Not found'); const b = await r.blob(); hideError(); await loadVideo(new File([b], 'mice.mp4', { type: 'video/mp4' })); } catch (e) { showError('Demo error: ' + e.message); } });

        async function seekToFrame(idx) { if (!state.videoDecoder) return; idx = ((idx % state.totalFrames) + state.totalFrames) % state.totalFrames; const r = await state.videoDecoder.getFrame(idx); if (r?.bitmap) { state.currentFrame = idx; currentBitmap = r.bitmap; renderFrame(); updateSeekbar(); updateStatusDisplay(); renderTimelineTracks(); } }

        function renderFrame() {
            if (!currentBitmap) return; const dpr = window.devicePixelRatio || 1, cw = canvasContainer.clientWidth, ch = canvasContainer.clientHeight;
            if (canvas.width !== cw * dpr || canvas.height !== ch * dpr) { canvas.width = cw * dpr; canvas.height = ch * dpr; }
            const { baseScale, drawX, drawY } = getVideoGeometry(), es = baseScale * scale;
            ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.save(); ctx.scale(dpr, dpr);
            ctx.imageSmoothingEnabled = es < 2; ctx.translate(offsetX, offsetY); ctx.translate(drawX, drawY); ctx.scale(es, es);
            ctx.drawImage(currentBitmap, 0, 0); ctx.restore();
            // Overlays
            ctx.save(); ctx.scale(dpr, dpr);
            const txt = `Frame ${state.currentFrame + 1} / ${state.totalFrames}`; ctx.font = 'bold 12px monospace'; ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(8, 8, ctx.measureText(txt).width + 10, 18); ctx.fillStyle = '#fff'; ctx.fillText(txt, 13, 21);
            if (Math.abs(scale - 1) > 0.01) { const zt = `${scale.toFixed(1)}x`; ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(8, 30, ctx.measureText(zt).width + 10, 18); ctx.fillStyle = '#fff'; ctx.fillText(zt, 13, 43); }
            if (state.mode === 'painting' && state.activeAnnotation) { const et = getEventType(state.activeAnnotation.eventTypeId); const lbl = `${et.name}: ${state.activeAnnotation.startFrame + 1}-${state.currentFrame + 1}`; const y = Math.abs(scale - 1) > 0.01 ? 52 : 30; ctx.fillStyle = et.color; ctx.fillRect(8, y, ctx.measureText(lbl).width + 10, 18); ctx.fillStyle = '#000'; ctx.fillText(lbl, 13, y + 13); }
            ctx.restore();
        }

        function updateSeekbar() { const p = state.totalFrames > 1 ? (state.currentFrame / (state.totalFrames - 1)) * 100 : 0; seekbarProgress.style.width = p + '%'; seekbarThumb.style.left = p + '%'; }

        // Seekbar
        let isScrubbing = false;
        const handleSeekbar = e => { const r = seekbar.getBoundingClientRect(), x = Math.max(0, Math.min(e.clientX - r.left, r.width)); seekToFrame(Math.round((x / r.width) * (state.totalFrames - 1))); };
        seekbar.addEventListener('mousedown', e => { isScrubbing = true; document.body.style.userSelect = 'none'; handleSeekbar(e); });
        document.addEventListener('mousemove', e => { if (isScrubbing) handleSeekbar(e); });
        document.addEventListener('mouseup', () => { if (isScrubbing) { document.body.style.userSelect = ''; isScrubbing = false; } });

        // Playback
        function togglePlayback() { if (state.isPlaying) { state.isPlaying = false; playBtn.textContent = '\u25B6'; if (state.playInterval) clearInterval(state.playInterval); } else { state.isPlaying = true; playBtn.textContent = '\u23F8'; state.playInterval = setInterval(() => seekToFrame(state.currentFrame + 1), 1000 / state.fps); } }
        playBtn.addEventListener('click', togglePlayback);
        document.getElementById('firstFrameBtn').addEventListener('click', () => seekToFrame(0));
        document.getElementById('prevFrameBtn').addEventListener('click', () => seekToFrame(state.currentFrame - 1));
        document.getElementById('nextFrameBtn').addEventListener('click', () => seekToFrame(state.currentFrame + 1));
        document.getElementById('lastFrameBtn').addEventListener('click', () => seekToFrame(state.totalFrames - 1));
        document.getElementById('zoomInBtn').addEventListener('click', () => { zoomToPoint(canvasContainer.clientWidth / 2, canvasContainer.clientHeight / 2, Math.min(50, scale * 1.25)); renderFrame(); });
        document.getElementById('zoomOutBtn').addEventListener('click', () => { zoomToPoint(canvasContainer.clientWidth / 2, canvasContainer.clientHeight / 2, Math.max(0.1, scale * 0.8)); renderFrame(); });
        document.getElementById('resetZoomBtn').addEventListener('click', () => { scale = 1; offsetX = 0; offsetY = 0; renderFrame(); });

        // Mouse wheel zoom
        canvasContainer.addEventListener('wheel', e => { e.preventDefault(); const rect = canvasContainer.getBoundingClientRect(), mx = e.clientX - rect.left, my = e.clientY - rect.top; let d = Math.max(-100, Math.min(100, e.deltaY)); const zf = Math.exp(-d * 0.001), ns = Math.max(0.1, Math.min(50, scale * zf)); zoomToPoint(mx, my, ns); renderFrame(); });
        // Mouse drag pan
        canvasContainer.addEventListener('mousedown', e => { isDragging = true; dragStartX = e.clientX - offsetX; dragStartY = e.clientY - offsetY; });
        document.addEventListener('mousemove', e => { if (isDragging) { offsetX = e.clientX - dragStartX; offsetY = e.clientY - dragStartY; constrainOffset(); renderFrame(); } });
        document.addEventListener('mouseup', () => { isDragging = false; });
        // Touch gestures
        let pinchDist = null, pinchScale = null, pinchCX = null, pinchCY = null, touchX = null, touchY = null, touchOX = null, touchOY = null;
        const touchDist = t => Math.sqrt((t[0].clientX - t[1].clientX) ** 2 + (t[0].clientY - t[1].clientY) ** 2);
        const touchCenter = (t, r) => ({ x: (t[0].clientX + t[1].clientX) / 2 - r.left, y: (t[0].clientY + t[1].clientY) / 2 - r.top });
        canvasContainer.addEventListener('touchstart', e => { if (e.touches.length === 2) { e.preventDefault(); pinchDist = touchDist(e.touches); pinchScale = scale; const r = canvasContainer.getBoundingClientRect(), c = touchCenter(e.touches, r); pinchCX = c.x; pinchCY = c.y; touchX = touchY = touchOX = touchOY = null; } else if (e.touches.length === 1) { touchX = e.touches[0].clientX; touchY = e.touches[0].clientY; touchOX = offsetX; touchOY = offsetY; } }, { passive: false });
        canvasContainer.addEventListener('touchmove', e => { if (e.touches.length === 2 && pinchDist !== null) { e.preventDefault(); const r = canvasContainer.getBoundingClientRect(), cc = touchCenter(e.touches, r), cd = touchDist(e.touches), pr = cd / pinchDist, ns = Math.max(0.1, Math.min(50, pinchScale * pr)); const { baseScale, drawX, drawY } = getVideoGeometry(), es = baseScale * scale, vx = (pinchCX - offsetX - drawX) / es, vy = (pinchCY - offsetY - drawY) / es, nes = baseScale * ns; offsetX = pinchCX - drawX - vx * nes + cc.x - pinchCX; offsetY = pinchCY - drawY - vy * nes + cc.y - pinchCY; pinchCX = cc.x; pinchCY = cc.y; scale = ns; constrainOffset(); renderFrame(); } else if (e.touches.length === 1 && touchX !== null) { e.preventDefault(); offsetX = touchOX + e.touches[0].clientX - touchX; offsetY = touchOY + e.touches[0].clientY - touchY; constrainOffset(); renderFrame(); } }, { passive: false });
        canvasContainer.addEventListener('touchend', e => { if (e.touches.length < 2) { pinchDist = pinchScale = pinchCX = pinchCY = null; } if (e.touches.length === 0) { touchX = touchY = touchOX = touchOY = null; } });
        // Resize handle
        let isResizing = false, resizeStartY = 0, resizeStartH = 0;
        resizeHandle.addEventListener('mousedown', e => { e.preventDefault(); isResizing = true; resizeStartY = e.clientY; resizeStartH = canvasContainer.clientHeight; document.body.style.userSelect = 'none'; document.body.style.cursor = 'ns-resize'; });
        document.addEventListener('mousemove', e => { if (isResizing) { const oh = canvasContainer.clientHeight, ow = canvasContainer.clientWidth, nh = Math.max(150, Math.min(window.innerHeight * 0.9, resizeStartH + e.clientY - resizeStartY)); canvasContainer.style.height = nh + 'px'; handleContainerResize(ow, oh, canvasContainer.clientWidth, canvasContainer.clientHeight); renderFrame(); } });
        document.addEventListener('mouseup', () => { if (isResizing) { isResizing = false; document.body.style.userSelect = ''; document.body.style.cursor = ''; lastContainerWidth = canvasContainer.clientWidth; lastContainerHeight = canvasContainer.clientHeight; } });
        function handleContainerResize(ow, oh, nw, nh) { if (!currentBitmap || ow === 0 || oh === 0) return; const va = currentBitmap.width / currentBitmap.height; let obs, odx, ody; if (va > ow / oh) { obs = ow / currentBitmap.width; odx = 0; ody = (oh - currentBitmap.height * obs) / 2; } else { obs = oh / currentBitmap.height; odx = (ow - currentBitmap.width * obs) / 2; ody = 0; } let nbs, ndx, ndy; if (va > nw / nh) { nbs = nw / currentBitmap.width; ndx = 0; ndy = (nh - currentBitmap.height * nbs) / 2; } else { nbs = nh / currentBitmap.height; ndx = (nw - currentBitmap.width * nbs) / 2; ndy = 0; } const oes = obs * scale, vx = (ow / 2 - offsetX - odx) / oes, vy = (oh / 2 - offsetY - ody) / oes, nes = nbs * scale; offsetX = nw / 2 - ndx - vx * nes; offsetY = nh / 2 - ndy - vy * nes; constrainOffset(); }
        const resizeObs = new ResizeObserver(entries => { for (const e of entries) { if (isResizing) continue; const nw = e.contentRect.width, nh = e.contentRect.height; if (lastContainerWidth === 0 || (nw === lastContainerWidth && nh === lastContainerHeight)) { lastContainerWidth = nw; lastContainerHeight = nh; continue; } handleContainerResize(lastContainerWidth, lastContainerHeight, nw, nh); lastContainerWidth = nw; lastContainerHeight = nh; renderFrame(); } }); resizeObs.observe(canvasContainer);

        // Annotation
        function startPainting(etId) { state.mode = 'painting'; state.activeAnnotation = { eventTypeId: etId, startFrame: state.currentFrame }; state.selectedSegmentId = null; updateStatusDisplay(); renderTimelineTracks(); renderFrame(); }
        function commitAnnotation() { if (!state.activeAnnotation) return; const { eventTypeId, startFrame } = state.activeAnnotation, endFrame = state.currentFrame, et = getEventType(eventTypeId), ss = Math.min(startFrame, endFrame), se = Math.max(startFrame, endFrame); if (et.isEraser) eraseRange(ss, se); else addSegment(et.trackId, eventTypeId, ss, se); state.mode = 'idle'; state.activeAnnotation = null; updateStatusDisplay(); renderTimelineTracks(); renderFrame(); updateMetrics(); }
        function cancelPainting() { state.mode = 'idle'; state.activeAnnotation = null; updateStatusDisplay(); renderTimelineTracks(); renderFrame(); }
        function addSegment(tid, etId, s, e) { const ovs = state.segments.filter(sg => sg.trackId === tid && !(sg.endFrame < s || sg.startFrame > e)); for (const o of ovs) { state.segments.splice(state.segments.indexOf(o), 1); if (o.eventTypeId === etId) { s = Math.min(s, o.startFrame); e = Math.max(e, o.endFrame); } else { if (o.startFrame < s) state.segments.push({ id: crypto.randomUUID(), trackId: tid, eventTypeId: o.eventTypeId, startFrame: o.startFrame, endFrame: s - 1 }); if (o.endFrame > e) state.segments.push({ id: crypto.randomUUID(), trackId: tid, eventTypeId: o.eventTypeId, startFrame: e + 1, endFrame: o.endFrame }); } } state.segments.push({ id: crypto.randomUUID(), trackId: tid, eventTypeId: etId, startFrame: s, endFrame: e }); }
        function eraseRange(s, e) { const rm = [], add = []; for (const sg of state.segments) { if (sg.endFrame < s || sg.startFrame > e) continue; rm.push(sg); if (sg.startFrame < s) add.push({ ...sg, id: crypto.randomUUID(), endFrame: s - 1 }); if (sg.endFrame > e) add.push({ ...sg, id: crypto.randomUUID(), startFrame: e + 1 }); } for (const sg of rm) state.segments.splice(state.segments.indexOf(sg), 1); state.segments.push(...add); }
        function deleteSelectedSegment() { if (!state.selectedSegmentId) return; const i = state.segments.findIndex(s => s.id === state.selectedSegmentId); if (i !== -1) state.segments.splice(i, 1); state.selectedSegmentId = null; renderTimelineTracks(); updateMetrics(); document.getElementById('selectedSegmentInfo').textContent = ''; }
        function handleEventTypeClick(etId) { if (state.mode === 'painting') { if (state.activeAnnotation.eventTypeId === etId) commitAnnotation(); else { commitAnnotation(); startPainting(etId); } } else startPainting(etId); }

        function renderEventTypeButtons() { const c = document.getElementById('eventTypeButtons'); c.innerHTML = ''; for (const et of state.eventTypes) { const b = document.createElement('button'); b.className = 'event-type-btn'; b.style.background = et.color; b.style.color = et.isEraser ? '#aaa' : '#000'; b.innerHTML = `${et.name} <span class="hotkey">${et.hotkey.toUpperCase()}</span>`; b.addEventListener('click', () => handleEventTypeClick(et.id)); c.appendChild(b); } }
        function renderTimelineTracks() { const c = document.getElementById('timelineTracks'); c.innerHTML = ''; for (const track of state.tracks) { const t = document.createElement('div'); t.className = 'timeline-track'; t.innerHTML = `<span class="timeline-track-label">${track.name}</span>`; for (const seg of state.segments.filter(s => s.trackId === track.id)) { const et = getEventType(seg.eventTypeId), l = (seg.startFrame / state.totalFrames) * 100, w = ((seg.endFrame - seg.startFrame + 1) / state.totalFrames) * 100; const s = document.createElement('div'); s.className = 'timeline-segment' + (seg.id === state.selectedSegmentId ? ' selected' : ''); s.style.cssText = `left:${l}%;width:${w}%;background:${et.color};`; s.title = `${et.name}: ${seg.startFrame + 1}-${seg.endFrame + 1}`; s.addEventListener('click', ev => { ev.stopPropagation(); state.selectedSegmentId = seg.id; document.getElementById('selectedSegmentInfo').textContent = `${et.name} (${seg.startFrame + 1}-${seg.endFrame + 1}) - Delete to remove`; renderTimelineTracks(); }); t.appendChild(s); } if (state.mode === 'painting' && state.activeAnnotation) { const et = getEventType(state.activeAnnotation.eventTypeId); if (et.trackId === track.id || et.isEraser) { const ss = Math.min(state.activeAnnotation.startFrame, state.currentFrame), se = Math.max(state.activeAnnotation.startFrame, state.currentFrame), l = (ss / state.totalFrames) * 100, w = ((se - ss + 1) / state.totalFrames) * 100; const p = document.createElement('div'); p.className = 'timeline-segment active'; p.style.cssText = `left:${l}%;width:${w}%;background:${et.color};`; t.appendChild(p); } } const ph = document.createElement('div'); ph.className = 'timeline-playhead'; ph.style.left = (state.currentFrame / state.totalFrames) * 100 + '%'; t.appendChild(ph); t.addEventListener('click', () => { state.selectedSegmentId = null; document.getElementById('selectedSegmentInfo').textContent = ''; renderTimelineTracks(); }); c.appendChild(t); } }
        function updateStatusDisplay() { const m = document.getElementById('modeDisplay'), f = document.getElementById('frameDisplay'), pi = document.getElementById('paintingInfo'), pd = document.getElementById('paintingDisplay'); f.textContent = `${state.currentFrame + 1} / ${state.totalFrames}`; if (state.mode === 'painting' && state.activeAnnotation) { const et = getEventType(state.activeAnnotation.eventTypeId); m.textContent = 'PAINTING'; m.className = 'status-value status-painting'; pi.style.display = 'inline'; pd.textContent = `${et.name} (${state.activeAnnotation.startFrame + 1}-${state.currentFrame + 1})`; pd.style.color = et.color; } else { m.textContent = 'IDLE'; m.className = 'status-value status-idle'; pi.style.display = 'none'; } }
        function updateMetrics() { document.getElementById('metricFile').textContent = state.fileName; document.getElementById('metricRes').textContent = state.videoInfo ? `${state.videoInfo.width}x${state.videoInfo.height}` : '-'; document.getElementById('metricFps').textContent = state.fps.toFixed(2); document.getElementById('metricSegments').textContent = state.segments.length; document.getElementById('metricTracks').textContent = state.tracks.length; }

        // Keyboard
        document.addEventListener('keydown', e => { if (!state.videoDecoder) return; if (e.key === 'ArrowLeft') { e.preventDefault(); seekToFrame(state.currentFrame - (e.ctrlKey ? 30 : 1)); } else if (e.key === 'ArrowRight') { e.preventDefault(); seekToFrame(state.currentFrame + (e.ctrlKey ? 30 : 1)); } else if (e.key === 'ArrowUp') { e.preventDefault(); zoomToPoint(canvasContainer.clientWidth / 2, canvasContainer.clientHeight / 2, Math.min(50, scale * (e.ctrlKey ? 1.5 : 1.1))); renderFrame(); } else if (e.key === 'ArrowDown') { e.preventDefault(); zoomToPoint(canvasContainer.clientWidth / 2, canvasContainer.clientHeight / 2, Math.max(0.1, scale * (e.ctrlKey ? 0.67 : 0.9))); renderFrame(); } else if (e.key === 'Home') { e.preventDefault(); seekToFrame(0); } else if (e.key === 'End') { e.preventDefault(); seekToFrame(state.totalFrames - 1); } else if (e.key === ' ') { e.preventDefault(); togglePlayback(); } else if (e.key === 'Escape') { e.preventDefault(); cancelPainting(); } else if (e.key === 'Delete' || e.key === 'Backspace') { e.preventDefault(); deleteSelectedSegment(); } const et = getEventTypeByHotkey(e.key); if (et && !e.ctrlKey && !e.metaKey && !e.altKey) { e.preventDefault(); handleEventTypeClick(et.id); } });

        // Export/Import
        document.getElementById('exportBtn').addEventListener('click', () => { const d = { videoFile: state.fileName, totalFrames: state.totalFrames, fps: state.fps, eventTypes: state.eventTypes, tracks: state.tracks, segments: state.segments, exportedAt: new Date().toISOString() }; const b = new Blob([JSON.stringify(d, null, 2)], { type: 'application/json' }); const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = state.fileName.replace(/\.[^.]+$/, '') + '_annotations.json'; a.click(); URL.revokeObjectURL(a.href); });
        document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importInput').click());
        document.getElementById('importInput').addEventListener('change', async e => { const f = e.target.files[0]; if (!f) return; try { const t = await f.text(), d = JSON.parse(t); if (d.segments && Array.isArray(d.segments)) { state.segments = d.segments; if (d.eventTypes) state.eventTypes = d.eventTypes; if (d.tracks) state.tracks = d.tracks; renderEventTypeButtons(); renderTimelineTracks(); updateMetrics(); hideError(); } else throw new Error('Invalid file'); } catch (er) { showError('Import error: ' + er.message); } e.target.value = ''; });
        document.getElementById('clearBtn').addEventListener('click', () => { if (confirm('Clear all?')) { state.segments = []; state.selectedSegmentId = null; document.getElementById('selectedSegmentInfo').textContent = ''; renderTimelineTracks(); updateMetrics(); } });
        window.addEventListener('resize', () => { if (currentBitmap) renderFrame(); renderTimelineTracks(); });
    </script>
</body>
</html>
