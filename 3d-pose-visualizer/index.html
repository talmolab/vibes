<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXUS // 3D Pose Visualizer</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --cyan: #00ffff;
            --magenta: #ff00ff;
            --green: #00ff88;
            --orange: #ffaa00;
            --red: #ff3366;
            --dark: #000511;
        }

        body {
            background: var(--dark);
            overflow: hidden;
            font-family: 'Orbitron', 'Courier New', monospace;
            color: var(--cyan);
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #webcam {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            border: 2px solid var(--cyan);
            box-shadow: 0 0 20px rgba(0,255,255,0.4), inset 0 0 20px rgba(0,255,255,0.2);
            object-fit: cover;
            opacity: 0.9;
            z-index: 100;
            clip-path: polygon(0 0, 100% 0, 100% 85%, 95% 100%, 0 100%);
        }

        /* Scanline overlay */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 255, 0.02) 2px,
                rgba(0, 255, 255, 0.02) 4px
            );
            pointer-events: none;
            z-index: 200;
            animation: scanlineMove 8s linear infinite;
        }

        @keyframes scanlineMove {
            0% { background-position: 0 0; }
            100% { background-position: 0 100px; }
        }

        /* Scanner sweep */
        .scanner-sweep {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                180deg,
                transparent 0%,
                rgba(0, 255, 255, 0.1) 50%,
                transparent 100%
            );
            pointer-events: none;
            z-index: 180;
            animation: scannerSweep 4s ease-in-out infinite;
            opacity: 0.5;
        }

        @keyframes scannerSweep {
            0%, 100% { transform: translateY(-100%); }
            50% { transform: translateY(100%); }
        }

        /* Vignette */
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(0,0,0,0.9) 100%);
            pointer-events: none;
            z-index: 150;
        }

        /* Glitch effect overlay */
        .glitch-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 210;
            opacity: 0;
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(255,0,255,0.1) 50%,
                transparent 100%
            );
        }

        .glitch-overlay.active {
            animation: glitch 0.3s steps(10) infinite;
        }

        @keyframes glitch {
            0%, 100% { opacity: 0; transform: translateX(0); }
            10% { opacity: 1; transform: translateX(-5px); }
            20% { opacity: 0; transform: translateX(5px); }
            30% { opacity: 1; transform: translateX(-3px); }
            40% { opacity: 0; }
        }

        /* HUD Elements */
        .hud {
            position: absolute;
            z-index: 300;
            pointer-events: none;
        }

        .hud-corner {
            position: absolute;
            width: 80px;
            height: 80px;
        }

        .hud-corner::before,
        .hud-corner::after {
            content: '';
            position: absolute;
            background: var(--cyan);
            box-shadow: 0 0 10px var(--cyan), 0 0 20px var(--cyan);
        }

        .hud-tl { top: 15px; left: 15px; }
        .hud-tl::before { width: 30px; height: 2px; top: 0; left: 0; }
        .hud-tl::after { width: 2px; height: 30px; top: 0; left: 0; }
        .hud-tl .corner-detail { position: absolute; top: 8px; left: 8px; width: 8px; height: 8px; border: 1px solid var(--cyan); }

        .hud-tr { top: 15px; right: 280px; }
        .hud-tr::before { width: 30px; height: 2px; top: 0; right: 0; }
        .hud-tr::after { width: 2px; height: 30px; top: 0; right: 0; }

        .hud-bl { bottom: 15px; left: 15px; }
        .hud-bl::before { width: 30px; height: 2px; bottom: 0; left: 0; }
        .hud-bl::after { width: 2px; height: 30px; bottom: 0; left: 0; }

        .hud-br { bottom: 15px; right: 15px; }
        .hud-br::before { width: 30px; height: 2px; bottom: 0; right: 0; }
        .hud-br::after { width: 2px; height: 30px; bottom: 0; right: 0; }

        /* Animated corner accents */
        .hud-corner .accent {
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--magenta);
            box-shadow: 0 0 10px var(--magenta);
            animation: accentPulse 2s ease-in-out infinite;
        }

        .hud-tl .accent { top: 35px; left: 0; }
        .hud-tr .accent { top: 35px; right: 0; animation-delay: 0.5s; }
        .hud-bl .accent { bottom: 35px; left: 0; animation-delay: 1s; }
        .hud-br .accent { bottom: 35px; right: 0; animation-delay: 1.5s; }

        @keyframes accentPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        /* Data panels */
        .data-panel {
            position: absolute;
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.9) 0%, rgba(0, 10, 20, 0.95) 100%);
            border: 1px solid var(--cyan);
            border-left: 3px solid var(--cyan);
            padding: 15px;
            font-size: 11px;
            line-height: 1.8;
            box-shadow: 0 0 30px rgba(0,255,255,0.2), inset 0 0 50px rgba(0,255,255,0.05);
            backdrop-filter: blur(10px);
            z-index: 300;
            clip-path: polygon(0 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%);
        }

        .data-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--cyan), var(--magenta), var(--cyan));
            animation: panelGlow 3s linear infinite;
        }

        @keyframes panelGlow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .data-panel h3 {
            color: var(--cyan);
            font-size: 11px;
            font-weight: 700;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 4px;
            border-bottom: 1px solid rgba(0,255,255,0.3);
            padding-bottom: 8px;
            text-shadow: 0 0 10px var(--cyan);
        }

        .data-panel .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 0;
        }

        .data-panel .value {
            color: #fff;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-shadow: 0 0 5px var(--cyan);
        }

        .data-panel .label {
            color: rgba(0,170,170,0.9);
        }

        .data-panel .bar {
            height: 4px;
            background: rgba(0,255,255,0.2);
            margin-top: 3px;
            border-radius: 2px;
            overflow: hidden;
        }

        .data-panel .bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--cyan), var(--magenta));
            transition: width 0.3s ease;
            box-shadow: 0 0 10px var(--cyan);
        }

        #system-panel {
            top: 20px;
            left: 20px;
            width: 200px;
        }

        #metrics-panel {
            bottom: 20px;
            left: 20px;
            width: 300px;
        }

        #joints-panel {
            bottom: 20px;
            right: 20px;
            width: 180px;
            max-height: 280px;
            overflow: hidden;
        }

        #tracking-panel {
            top: 220px;
            left: 20px;
            width: 200px;
        }

        /* Status indicator */
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--red);
            box-shadow: 0 0 10px var(--red);
            animation: statusPulse 1.5s infinite;
        }

        .status-dot.active {
            background: var(--green);
            box-shadow: 0 0 15px var(--green);
        }

        @keyframes statusPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(0.9); }
        }

        /* Title */
        .title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 400;
            transition: opacity 0.8s, transform 0.8s;
        }

        .title.hidden {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.9);
            pointer-events: none;
        }

        .title h1 {
            font-size: 72px;
            font-weight: 900;
            letter-spacing: 30px;
            color: var(--cyan);
            text-shadow: 0 0 30px var(--cyan), 0 0 60px var(--cyan), 0 0 90px var(--magenta);
            margin-bottom: 15px;
            animation: titleFlicker 4s infinite;
        }

        .title .subtitle {
            font-size: 14px;
            letter-spacing: 8px;
            color: rgba(0,170,170,0.8);
            margin-bottom: 10px;
        }

        .title .version {
            font-size: 10px;
            letter-spacing: 3px;
            color: var(--magenta);
            margin-bottom: 40px;
        }

        @keyframes titleFlicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.7; text-shadow: 0 0 30px var(--magenta), 0 0 60px var(--red); }
            94% { opacity: 1; }
            95% { opacity: 0.8; }
            96% { opacity: 1; }
        }

        #start-btn {
            padding: 18px 60px;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 5px;
            background: transparent;
            border: 2px solid var(--cyan);
            color: var(--cyan);
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }

        #start-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        #start-btn:hover {
            background: var(--cyan);
            color: var(--dark);
            box-shadow: 0 0 40px var(--cyan), inset 0 0 20px rgba(255,255,255,0.3);
            transform: scale(1.05);
        }

        #start-btn:hover::before {
            left: 100%;
        }

        /* Loading animation */
        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 500;
            text-align: center;
        }

        .loading.active {
            display: block;
        }

        .loading-ring {
            width: 100px;
            height: 100px;
            margin: 0 auto;
            position: relative;
        }

        .loading-ring::before,
        .loading-ring::after {
            content: '';
            position: absolute;
            border: 3px solid transparent;
            border-radius: 50%;
        }

        .loading-ring::before {
            top: 0; left: 0; right: 0; bottom: 0;
            border-top-color: var(--cyan);
            border-right-color: var(--cyan);
            animation: spinRing 1.2s linear infinite;
        }

        .loading-ring::after {
            top: 10px; left: 10px; right: 10px; bottom: 10px;
            border-bottom-color: var(--magenta);
            border-left-color: var(--magenta);
            animation: spinRing 1.8s linear infinite reverse;
        }

        @keyframes spinRing {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 25px;
            font-size: 12px;
            letter-spacing: 4px;
            color: var(--cyan);
            animation: loadingPulse 1.5s ease-in-out infinite;
        }

        .loading-progress {
            width: 200px;
            height: 3px;
            background: rgba(0,255,255,0.2);
            margin: 15px auto 0;
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--cyan), var(--magenta));
            transition: width 0.3s;
        }

        @keyframes loadingPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Mode toggle */
        #mode-toggle {
            position: absolute;
            top: 220px;
            right: 20px;
            z-index: 300;
        }

        #mode-toggle button {
            display: block;
            width: 120px;
            margin-bottom: 5px;
            padding: 10px 15px;
            font-family: 'Orbitron', monospace;
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 1px;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid rgba(0,255,255,0.3);
            color: var(--cyan);
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            position: relative;
            overflow: hidden;
        }

        #mode-toggle button::before {
            content: '○';
            margin-right: 8px;
            color: rgba(0,255,255,0.5);
        }

        #mode-toggle button:hover {
            border-color: var(--cyan);
            background: rgba(0, 255, 255, 0.1);
        }

        #mode-toggle button.active {
            background: linear-gradient(90deg, rgba(0,255,255,0.3), transparent);
            border-color: var(--cyan);
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }

        #mode-toggle button.active::before {
            content: '●';
            color: var(--cyan);
            text-shadow: 0 0 10px var(--cyan);
        }

        /* Targeting reticle */
        .reticle {
            position: absolute;
            width: 80px;
            height: 80px;
            pointer-events: none;
            z-index: 250;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .reticle.active {
            opacity: 1;
        }

        .reticle-ring {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            border: 2px solid var(--magenta);
            border-radius: 50%;
            animation: reticleSpin 3s linear infinite;
            box-shadow: 0 0 20px rgba(255,0,255,0.5);
        }

        .reticle-ring::before {
            content: '';
            position: absolute;
            top: 50%;
            left: -15px;
            right: -15px;
            height: 1px;
            background: var(--magenta);
        }

        .reticle-ring::after {
            content: '';
            position: absolute;
            left: 50%;
            top: -15px;
            bottom: -15px;
            width: 1px;
            background: var(--magenta);
        }

        .reticle-inner {
            position: absolute;
            top: 15px; left: 15px; right: 15px; bottom: 15px;
            border: 1px solid var(--cyan);
            border-radius: 50%;
            animation: reticleSpin 2s linear infinite reverse;
        }

        .reticle-corners {
            position: absolute;
            top: 5px; left: 5px; right: 5px; bottom: 5px;
        }

        .reticle-corners::before,
        .reticle-corners::after {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            border-color: var(--cyan);
            border-style: solid;
        }

        .reticle-corners::before {
            top: 0; left: 0;
            border-width: 2px 0 0 2px;
        }

        .reticle-corners::after {
            bottom: 0; right: 0;
            border-width: 0 2px 2px 0;
        }

        @keyframes reticleSpin {
            to { transform: rotate(360deg); }
        }

        /* Hexagon grid background */
        .hex-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            opacity: 0.03;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='28' height='49' viewBox='0 0 28 49'%3E%3Cg fill-rule='evenodd'%3E%3Cg fill='%2300ffff' fill-opacity='1'%3E%3Cpath d='M13.99 9.25l13 7.5v15l-13 7.5L1 31.75v-15l12.99-7.5zM3 17.9v12.7l10.99 6.34 11-6.35V17.9l-11-6.34L3 17.9zM0 15l12.98-7.5V0h-2v6.35L0 12.69v2.3zm0 18.5L12.98 41v8h-2v-6.85L0 35.81v-2.3zM15 0v7.5L27.99 15H28v-2.31h-.01L17 6.35V0h-2zm0 49v-8l12.99-7.5H28v2.31h-.01L17 42.15V49h-2z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        }

        /* Timestamp display */
        #timestamp {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            letter-spacing: 3px;
            color: rgba(0,255,255,0.5);
            z-index: 300;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            #webcam {
                width: 120px;
                height: 90px;
                top: 10px;
                right: 10px;
            }

            .data-panel {
                font-size: 8px;
                padding: 10px;
            }

            #system-panel { width: 150px; }
            #metrics-panel { width: 180px; }
            #joints-panel, #tracking-panel { display: none; }

            .title h1 {
                font-size: 36px;
                letter-spacing: 15px;
            }

            .hud-tr { right: 140px; }
            #mode-toggle { top: 120px; }
            #mode-toggle button { width: 100px; font-size: 8px; padding: 8px 10px; }
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="three-canvas"></canvas>
        <video id="webcam" autoplay playsinline muted></video>

        <div class="hex-grid"></div>
        <div class="scanner-sweep"></div>
        <div class="scanlines"></div>
        <div class="vignette"></div>
        <div class="glitch-overlay" id="glitch-overlay"></div>

        <!-- HUD Corners -->
        <div class="hud hud-corner hud-tl"><div class="accent"></div><div class="corner-detail"></div></div>
        <div class="hud hud-corner hud-tr"><div class="accent"></div></div>
        <div class="hud hud-corner hud-bl"><div class="accent"></div></div>
        <div class="hud hud-corner hud-br"><div class="accent"></div></div>

        <!-- Data Panels -->
        <div class="data-panel" id="system-panel">
            <h3>System Core</h3>
            <div class="status">
                <div class="status-dot" id="camera-status"></div>
                <span class="label">CAMERA</span>
                <span class="value" id="camera-val">OFFLINE</span>
            </div>
            <div class="status">
                <div class="status-dot" id="ai-status"></div>
                <span class="label">NEURAL NET</span>
                <span class="value" id="ai-val">STANDBY</span>
            </div>
            <div class="status">
                <div class="status-dot" id="render-status"></div>
                <span class="label">RENDERER</span>
                <span class="value" id="render-val">READY</span>
            </div>
            <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(0,255,255,0.2);">
                <div class="row"><span class="label">FPS</span><span class="value" id="fps-val">0</span></div>
                <div class="row"><span class="label">LATENCY</span><span class="value" id="latency-val">0ms</span></div>
            </div>
        </div>

        <div class="data-panel" id="tracking-panel">
            <h3>Tracking Status</h3>
            <div class="row"><span class="label">CONFIDENCE</span><span class="value" id="confidence-val">--</span></div>
            <div class="bar"><div class="bar-fill" id="confidence-bar" style="width: 0%"></div></div>
            <div class="row" style="margin-top: 8px;"><span class="label">LANDMARKS</span><span class="value" id="points-val">0/33</span></div>
            <div class="bar"><div class="bar-fill" id="landmarks-bar" style="width: 0%"></div></div>
        </div>

        <div class="data-panel" id="metrics-panel">
            <h3>Biomechanics Analysis</h3>
            <div class="row"><span class="label">HEAD TILT</span><span class="value" id="head-angle">--</span></div>
            <div class="row"><span class="label">SHOULDER WIDTH</span><span class="value" id="shoulder-width">--</span></div>
            <div class="row"><span class="label">ARM SPAN</span><span class="value" id="arm-span">--</span></div>
            <div class="row"><span class="label">STANCE WIDTH</span><span class="value" id="stance-width">--</span></div>
            <div class="row"><span class="label">BODY VELOCITY</span><span class="value" id="velocity-val">0.00 m/s</span></div>
            <div class="row"><span class="label">POSE SYMMETRY</span><span class="value" id="symmetry-val">--</span></div>
            <div class="row"><span class="label">CENTER OF MASS</span><span class="value" id="com-val">--</span></div>
        </div>

        <div class="data-panel" id="joints-panel">
            <h3>Active Joints</h3>
            <div id="joints-list"></div>
        </div>

        <!-- Mode Toggle -->
        <div id="mode-toggle">
            <button class="active" data-mode="hologram">HOLOGRAM</button>
            <button data-mode="wireframe">WIREFRAME</button>
            <button data-mode="particles">PARTICLES</button>
            <button data-mode="energy">ENERGY</button>
            <button data-mode="xray">X-RAY</button>
            <button data-mode="matrix">MATRIX</button>
        </div>

        <!-- Timestamp -->
        <div id="timestamp"></div>

        <!-- Title Screen -->
        <div class="title" id="title-screen">
            <h1>NEXUS</h1>
            <p class="subtitle">3D POSE VISUALIZATION SYSTEM</p>
            <p class="version">VERSION 2.0.0 // NEURAL CORE ACTIVE</p>
            <button id="start-btn">INITIALIZE</button>
        </div>

        <!-- Loading -->
        <div class="loading" id="loading">
            <div class="loading-ring"></div>
            <div class="loading-text" id="loading-text">INITIALIZING NEURAL NETWORK</div>
            <div class="loading-progress"><div class="loading-progress-bar" id="loading-bar"></div></div>
        </div>

        <!-- Reticle -->
        <div class="reticle" id="reticle">
            <div class="reticle-ring"></div>
            <div class="reticle-inner"></div>
            <div class="reticle-corners"></div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/shaders/CopyShader.js"></script>

    <script type="module">
        import { PoseLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs';

        // ==================== CONFIGURATION ====================
        const CONFIG = {
            colors: {
                primary: 0x00ffff,
                secondary: 0xff00ff,
                tertiary: 0x00ff88,
                warning: 0xffaa00,
                grid: 0x004466,
                background: 0x000511,
                xray: 0x00ff00
            },
            skeleton: {
                jointSize: 0.035,
                boneWidth: 0.012,
                glowIntensity: 2.0
            },
            particles: {
                count: 3000,
                size: 0.015,
                speed: 0.3
            },
            trails: {
                length: 15,
                fadeSpeed: 0.92
            },
            bloom: {
                strength: 1.8,
                radius: 0.5,
                threshold: 0.15
            }
        };

        // MediaPipe pose connections with body part classification
        const POSE_CONNECTIONS = [
            { start: 11, end: 12, type: 'torso' },
            { start: 11, end: 13, type: 'arm' }, { start: 13, end: 15, type: 'arm' },
            { start: 12, end: 14, type: 'arm' }, { start: 14, end: 16, type: 'arm' },
            { start: 11, end: 23, type: 'torso' }, { start: 12, end: 24, type: 'torso' },
            { start: 23, end: 24, type: 'torso' },
            { start: 23, end: 25, type: 'leg' }, { start: 25, end: 27, type: 'leg' },
            { start: 24, end: 26, type: 'leg' }, { start: 26, end: 28, type: 'leg' },
            { start: 15, end: 17, type: 'hand' }, { start: 15, end: 19, type: 'hand' }, { start: 15, end: 21, type: 'hand' },
            { start: 16, end: 18, type: 'hand' }, { start: 16, end: 20, type: 'hand' }, { start: 16, end: 22, type: 'hand' },
            { start: 27, end: 29, type: 'foot' }, { start: 27, end: 31, type: 'foot' },
            { start: 28, end: 30, type: 'foot' }, { start: 28, end: 32, type: 'foot' },
            { start: 0, end: 1, type: 'face' }, { start: 1, end: 2, type: 'face' }, { start: 2, end: 3, type: 'face' }, { start: 3, end: 7, type: 'face' },
            { start: 0, end: 4, type: 'face' }, { start: 4, end: 5, type: 'face' }, { start: 5, end: 6, type: 'face' }, { start: 6, end: 8, type: 'face' },
            { start: 9, end: 10, type: 'face' },
        ];

        const JOINT_NAMES = [
            'NOSE', 'L_EYE_IN', 'L_EYE', 'L_EYE_OUT',
            'R_EYE_IN', 'R_EYE', 'R_EYE_OUT',
            'L_EAR', 'R_EAR', 'MOUTH_L', 'MOUTH_R',
            'L_SHOULDER', 'R_SHOULDER', 'L_ELBOW', 'R_ELBOW',
            'L_WRIST', 'R_WRIST', 'L_PINKY', 'R_PINKY',
            'L_INDEX', 'R_INDEX', 'L_THUMB', 'R_THUMB',
            'L_HIP', 'R_HIP', 'L_KNEE', 'R_KNEE',
            'L_ANKLE', 'R_ANKLE', 'L_HEEL', 'R_HEEL',
            'L_FOOT', 'R_FOOT'
        ];

        const KEY_JOINTS = [0, 11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28];

        // ==================== GLOBALS ====================
        let scene, camera, renderer, composer;
        let poseLandmarker, video;
        let currentMode = 'hologram';
        let isRunning = false;
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let fps = 0;
        let previousLandmarks = null;
        let processStartTime = 0;

        // 3D objects
        let joints = [];
        let bones = [];
        let particles = null;
        let energyField = null;
        let gridFloor = null;
        let hologramShell = null;
        let trailsGroup = null;
        let matrixRain = null;
        let xrayMesh = null;
        let jointTrails = [];

        // ==================== THREE.JS SETUP ====================
        function initThree() {
            const canvas = document.getElementById('three-canvas');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.background);
            scene.fog = new THREE.FogExp2(CONFIG.colors.background, 0.12);

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0.3, 3.5);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            // Post-processing
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                CONFIG.bloom.strength,
                CONFIG.bloom.radius,
                CONFIG.bloom.threshold
            );
            composer.addPass(bloomPass);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x111122, 0.4);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(CONFIG.colors.primary, 1.5, 15);
            pointLight1.position.set(3, 3, 3);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(CONFIG.colors.secondary, 1.2, 15);
            pointLight2.position.set(-3, 2, -3);
            scene.add(pointLight2);

            const pointLight3 = new THREE.PointLight(CONFIG.colors.tertiary, 0.8, 10);
            pointLight3.position.set(0, -2, 2);
            scene.add(pointLight3);

            createGridFloor();
            createSkeleton();
            createParticleSystem();
            createEnergyField();
            createHologramShell();
            createMatrixRain();
            createXRayMesh();
            createTrailsSystem();

            window.addEventListener('resize', onWindowResize);
            document.getElementById('render-status').classList.add('active');
        }

        function createGridFloor() {
            const gridSize = 30;
            const divisions = 60;

            // Main grid
            const gridGeometry = new THREE.BufferGeometry();
            const gridPositions = [];
            const gridColors = [];

            const color1 = new THREE.Color(CONFIG.colors.grid);
            const color2 = new THREE.Color(CONFIG.colors.primary);

            for (let i = -gridSize / 2; i <= gridSize / 2; i += gridSize / divisions) {
                const isCenter = Math.abs(i) < 0.1;
                const c = isCenter ? color2 : color1;

                gridPositions.push(-gridSize / 2, -1.5, i, gridSize / 2, -1.5, i);
                gridColors.push(c.r, c.g, c.b, c.r, c.g, c.b);

                gridPositions.push(i, -1.5, -gridSize / 2, i, -1.5, gridSize / 2);
                gridColors.push(c.r, c.g, c.b, c.r, c.g, c.b);
            }

            gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(gridPositions, 3));
            gridGeometry.setAttribute('color', new THREE.Float32BufferAttribute(gridColors, 3));

            const gridMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.4
            });

            gridFloor = new THREE.LineSegments(gridGeometry, gridMaterial);
            scene.add(gridFloor);

            // Concentric circles
            for (let r = 1; r <= 5; r++) {
                const circleGeometry = new THREE.BufferGeometry();
                const circlePoints = [];
                const segments = 64;

                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    circlePoints.push(Math.cos(angle) * r, -1.49, Math.sin(angle) * r);
                }

                circleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(circlePoints, 3));

                const circleMaterial = new THREE.LineBasicMaterial({
                    color: CONFIG.colors.primary,
                    transparent: true,
                    opacity: 0.15 + (0.05 * (5 - r))
                });

                const circle = new THREE.Line(circleGeometry, circleMaterial);
                scene.add(circle);
            }
        }

        function createSkeleton() {
            // Create joints with multiple layers for glow effect
            for (let i = 0; i < 33; i++) {
                const jointGroup = new THREE.Group();
                jointGroup.visible = false;

                // Core sphere
                const coreGeometry = new THREE.SphereGeometry(CONFIG.skeleton.jointSize, 16, 16);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: CONFIG.colors.primary,
                    transparent: true,
                    opacity: 1
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                jointGroup.add(core);

                // Outer glow
                const glowGeometry = new THREE.SphereGeometry(CONFIG.skeleton.jointSize * 2, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: CONFIG.colors.primary,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                jointGroup.add(glow);

                // Ring
                const ringGeometry = new THREE.RingGeometry(CONFIG.skeleton.jointSize * 1.5, CONFIG.skeleton.jointSize * 2, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: CONFIG.colors.primary,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                jointGroup.add(ring);

                // Store references
                jointGroup.userData = {
                    core,
                    glow,
                    ring,
                    index: i,
                    trailPositions: []
                };

                joints.push(jointGroup);
                scene.add(jointGroup);
            }

            // Create bones with energy pulse effect
            for (const conn of POSE_CONNECTIONS) {
                const boneGroup = new THREE.Group();
                boneGroup.visible = false;

                // Main bone
                const boneGeometry = new THREE.CylinderGeometry(
                    CONFIG.skeleton.boneWidth,
                    CONFIG.skeleton.boneWidth,
                    1,
                    8
                );
                const boneMaterial = new THREE.MeshBasicMaterial({
                    color: CONFIG.colors.primary,
                    transparent: true,
                    opacity: 0.8
                });
                const bone = new THREE.Mesh(boneGeometry, boneMaterial);
                boneGroup.add(bone);

                // Energy pulse ring
                const pulseGeometry = new THREE.TorusGeometry(CONFIG.skeleton.boneWidth * 2, CONFIG.skeleton.boneWidth * 0.5, 8, 16);
                const pulseMaterial = new THREE.MeshBasicMaterial({
                    color: CONFIG.colors.secondary,
                    transparent: true,
                    opacity: 0.6
                });
                const pulse = new THREE.Mesh(pulseGeometry, pulseMaterial);
                pulse.rotation.x = Math.PI / 2;
                boneGroup.add(pulse);

                boneGroup.userData = {
                    start: conn.start,
                    end: conn.end,
                    type: conn.type,
                    bone,
                    pulse,
                    pulsePosition: Math.random()
                };

                bones.push(boneGroup);
                scene.add(boneGroup);
            }
        }

        function createParticleSystem() {
            const particleCount = CONFIG.particles.count;
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const velocities = [];
            const targetJoints = [];

            const color1 = new THREE.Color(CONFIG.colors.primary);
            const color2 = new THREE.Color(CONFIG.colors.secondary);
            const color3 = new THREE.Color(CONFIG.colors.tertiary);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;

                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const r = Math.random() * 2.5;

                positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);

                const colorChoice = Math.random();
                let c;
                if (colorChoice < 0.5) c = color1;
                else if (colorChoice < 0.8) c = color2;
                else c = color3;

                colors[i3] = c.r;
                colors[i3 + 1] = c.g;
                colors[i3 + 2] = c.b;

                sizes[i] = Math.random() * CONFIG.particles.size + 0.005;

                velocities.push({
                    x: (Math.random() - 0.5) * CONFIG.particles.speed,
                    y: (Math.random() - 0.5) * CONFIG.particles.speed,
                    z: (Math.random() - 0.5) * CONFIG.particles.speed
                });

                targetJoints.push(Math.floor(Math.random() * KEY_JOINTS.length));
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.userData = { velocities, targetJoints };

            const material = new THREE.PointsMaterial({
                size: CONFIG.particles.size,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            particles.visible = false;
            scene.add(particles);
        }

        function createEnergyField() {
            const group = new THREE.Group();
            group.visible = false;

            // Outer icosahedron
            const outerGeometry = new THREE.IcosahedronGeometry(1.2, 1);
            const outerMaterial = new THREE.MeshBasicMaterial({
                color: CONFIG.colors.secondary,
                wireframe: true,
                transparent: true,
                opacity: 0.25
            });
            const outer = new THREE.Mesh(outerGeometry, outerMaterial);
            group.add(outer);

            // Middle icosahedron
            const middleGeometry = new THREE.IcosahedronGeometry(0.9, 2);
            const middleMaterial = new THREE.MeshBasicMaterial({
                color: CONFIG.colors.primary,
                wireframe: true,
                transparent: true,
                opacity: 0.35
            });
            const middle = new THREE.Mesh(middleGeometry, middleMaterial);
            group.add(middle);

            // Inner sphere
            const innerGeometry = new THREE.IcosahedronGeometry(0.6, 0);
            const innerMaterial = new THREE.MeshBasicMaterial({
                color: CONFIG.colors.tertiary,
                wireframe: true,
                transparent: true,
                opacity: 0.45
            });
            const inner = new THREE.Mesh(innerGeometry, innerMaterial);
            group.add(inner);

            // Energy rings
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.TorusGeometry(0.8 + i * 0.2, 0.02, 8, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: i === 1 ? CONFIG.colors.secondary : CONFIG.colors.primary,
                    transparent: true,
                    opacity: 0.4
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2 + (i * 0.3);
                ring.rotation.z = i * 0.5;
                group.add(ring);
            }

            group.userData = { outer, middle, inner };
            energyField = group;
            scene.add(energyField);
        }

        function createHologramShell() {
            const group = new THREE.Group();

            // Vertical lines
            const lineCount = 60;
            const radius = 1.4;
            const height = 3;

            const linesGeometry = new THREE.BufferGeometry();
            const positions = [];

            for (let i = 0; i < lineCount; i++) {
                const angle = (i / lineCount) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                positions.push(x, -1.5, z, x, height - 1.5, z);
            }

            linesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const linesMaterial = new THREE.LineBasicMaterial({
                color: CONFIG.colors.primary,
                transparent: true,
                opacity: 0.12
            });

            const lines = new THREE.LineSegments(linesGeometry, linesMaterial);
            group.add(lines);

            // Horizontal rings
            for (let h = 0; h < 8; h++) {
                const ringGeometry = new THREE.RingGeometry(radius - 0.01, radius + 0.01, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: h % 2 === 0 ? CONFIG.colors.primary : CONFIG.colors.secondary,
                    transparent: true,
                    opacity: 0.08,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = (h / 7) * height - 1.5;
                group.add(ring);
            }

            // Top and bottom caps
            const capGeometry = new THREE.RingGeometry(0, radius, 32);
            const capMaterial = new THREE.MeshBasicMaterial({
                color: CONFIG.colors.primary,
                transparent: true,
                opacity: 0.05,
                side: THREE.DoubleSide
            });

            const topCap = new THREE.Mesh(capGeometry, capMaterial);
            topCap.rotation.x = -Math.PI / 2;
            topCap.position.y = height - 1.5;
            group.add(topCap);

            const bottomCap = new THREE.Mesh(capGeometry.clone(), capMaterial.clone());
            bottomCap.rotation.x = -Math.PI / 2;
            bottomCap.position.y = -1.5;
            group.add(bottomCap);

            hologramShell = group;
            scene.add(hologramShell);
        }

        function createMatrixRain() {
            const count = 500;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const speeds = [];

            const color = new THREE.Color(CONFIG.colors.tertiary);

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 6;
                positions[i3 + 1] = Math.random() * 4 - 1;
                positions[i3 + 2] = (Math.random() - 0.5) * 6;

                const brightness = 0.3 + Math.random() * 0.7;
                colors[i3] = color.r * brightness;
                colors[i3 + 1] = color.g * brightness;
                colors[i3 + 2] = color.b * brightness;

                sizes[i] = Math.random() * 0.08 + 0.02;
                speeds.push(Math.random() * 0.03 + 0.01);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.userData = { speeds };

            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            matrixRain = new THREE.Points(geometry, material);
            matrixRain.visible = false;
            scene.add(matrixRain);
        }

        function createXRayMesh() {
            // Create a simple body outline mesh for x-ray mode
            const group = new THREE.Group();
            group.visible = false;

            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(0.2, 0.25, 0.6, 8);
            const xrayMaterial = new THREE.MeshBasicMaterial({
                color: CONFIG.colors.xray,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const torso = new THREE.Mesh(torsoGeometry, xrayMaterial.clone());
            group.add(torso);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.12, 8, 8);
            const head = new THREE.Mesh(headGeometry, xrayMaterial.clone());
            head.position.y = 0.45;
            group.add(head);

            // Limb cylinders
            const limbGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.4, 6);

            // Arms
            const leftArm = new THREE.Mesh(limbGeometry.clone(), xrayMaterial.clone());
            leftArm.position.set(-0.35, 0.1, 0);
            leftArm.rotation.z = Math.PI / 4;
            group.add(leftArm);

            const rightArm = new THREE.Mesh(limbGeometry.clone(), xrayMaterial.clone());
            rightArm.position.set(0.35, 0.1, 0);
            rightArm.rotation.z = -Math.PI / 4;
            group.add(rightArm);

            // Legs
            const leftLeg = new THREE.Mesh(limbGeometry.clone(), xrayMaterial.clone());
            leftLeg.position.set(-0.1, -0.5, 0);
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(limbGeometry.clone(), xrayMaterial.clone());
            rightLeg.position.set(0.1, -0.5, 0);
            group.add(rightLeg);

            xrayMesh = group;
            scene.add(xrayMesh);
        }

        function createTrailsSystem() {
            trailsGroup = new THREE.Group();
            scene.add(trailsGroup);

            // Create trail lines for key joints
            for (const jointIndex of KEY_JOINTS) {
                const trailGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(CONFIG.trails.length * 3);
                trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const trailMaterial = new THREE.LineBasicMaterial({
                    color: CONFIG.colors.secondary,
                    transparent: true,
                    opacity: 0.6
                });

                const trail = new THREE.Line(trailGeometry, trailMaterial);
                trail.visible = false;
                trail.userData = { jointIndex, positions: [] };
                jointTrails.push(trail);
                trailsGroup.add(trail);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== MEDIAPIPE SETUP ====================
        async function initMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm'
            );

            // Try GPU first, fall back to CPU
            try {
                poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task',
                        delegate: 'GPU'
                    },
                    runningMode: 'VIDEO',
                    numPoses: 1
                });
            } catch (gpuError) {
                console.warn('GPU delegate failed, falling back to CPU:', gpuError);
                poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task',
                        delegate: 'CPU'
                    },
                    runningMode: 'VIDEO',
                    numPoses: 1
                });
            }

            document.getElementById('ai-status').classList.add('active');
            document.getElementById('ai-val').textContent = 'ONLINE';
        }

        async function initWebcam() {
            video = document.getElementById('webcam');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user'
                    }
                });
                video.srcObject = stream;

                await new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });

                document.getElementById('camera-status').classList.add('active');
                document.getElementById('camera-val').textContent = 'ACTIVE';

                return true;
            } catch (err) {
                console.error('Webcam error:', err);
                document.getElementById('camera-val').textContent = 'ERROR';
                return false;
            }
        }

        // ==================== POSE PROCESSING ====================
        function processLandmarks(landmarks) {
            if (!landmarks || landmarks.length === 0) return;

            const pose = landmarks[0];
            let visibleCount = 0;
            let totalConfidence = 0;

            // Update joints
            pose.forEach((landmark, i) => {
                if (landmark.visibility > 0.5) {
                    visibleCount++;
                    totalConfidence += landmark.visibility;

                    const x = -(landmark.x - 0.5) * 2.5;
                    const y = -(landmark.y - 0.5) * 2.5;
                    const z = -landmark.z * 2;

                    joints[i].position.set(x, y, z);

                    const showJoints = currentMode === 'hologram' || currentMode === 'wireframe' || currentMode === 'xray';
                    joints[i].visible = showJoints;

                    // Update trail
                    const trailData = joints[i].userData.trailPositions;
                    trailData.unshift({ x, y, z });
                    if (trailData.length > CONFIG.trails.length) {
                        trailData.pop();
                    }

                    // Color based on body part
                    let color;
                    if (i < 11) color = new THREE.Color(CONFIG.colors.secondary);
                    else if (i < 17) color = new THREE.Color(CONFIG.colors.primary);
                    else if (i < 23) color = new THREE.Color(CONFIG.colors.tertiary);
                    else color = new THREE.Color(CONFIG.colors.primary);

                    if (currentMode === 'xray') {
                        color = new THREE.Color(CONFIG.colors.xray);
                    }

                    joints[i].userData.core.material.color = color;
                    joints[i].userData.glow.material.color = color;
                    joints[i].userData.ring.material.color = color;
                } else {
                    joints[i].visible = false;
                }
            });

            // Update bones
            bones.forEach((boneGroup) => {
                const { start, end, bone, pulse, type } = boneGroup.userData;
                const startJoint = joints[start];
                const endJoint = joints[end];

                if (startJoint.visible && endJoint.visible) {
                    const startPos = startJoint.position;
                    const endPos = endJoint.position;

                    boneGroup.position.copy(startPos).add(endPos).multiplyScalar(0.5);
                    boneGroup.lookAt(endPos);
                    boneGroup.rotateX(Math.PI / 2);

                    const length = startPos.distanceTo(endPos);
                    bone.scale.set(1, length, 1);

                    // Animate pulse position
                    boneGroup.userData.pulsePosition += 0.02;
                    if (boneGroup.userData.pulsePosition > 1) boneGroup.userData.pulsePosition = 0;
                    pulse.position.y = (boneGroup.userData.pulsePosition - 0.5) * length;

                    const showBones = currentMode === 'hologram' || currentMode === 'wireframe' || currentMode === 'xray';
                    boneGroup.visible = showBones;

                    // Color based on type
                    let color = new THREE.Color(CONFIG.colors.primary);
                    if (type === 'torso') color = new THREE.Color(CONFIG.colors.primary);
                    else if (type === 'arm') color = new THREE.Color(CONFIG.colors.secondary);
                    else if (type === 'leg') color = new THREE.Color(CONFIG.colors.primary);
                    else if (type === 'hand' || type === 'foot') color = new THREE.Color(CONFIG.colors.tertiary);

                    if (currentMode === 'xray') {
                        color = new THREE.Color(CONFIG.colors.xray);
                        pulse.visible = false;
                    } else {
                        pulse.visible = currentMode === 'hologram';
                    }

                    bone.material.color = color;
                } else {
                    boneGroup.visible = false;
                }
            });

            // Update trails
            updateTrails(pose);

            // Update energy field
            updateEnergyField(pose);

            // Update particles
            if (currentMode === 'particles') {
                updateParticles(pose);
                particles.visible = true;
            } else {
                particles.visible = false;
            }

            // Update x-ray mesh
            updateXRayMesh(pose);

            // Calculate metrics
            updateMetrics(pose, visibleCount, totalConfidence);

            previousLandmarks = pose;
        }

        function updateTrails(pose) {
            jointTrails.forEach((trail) => {
                const jointIndex = trail.userData.jointIndex;
                const joint = joints[jointIndex];

                if (joint.visible) {
                    const trailPositions = joint.userData.trailPositions;
                    const positionsArray = trail.geometry.attributes.position.array;

                    for (let i = 0; i < CONFIG.trails.length; i++) {
                        const i3 = i * 3;
                        if (i < trailPositions.length) {
                            positionsArray[i3] = trailPositions[i].x;
                            positionsArray[i3 + 1] = trailPositions[i].y;
                            positionsArray[i3 + 2] = trailPositions[i].z;
                        } else {
                            positionsArray[i3] = joint.position.x;
                            positionsArray[i3 + 1] = joint.position.y;
                            positionsArray[i3 + 2] = joint.position.z;
                        }
                    }

                    trail.geometry.attributes.position.needsUpdate = true;
                    trail.geometry.setDrawRange(0, Math.min(trailPositions.length, CONFIG.trails.length));
                    trail.visible = currentMode === 'hologram' || currentMode === 'particles';
                } else {
                    trail.visible = false;
                }
            });
        }

        function updateEnergyField(pose) {
            if (currentMode !== 'energy') {
                energyField.visible = false;
                return;
            }

            if (pose[23] && pose[24] && pose[23].visibility > 0.5) {
                const hipCenter = new THREE.Vector3(
                    -(((pose[23].x + pose[24].x) / 2) - 0.5) * 2.5,
                    -(((pose[23].y + pose[24].y) / 2) - 0.5) * 2.5,
                    -(((pose[23].z + pose[24].z) / 2)) * 2
                );
                energyField.position.copy(hipCenter);
                energyField.visible = true;
            }
        }

        function updateParticles(pose) {
            const positions = particles.geometry.attributes.position.array;
            const { velocities, targetJoints } = particles.geometry.userData;

            for (let i = 0; i < positions.length / 3; i++) {
                const i3 = i * 3;
                const targetJointIndex = KEY_JOINTS[targetJoints[i]];
                const targetJoint = joints[targetJointIndex];

                if (targetJoint && targetJoint.visible) {
                    const target = targetJoint.position;
                    const dx = target.x - positions[i3];
                    const dy = target.y - positions[i3 + 1];
                    const dz = target.z - positions[i3 + 2];
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    if (dist > 0.05) {
                        const force = 0.015 / (dist + 0.3);
                        positions[i3] += dx * force + velocities[i].x * 0.008;
                        positions[i3 + 1] += dy * force + velocities[i].y * 0.008;
                        positions[i3 + 2] += dz * force + velocities[i].z * 0.008;
                    }

                    // Orbital motion
                    const angle = performance.now() * 0.001 + i * 0.1;
                    positions[i3] += Math.cos(angle) * 0.002;
                    positions[i3 + 2] += Math.sin(angle) * 0.002;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
        }

        function updateXRayMesh(pose) {
            if (currentMode !== 'xray') {
                xrayMesh.visible = false;
                return;
            }

            if (pose[11] && pose[12] && pose[23] && pose[24] &&
                pose[11].visibility > 0.5 && pose[23].visibility > 0.5) {

                const shoulderMid = {
                    x: -(((pose[11].x + pose[12].x) / 2) - 0.5) * 2.5,
                    y: -(((pose[11].y + pose[12].y) / 2) - 0.5) * 2.5,
                    z: -(((pose[11].z + pose[12].z) / 2)) * 2
                };

                const hipMid = {
                    x: -(((pose[23].x + pose[24].x) / 2) - 0.5) * 2.5,
                    y: -(((pose[23].y + pose[24].y) / 2) - 0.5) * 2.5,
                    z: -(((pose[23].z + pose[24].z) / 2)) * 2
                };

                xrayMesh.position.set(
                    (shoulderMid.x + hipMid.x) / 2,
                    (shoulderMid.y + hipMid.y) / 2,
                    (shoulderMid.z + hipMid.z) / 2
                );

                xrayMesh.visible = true;
            }
        }

        function updateMetrics(pose, visibleCount, totalConfidence) {
            const avgConfidence = visibleCount > 0 ? (totalConfidence / visibleCount * 100).toFixed(1) : 0;
            document.getElementById('confidence-val').textContent = avgConfidence + '%';
            document.getElementById('confidence-bar').style.width = avgConfidence + '%';
            document.getElementById('points-val').textContent = `${visibleCount}/33`;
            document.getElementById('landmarks-bar').style.width = (visibleCount / 33 * 100) + '%';

            // Head angle
            if (pose[0] && pose[11] && pose[12] &&
                pose[0].visibility > 0.5 && pose[11].visibility > 0.5 && pose[12].visibility > 0.5) {
                const shoulderMidX = (pose[11].x + pose[12].x) / 2;
                const headOffset = pose[0].x - shoulderMidX;
                const angle = (headOffset * 90).toFixed(1);
                document.getElementById('head-angle').textContent = angle + '°';
            }

            // Shoulder width
            if (pose[11] && pose[12] && pose[11].visibility > 0.5 && pose[12].visibility > 0.5) {
                const width = Math.abs(pose[11].x - pose[12].x) * 100;
                document.getElementById('shoulder-width').textContent = width.toFixed(1) + ' cm';
            }

            // Arm span
            if (pose[15] && pose[16] && pose[15].visibility > 0.5 && pose[16].visibility > 0.5) {
                const span = Math.abs(pose[15].x - pose[16].x) * 200;
                document.getElementById('arm-span').textContent = span.toFixed(1) + ' cm';
            }

            // Stance width
            if (pose[27] && pose[28] && pose[27].visibility > 0.5 && pose[28].visibility > 0.5) {
                const stance = Math.abs(pose[27].x - pose[28].x) * 100;
                document.getElementById('stance-width').textContent = stance.toFixed(1) + ' cm';
            }

            // Velocity
            if (previousLandmarks && pose[0] && previousLandmarks[0]) {
                const dx = pose[0].x - previousLandmarks[0].x;
                const dy = pose[0].y - previousLandmarks[0].y;
                const velocity = Math.sqrt(dx * dx + dy * dy) * 100 * fps;
                document.getElementById('velocity-val').textContent = velocity.toFixed(2) + ' m/s';
            }

            // Symmetry (comparing left and right sides)
            if (pose[11] && pose[12] && pose[23] && pose[24] &&
                pose[11].visibility > 0.5 && pose[12].visibility > 0.5) {
                const leftSide = Math.abs(pose[11].x - pose[23].x) + Math.abs(pose[11].y - pose[23].y);
                const rightSide = Math.abs(pose[12].x - pose[24].x) + Math.abs(pose[12].y - pose[24].y);
                const symmetry = (1 - Math.abs(leftSide - rightSide) / Math.max(leftSide, rightSide)) * 100;
                document.getElementById('symmetry-val').textContent = symmetry.toFixed(1) + '%';
            }

            // Center of mass
            if (pose[23] && pose[24] && pose[23].visibility > 0.5) {
                const comX = ((pose[23].x + pose[24].x) / 2 - 0.5) * 100;
                const comY = ((pose[23].y + pose[24].y) / 2 - 0.5) * 100;
                document.getElementById('com-val').textContent = `${comX.toFixed(0)}, ${comY.toFixed(0)}`;
            }

            // Update joints list
            updateJointsList(pose);
        }

        function updateJointsList(pose) {
            const list = document.getElementById('joints-list');
            let html = '';

            KEY_JOINTS.slice(0, 8).forEach(i => {
                if (pose[i] && pose[i].visibility > 0.5) {
                    const conf = (pose[i].visibility * 100).toFixed(0);
                    const color = pose[i].visibility > 0.8 ? '#0f0' : pose[i].visibility > 0.6 ? '#ff0' : '#f90';
                    html += `<div style="display:flex;justify-content:space-between;"><span style="color:${color}">● ${JOINT_NAMES[i]}</span><span style="color:#fff">${conf}%</span></div>`;
                }
            });

            list.innerHTML = html;
        }

        // ==================== ANIMATION LOOP ====================
        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            frameCount++;

            if (now - lastFrameTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFrameTime = now;
                document.getElementById('fps-val').textContent = fps;
            }

            // Process pose
            if (isRunning && poseLandmarker && video.readyState >= 2) {
                processStartTime = performance.now();
                const result = poseLandmarker.detectForVideo(video, now);
                const latency = (performance.now() - processStartTime).toFixed(0);
                document.getElementById('latency-val').textContent = latency + 'ms';

                if (result.landmarks) {
                    processLandmarks(result.landmarks);

                    // Occasional glitch effect
                    if (Math.random() < 0.002) {
                        triggerGlitch();
                    }
                }
            }

            // Animate scene
            const time = now * 0.001;

            // Rotate hologram shell
            if (hologramShell) {
                hologramShell.rotation.y = time * 0.08;
            }

            // Animate energy field
            if (energyField && energyField.visible) {
                const { outer, middle, inner } = energyField.userData;
                outer.rotation.x = time * 0.2;
                outer.rotation.y = time * 0.15;
                middle.rotation.x = -time * 0.25;
                middle.rotation.z = time * 0.2;
                inner.rotation.y = time * 0.4;
                inner.rotation.z = -time * 0.3;

                // Scale pulsing
                const scale = 1 + Math.sin(time * 2) * 0.1;
                energyField.scale.setScalar(scale);
            }

            // Animate matrix rain
            if (matrixRain && currentMode === 'matrix') {
                matrixRain.visible = true;
                const positions = matrixRain.geometry.attributes.position.array;
                const speeds = matrixRain.geometry.userData.speeds;

                for (let i = 0; i < positions.length / 3; i++) {
                    const i3 = i * 3;
                    positions[i3 + 1] -= speeds[i];

                    if (positions[i3 + 1] < -2) {
                        positions[i3 + 1] = 3;
                        positions[i3] = (Math.random() - 0.5) * 6;
                        positions[i3 + 2] = (Math.random() - 0.5) * 6;
                    }
                }

                matrixRain.geometry.attributes.position.needsUpdate = true;
            } else if (matrixRain) {
                matrixRain.visible = false;
            }

            // Pulse joints
            joints.forEach((joint, i) => {
                if (joint.visible) {
                    const pulse = 1 + Math.sin(time * 4 + i * 0.3) * 0.15;
                    joint.userData.glow.scale.setScalar(pulse);
                    joint.userData.ring.rotation.z = time * 2 + i;
                    joint.userData.ring.scale.setScalar(0.8 + Math.sin(time * 3 + i) * 0.2);
                }
            });

            // Grid pulse
            if (gridFloor) {
                gridFloor.material.opacity = 0.3 + Math.sin(time * 0.5) * 0.1;
            }

            // Camera breathing
            camera.position.x = Math.sin(time * 0.15) * 0.15;
            camera.position.y = 0.3 + Math.sin(time * 0.2) * 0.08;
            camera.lookAt(0, 0, 0);

            // Update timestamp
            updateTimestamp();

            composer.render();
        }

        function updateTimestamp() {
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const seconds = now.getSeconds().toString().padStart(2, '0');
            const ms = now.getMilliseconds().toString().padStart(3, '0');
            document.getElementById('timestamp').textContent = `${hours}:${minutes}:${seconds}.${ms} // NEXUS ACTIVE`;
        }

        function triggerGlitch() {
            const glitch = document.getElementById('glitch-overlay');
            glitch.classList.add('active');
            setTimeout(() => glitch.classList.remove('active'), 150);
        }

        // ==================== MODE SWITCHING ====================
        function setMode(mode) {
            currentMode = mode;

            document.querySelectorAll('#mode-toggle button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });

            // Reset visibilities
            joints.forEach(j => j.visible = false);
            bones.forEach(b => b.visible = false);
            particles.visible = false;
            energyField.visible = false;
            matrixRain.visible = false;
            xrayMesh.visible = false;
            jointTrails.forEach(t => t.visible = false);

            triggerGlitch();
        }

        // ==================== INITIALIZATION ====================
        async function start() {
            const titleScreen = document.getElementById('title-screen');
            const loading = document.getElementById('loading');
            const loadingBar = document.getElementById('loading-bar');
            const loadingText = document.getElementById('loading-text');

            titleScreen.classList.add('hidden');

            loading.classList.add('active');
            loadingBar.style.width = '10%';

            try {
                loadingText.textContent = 'LOADING NEURAL NETWORK';
                loadingBar.style.width = '30%';
                await initMediaPipe();

                loadingText.textContent = 'CALIBRATING SENSORS';
                loadingBar.style.width = '60%';
                await new Promise(r => setTimeout(r, 500));

                loadingText.textContent = 'ACTIVATING CAMERA';
                loadingBar.style.width = '80%';
                const webcamReady = await initWebcam();

                if (!webcamReady) {
                    throw new Error('Webcam failed');
                }

                loadingText.textContent = 'SYSTEM READY';
                loadingBar.style.width = '100%';
                await new Promise(r => setTimeout(r, 500));

                loading.classList.remove('active');
                isRunning = true;

                // Show reticle
                const reticle = document.getElementById('reticle');
                reticle.style.left = '50%';
                reticle.style.top = '50%';
                reticle.style.transform = 'translate(-50%, -50%)';
                reticle.classList.add('active');
                setTimeout(() => reticle.classList.remove('active'), 2000);

            } catch (error) {
                console.error('Initialization error:', error);
                loadingText.textContent = 'ERROR: ' + (error.message || 'Unknown error');
                loadingText.style.color = '#ff3366';
                loadingBar.style.background = '#ff3366';
            }
        }

        // ==================== EVENT LISTENERS ====================
        document.getElementById('start-btn').addEventListener('click', start);

        document.querySelectorAll('#mode-toggle button').forEach(btn => {
            btn.addEventListener('click', () => setMode(btn.dataset.mode));
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            const modes = ['hologram', 'wireframe', 'particles', 'energy', 'xray', 'matrix'];
            const num = parseInt(e.key);
            if (num >= 1 && num <= 6) {
                setMode(modes[num - 1]);
            }
        });

        // ==================== MAIN ====================
        initThree();
        animate();
    </script>
</body>
</html>
