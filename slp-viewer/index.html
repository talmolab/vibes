<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLP Viewer - SLEAP Pose Visualization</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        h1 { margin-bottom: 0.5rem; color: #fff; }
        .description { color: #aaa; margin-top: 0; }
        .container { max-width: 1200px; margin: 0 auto; }
        .controls {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 6px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            margin: 3px;
        }
        button:hover { background: #5568d3; }
        button:disabled { background: #444; cursor: not-allowed; }
        .canvas-container {
            position: relative;
            background: #000;
            border-radius: 8px 8px 0 0;
            overflow: hidden;
            margin: 20px 0 0 0;
            cursor: grab;
            height: 70vh;
            min-height: 150px;
            max-height: 90vh;
        }
        .canvas-container:active { cursor: grabbing; }
        .resize-handle {
            height: 8px;
            background: #2a2a2a;
            border-radius: 0 0 8px 8px;
            cursor: ns-resize;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }
        .resize-handle:hover { background: #3a3a3a; }
        .resize-handle::after {
            content: '';
            width: 40px;
            height: 3px;
            background: #555;
            border-radius: 2px;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: crisp-edges;
        }
        .seekbar-container {
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .seekbar {
            width: 100%;
            height: 8px;
            background: #444;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            margin: 10px 0;
        }
        .seekbar-progress {
            height: 100%;
            background: #667eea;
            border-radius: 4px;
            width: 0%;
            pointer-events: none;
        }
        .seekbar-thumb {
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            left: 0%;
            pointer-events: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .playback-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 6px;
            margin-top: 10px;
        }
        .playback-controls button {
            width: 26px;
            height: 26px;
            padding: 0;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .control-separator {
            width: 1px;
            height: 18px;
            background: #444;
            margin: 0 6px;
        }
        .info-row {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .metrics {
            flex: 2;
            min-width: 300px;
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #aaa;
        }
        .metrics h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            font-family: system-ui, -apple-system, sans-serif;
            color: #ccc;
        }
        .metrics-row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .metric { margin: 5px 0; }
        .metric-label { color: #667eea; font-weight: bold; }
        .overlay-controls {
            flex: 1;
            min-width: 200px;
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
        }
        .overlay-controls h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #ccc;
        }
        .overlay-controls label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 14px;
            color: #ccc;
            margin: 5px 0;
        }
        .overlay-controls input[type="checkbox"] { cursor: pointer; }
        .overlay-controls input[type="range"] {
            flex: 1;
            max-width: 100px;
        }
        .track-legend {
            flex: 1;
            min-width: 150px;
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
        }
        .track-legend h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #ccc;
        }
        .track-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            font-size: 13px;
        }
        .track-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        .track-name { color: #aaa; }
        .cache-viz-container {
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .cache-viz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .cache-viz-header h3 {
            margin: 0;
            color: #fff;
            font-size: 14px;
        }
        .cache-viz-settings {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .cache-viz-settings label {
            color: #aaa;
            font-size: 12px;
        }
        .cache-viz-settings input[type="number"] {
            background: #1a1a1a;
            border: 1px solid #444;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            width: 60px;
            font-size: 12px;
        }
        .cache-viz-legend {
            display: flex;
            gap: 15px;
            font-size: 12px;
            color: #aaa;
        }
        .cache-viz-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .cache-viz-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        .cache-viz-canvas {
            width: 100%;
            height: 24px;
            border-radius: 4px;
        }
        .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
        }
        .slider-row label {
            font-size: 13px;
            color: #aaa;
            min-width: 80px;
        }
        .slider-row input[type="range"] { flex: 1; }
        .slider-row .slider-value {
            font-size: 12px;
            color: #667eea;
            min-width: 35px;
            text-align: right;
        }
        .diagnostic-console {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        .diagnostic-console-header {
            background: #2a2a2a;
            padding: 8px 15px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .diagnostic-console-header h3 { margin: 0; color: #fff; font-size: 12px; }
        .diagnostic-console-header button {
            background: #444;
            padding: 4px 10px;
            font-size: 11px;
            margin: 0;
        }
        .diagnostic-console-body {
            height: 120px;
            overflow-y: auto;
            padding: 10px 15px;
        }
        .log-entry { margin: 2px 0; display: flex; gap: 10px; }
        .log-time { color: #666; flex-shrink: 0; }
        .log-msg { color: #aaa; }
        .log-msg.info { color: #667eea; }
        .log-msg.success { color: #4ade80; }
        .log-msg.warn { color: #fbbf24; }
        .log-msg.error { color: #ff6b6b; }
        .error-msg {
            background: #4a2020;
            border: 1px solid #ff6b6b;
            color: #ff6b6b;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
            display: none;
        }
        .loading {
            display: none;
            align-items: center;
            gap: 10px;
            color: #667eea;
            margin: 20px 0;
        }
        .loading.visible { display: flex; }
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #333;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .hotkeys {
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 14px;
        }
        .hotkeys h3 { margin-top: 0; color: #fff; }
        .hotkeys-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px 20px;
        }
        .hotkey { display: flex; gap: 10px; }
        .hotkey-key {
            color: #667eea;
            font-family: 'Courier New', monospace;
            min-width: 100px;
        }
        .hotkey-desc { color: #aaa; }
        .status-banner {
            background: #2a2a2a;
            padding: 10px 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            font-size: 13px;
        }
        .status-banner #statusType {
            font-weight: bold;
            color: #667eea;
        }
        .status-banner #statusDetails {
            color: #888;
        }
        .video-selector {
            background: #2a2a2a;
            padding: 10px 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .video-selector label {
            color: #ccc;
            font-size: 14px;
        }
        .video-selector select {
            background: #1a1a1a;
            color: #e0e0e0;
            border: 1px solid #444;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            flex: 1;
            max-width: 400px;
        }
        #videoInfo {
            color: #888;
            font-size: 12px;
        }
        .seekbar-marks {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .seekbar-mark {
            position: absolute;
            width: 2px;
            height: 100%;
            top: 0;
        }
        .mark-user { background: #4ade80; }
        .mark-predicted { background: #667eea; }
        .mark-both {
            background: linear-gradient(to bottom, #4ade80 50%, #667eea 50%);
        }
        .fallback-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fbbf24;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .view-poses-btn {
            background: #4a4a4a;
            color: #fbbf24;
            border: 1px solid #fbbf24;
        }
        .view-poses-btn:hover {
            background: #5a5a5a;
        }
        .video-resolution-panel {
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 10px 0;
            border: 1px solid #444;
        }
        .video-resolution-panel h3 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 14px;
        }
        .video-resolution-panel p {
            color: #888;
            font-size: 13px;
            margin: 0 0 15px 0;
        }
        .video-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        .video-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 13px;
        }
        .video-item .video-status {
            font-size: 16px;
            width: 24px;
            text-align: center;
            flex-shrink: 0;
        }
        .video-item .video-filename {
            flex: 1;
            color: #aaa;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .video-item .select-video-btn {
            padding: 4px 10px;
            font-size: 12px;
            background: #444;
            margin: 0;
        }
        .video-item .select-video-btn:hover {
            background: #555;
        }
        .video-item.resolved .video-filename {
            color: #4ade80;
        }
        .resolution-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .resolution-actions button {
            flex: 1;
            min-width: 120px;
        }
        .resolution-actions .load-dir-btn {
            background: #667eea;
        }
        .resolution-actions .skip-btn {
            background: #4a4a4a;
            color: #fbbf24;
            border: 1px solid #fbbf24;
        }
        @media (max-width: 600px) {
            body { padding: 10px; }
            .controls { padding: 8px 10px; }
            button { padding: 6px 12px; font-size: 13px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SLP Viewer</h1>
        <p class="description">View SLEAP pose predictions overlaid on video. Load an SLP file and its corresponding video.</p>

        <div class="controls">
            <input type="file" id="slpInput" accept=".slp" style="display: none;">
            <input type="file" id="videoInput" accept="video/mp4,video/quicktime,video/webm,.mp4,.mov,.m4v,.webm" style="display: none;">
            <button id="loadDemoBtn">Load Demo</button>
            <button id="loadSlpBtn">Load SLP File</button>
            <button id="loadVideoBtn" disabled>Load Video</button>
            <button id="viewPosesBtn" class="view-poses-btn" disabled>View Poses Only</button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <span id="loadingText">Loading...</span>
        </div>

        <div class="error-msg" id="errorMsg"></div>

        <div class="status-banner" id="statusBanner" style="display: none;">
            <span id="statusType"></span>
            <span id="statusDetails"></span>
        </div>

        <div class="video-selector" id="videoSelectorContainer" style="display: none;">
            <label>Video:</label>
            <select id="videoSelect"></select>
            <span id="videoInfo"></span>
        </div>

        <div class="video-resolution-panel" id="videoResolutionPanel" style="display: none;">
            <h3>üìÅ Video Files</h3>
            <p>Found <span id="videoCount">0</span> video reference(s). Select video files to enable playback.</p>
            <div class="video-list" id="videoList"></div>
            <div class="resolution-actions">
                <button id="loadDirectoryBtn" class="load-dir-btn">Load Directory</button>
                <button id="skipAllVideosBtn" class="skip-btn">Skip (poses only)</button>
            </div>
        </div>

        <div class="canvas-container" id="canvasContainer" style="display: none;">
            <canvas id="canvas"></canvas>
            <div class="fallback-indicator" id="fallbackIndicator" style="display: none;">
                üì∑ Poses only (no video)
            </div>
        </div>
        <div class="resize-handle" id="resizeHandle" style="display: none;"></div>

        <div class="seekbar-container" id="seekbarContainer" style="display: none;">
            <div class="seekbar" id="seekbar">
                <div class="seekbar-marks" id="seekbarMarks"></div>
                <div class="seekbar-progress" id="seekbarProgress"></div>
                <div class="seekbar-thumb" id="seekbarThumb"></div>
            </div>
            <div class="playback-controls">
                <button id="firstFrameBtn" title="First frame (Home)">|‚ùÆ</button>
                <button id="prevFrameBtn" title="Previous frame (‚Üê)">‚ùÆ</button>
                <button id="playBtn">‚ñ∂</button>
                <button id="nextFrameBtn" title="Next frame (‚Üí)">‚ùØ</button>
                <button id="lastFrameBtn" title="Last frame (End)">‚ùØ|</button>
                <span class="control-separator"></span>
                <button id="zoomOutBtn" title="Zoom out">‚àí</button>
                <button id="zoomInBtn" title="Zoom in">+</button>
                <button id="resetZoomBtn" title="Reset view">‚ü≤</button>
            </div>
        </div>

        <div class="info-row" id="infoRow" style="display: none;">
            <div class="metrics" id="metrics">
                <h3>Info</h3>
                <div class="metrics-row">
                    <div class="metric"><span class="metric-label">Video:</span> <span id="metricVideo">-</span></div>
                    <div class="metric"><span class="metric-label">SLP:</span> <span id="metricSlp">-</span></div>
                </div>
                <div class="metrics-row">
                    <div class="metric"><span class="metric-label">Frame:</span> <span id="metricFrame">-</span>/<span id="metricTotal">-</span></div>
                    <div class="metric"><span class="metric-label">Instances:</span> <span id="metricInstances">-</span></div>
                    <div class="metric"><span class="metric-label">Skeleton:</span> <span id="metricSkeleton">-</span></div>
                </div>
            </div>

            <div class="overlay-controls" id="overlayControls">
                <h3>Overlays</h3>
                <label><input type="checkbox" id="showPoses" checked> Show Poses</label>
                <label><input type="checkbox" id="showEdges" checked> Show Edges</label>
                <label><input type="checkbox" id="showNodes" checked> Show Nodes</label>
                <label><input type="checkbox" id="showFrameIndex" checked> Frame Index</label>
                <label><input type="checkbox" id="showTiming" checked> Timing Stats</label>
                <div class="slider-row">
                    <label>Node Size:</label>
                    <input type="range" id="nodeSize" min="2" max="12" value="5">
                    <span class="slider-value" id="nodeSizeValue">5</span>
                </div>
                <div class="slider-row">
                    <label>Edge Width:</label>
                    <input type="range" id="edgeWidth" min="1" max="6" value="2">
                    <span class="slider-value" id="edgeWidthValue">2</span>
                </div>
            </div>

            <div class="track-legend" id="trackLegend">
                <h3>Tracks</h3>
                <div id="trackList">
                    <div class="track-item">
                        <span class="track-color" style="background: #888;"></span>
                        <span class="track-name">No tracks loaded</span>
                    </div>
                </div>
            </div>

        </div>

        <div class="cache-viz-container" id="cacheVizContainer" style="display: none;">
            <div class="cache-viz-header">
                <h3>Frame Cache</h3>
                <div class="cache-viz-settings">
                    <label>Cache Size: <input type="number" id="cacheSize" value="120" min="10" max="500"></label>
                    <label>Lookahead: <input type="number" id="lookahead" value="60" min="1" max="200"></label>
                </div>
                <div class="cache-viz-legend">
                    <div class="cache-viz-legend-item"><div class="cache-viz-legend-color" style="background: #4ade80;"></div> Cached</div>
                    <div class="cache-viz-legend-item"><div class="cache-viz-legend-color" style="background: #fbbf24;"></div> Keyframe</div>
                    <div class="cache-viz-legend-item"><div class="cache-viz-legend-color" style="background: #667eea;"></div> Current</div>
                </div>
            </div>
            <canvas class="cache-viz-canvas" id="cacheVizCanvas"></canvas>
        </div>

        <div class="diagnostic-console" id="diagnosticConsole">
            <div class="diagnostic-console-header">
                <h3>Log</h3>
                <button id="copyLogBtn">Copy</button>
            </div>
            <div class="diagnostic-console-body" id="logBody"></div>
        </div>

        <div class="hotkeys">
            <h3>Keyboard Shortcuts</h3>
            <div class="hotkeys-grid">
                <div class="hotkey"><span class="hotkey-key">‚Üê / ‚Üí</span><span class="hotkey-desc">¬±1 frame</span></div>
                <div class="hotkey"><span class="hotkey-key">Ctrl+‚Üê / ‚Üí</span><span class="hotkey-desc">¬±30 frames</span></div>
                <div class="hotkey"><span class="hotkey-key">Home / End</span><span class="hotkey-desc">First/Last frame</span></div>
                <div class="hotkey"><span class="hotkey-key">Space</span><span class="hotkey-desc">Play/Pause</span></div>
                <div class="hotkey"><span class="hotkey-key">P</span><span class="hotkey-desc">Toggle poses</span></div>
                <div class="hotkey"><span class="hotkey-key">Mouse Wheel</span><span class="hotkey-desc">Zoom</span></div>
                <div class="hotkey"><span class="hotkey-key">Click + Drag</span><span class="hotkey-desc">Pan</span></div>
            </div>
        </div>
    </div>

    <!-- mp4box.js for demuxing -->
    <script src="https://cdn.jsdelivr.net/npm/mp4box@0.5.2/dist/mp4box.all.min.js"></script>
    <!-- Video player module -->
    <script src="./video-player.js"></script>
    <!-- Video backend abstraction for embedded videos -->
    <script src="./lru-cache.js"></script>
    <script src="./video-backend.js"></script>

    <script>
        // ============================================
        // Track Colors
        // ============================================
        const TRACK_COLORS = [
            '#667eea',  // blue
            '#4ade80',  // green
            '#fbbf24',  // yellow
            '#f472b6',  // pink
            '#06b6d4',  // cyan
            '#f97316',  // orange
            '#a855f7',  // purple
            '#ef4444',  // red
        ];

        function getTrackColor(trackIdx) {
            if (trackIdx < 0) return '#888888';
            return TRACK_COLORS[trackIdx % TRACK_COLORS.length];
        }

        // ============================================
        // Logging
        // ============================================
        const logBody = document.getElementById('logBody');
        const MAX_LOG_ENTRIES = 100;

        function log(msg, level = 'info') {
            const time = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">${time}</span><span class="log-msg ${level}">${msg}</span>`;
            logBody.appendChild(entry);
            while (logBody.children.length > MAX_LOG_ENTRIES) {
                logBody.removeChild(logBody.firstChild);
            }
            logBody.scrollTop = logBody.scrollHeight;
        }

        document.getElementById('copyLogBtn').addEventListener('click', () => {
            const lines = Array.from(logBody.querySelectorAll('.log-entry')).map(entry => {
                const time = entry.querySelector('.log-time').textContent;
                const msg = entry.querySelector('.log-msg').textContent;
                return `${time} ${msg}`;
            });
            navigator.clipboard.writeText(lines.join('\n')).then(() => {
                log('Log copied to clipboard', 'success');
            });
        });

        log('SLP Viewer initialized', 'info');

        // ============================================
        // State
        // ============================================
        let poseData = null;       // Loaded SLP data
        let frameIndexMap = null;  // Map "videoIdx:frameIdx" -> frame data
        let labeledFramesByVideo = null; // Map videoIdx -> Set of labeled frame indices
        let currentVideoIdx = 0;   // Currently selected video index
        let player = null;         // VideoPlayer instance
        let seekbarController = null; // SeekbarController instance

        // Fallback mode state (view poses without video)
        let fallbackMode = false;           // True when viewing without video
        let fallbackFrameIndex = 0;         // Current index in sortedLabeledFrames
        let sortedLabeledFrames = [];       // Sorted array of labeled frame indices for current video
        let fallbackVideoWidth = 640;       // Video dimensions from SLP metadata
        let fallbackVideoHeight = 480;

        // Embedded video state (pkg.slp files)
        let embeddedMode = false;           // True when viewing embedded video frames
        let frameWorker = null;             // Web Worker for HDF5 frame extraction
        let frameWorkerReady = false;       // Whether frame worker is initialized
        let embeddedVideos = new Map();     // videoIdx -> EmbeddedVideoInfo from frame worker
        let videoBackends = new Map();      // videoIdx -> HDF5VideoBackend instance
        let currentBackend = null;          // Current active HDF5VideoBackend
        let embeddedFrameIndex = 0;         // Current embedded frame index

        // URL state - track loaded URLs for sharing
        let currentSlpUrl = null;
        let currentVideoUrl = null;

        // Video resolution state - track resolved video files
        let videoSources = new Map();  // videoIndex -> { type: 'file'|'url', file?, url? }

        // Track pending SLP source for embedded video loading
        let pendingSlpSource = null;  // { type: 'url', url } or { type: 'file', file }

        // UI Elements
        let canvas = document.getElementById('canvas');
        const canvasContainer = document.getElementById('canvasContainer');
        const resizeHandle = document.getElementById('resizeHandle');
        const seekbar = document.getElementById('seekbar');
        const seekbarProgress = document.getElementById('seekbarProgress');
        const seekbarThumb = document.getElementById('seekbarThumb');
        const seekbarContainer = document.getElementById('seekbarContainer');
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');
        const errorMsg = document.getElementById('errorMsg');
        const playBtn = document.getElementById('playBtn');
        const loadVideoBtn = document.getElementById('loadVideoBtn');

        // Cache visualization elements
        const cacheVizContainer = document.getElementById('cacheVizContainer');
        const cacheVizCanvas = document.getElementById('cacheVizCanvas');
        const cacheVizCtx = cacheVizCanvas.getContext('2d');
        const cacheSizeInput = document.getElementById('cacheSize');
        const lookaheadInput = document.getElementById('lookahead');

        // ============================================
        // SLP Worker
        // ============================================
        let slpWorker = null;

        function initSlpWorker() {
            if (slpWorker) slpWorker.terminate();

            slpWorker = new Worker('./slp-worker.js');

            slpWorker.onmessage = (e) => {
                const { type, data } = e.data;

                if (type === 'log') {
                    log(data.message, data.level);
                } else if (type === 'loading') {
                    showLoading(data.message);
                } else if (type === 'result') {
                    hideLoading();
                    handleSlpLoaded(data);
                } else if (type === 'error') {
                    hideLoading();
                    showError(data.message);
                    log(`Error: ${data.message}`, 'error');
                }
            };

            slpWorker.onerror = (e) => {
                hideLoading();
                log(`Worker error: ${e.message}`, 'error');
            };
        }

        function handleSlpLoaded(data) {
            poseData = data;

            // Reset video selection
            currentVideoIdx = 0;

            // Build composite frame index map: "videoIdx:frameIdx" -> frame
            frameIndexMap = new Map();
            for (const frame of data.frames) {
                const key = `${frame.videoIdx ?? 0}:${frame.frameIdx}`;
                frameIndexMap.set(key, frame);
            }

            // Build per-video labeled frame sets for timeline marks
            labeledFramesByVideo = new Map();
            for (const frame of data.frames) {
                const vidIdx = frame.videoIdx ?? 0;
                if (!labeledFramesByVideo.has(vidIdx)) {
                    labeledFramesByVideo.set(vidIdx, new Set());
                }
                labeledFramesByVideo.get(vidIdx).add(frame.frameIdx);
            }

            log(`Loaded ${data.frames.length} frames of pose data`, 'success');

            // Update track legend
            updateTrackLegend();

            // Update video selector
            updateVideoSelector();

            // Update status banner
            updateStatusBanner();

            // Show video resolution panel for files with external videos
            showVideoResolutionPanel();

            // Check for embedded videos and load them
            const hasEmbeddedVideos = (data.videos || []).some(v => v.embedded);
            if (hasEmbeddedVideos && pendingSlpSource) {
                // Initialize frame worker if not ready
                if (!frameWorker) {
                    initFrameWorker();
                }

                // Load embedded videos from the source
                if (pendingSlpSource.type === 'url') {
                    loadEmbeddedVideosFromSlp(pendingSlpSource.url);
                } else if (pendingSlpSource.type === 'file') {
                    loadEmbeddedVideosFromFile(pendingSlpSource.file);
                }
            }

            // Enable video loading and fallback mode
            loadVideoBtn.disabled = false;
            document.getElementById('viewPosesBtn').disabled = false;

            // Update metrics
            document.getElementById('metricSlp').textContent = data.filename;
            document.getElementById('metricSkeleton').textContent = `${data.skeleton.nodes.length} nodes`;

            // If video path is available, show it
            if (data.videoPath) {
                log(`Video reference: ${data.videoPath}`, 'info');
            }
        }

        // ============================================
        // Frame Worker (for embedded videos)
        // ============================================
        function initFrameWorker() {
            if (frameWorker) {
                frameWorker.terminate();
            }

            frameWorker = new Worker('./frame-worker.js');
            frameWorkerReady = false;

            frameWorker.onmessage = (e) => {
                const { type, ...data } = e.data;

                if (type === 'ready') {
                    frameWorkerReady = true;
                    log('Frame worker ready', 'success');
                } else if (type === 'log') {
                    log(data.message, data.level);
                } else if (type === 'loaded') {
                    handleFrameWorkerLoaded(data);
                } else if (type === 'error') {
                    log(`Frame worker error: ${data.error}`, 'error');
                }
            };

            frameWorker.onerror = (e) => {
                log(`Frame worker error: ${e.message}`, 'error');
            };
        }

        function handleFrameWorkerLoaded(data) {
            const { videos, filename, streaming } = data;

            log(`Embedded videos: ${videos.length}`, 'info');
            if (streaming) {
                log('Streaming mode enabled (range requests)', 'success');
            }

            // Store embedded video info
            embeddedVideos.clear();
            videoBackends.clear();

            for (const video of videos) {
                embeddedVideos.set(video.idx, video);

                // Create backend for each embedded video
                const backend = new HDF5VideoBackend(frameWorker, video, {
                    cacheSize: parseInt(document.getElementById('cacheSize').value) || 60
                });
                videoBackends.set(video.idx, backend);
            }

            // Check if current video is embedded and auto-start
            if (embeddedVideos.has(currentVideoIdx)) {
                enterEmbeddedMode();
            }

            // Update video selector to show embedded status
            updateVideoSelector();
        }

        async function loadEmbeddedVideosFromSlp(slpUrl) {
            if (!frameWorkerReady) {
                // Wait for worker to be ready
                await new Promise((resolve) => {
                    const checkReady = () => {
                        if (frameWorkerReady) resolve();
                        else setTimeout(checkReady, 50);
                    };
                    checkReady();
                });
            }

            frameWorker.postMessage({ type: 'loadUrl', url: slpUrl });
        }

        async function loadEmbeddedVideosFromFile(file) {
            if (!frameWorkerReady) {
                await new Promise((resolve) => {
                    const checkReady = () => {
                        if (frameWorkerReady) resolve();
                        else setTimeout(checkReady, 50);
                    };
                    checkReady();
                });
            }

            frameWorker.postMessage({ type: 'loadFile', file: file });
        }

        // ============================================
        // Embedded Video Mode
        // ============================================
        function enterEmbeddedMode() {
            const backend = videoBackends.get(currentVideoIdx);
            if (!backend) {
                log(`No embedded video backend for video ${currentVideoIdx}`, 'error');
                return;
            }

            embeddedMode = true;
            currentBackend = backend;
            embeddedFrameIndex = 0;

            // Clean up video player if active
            if (player) {
                player.destroy();
                player = null;
            }
            if (seekbarController) {
                seekbarController.destroy();
                seekbarController = null;
            }
            exitFallbackMode();

            // Replace canvas
            const oldCanvas = document.getElementById('canvas');
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'canvas';
            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
            canvas = newCanvas;

            // Get video dimensions
            const videoInfo = embeddedVideos.get(currentVideoIdx);
            if (videoInfo) {
                fallbackVideoWidth = videoInfo.width || 640;
                fallbackVideoHeight = videoInfo.height || 480;
            }

            // Show UI
            canvasContainer.style.display = 'block';
            resizeHandle.style.display = 'flex';
            seekbarContainer.style.display = 'block';
            document.getElementById('infoRow').style.display = 'flex';
            document.getElementById('fallbackIndicator').style.display = 'flex';
            document.getElementById('fallbackIndicator').innerHTML = 'üì¶ Embedded video';
            cacheVizContainer.style.display = 'none';

            // Hide resolution panel
            document.getElementById('videoResolutionPanel').style.display = 'none';

            // Setup canvas
            setupEmbeddedCanvas();

            // Render first frame
            renderEmbeddedFrame();

            // Update metrics
            document.getElementById('metricVideo').textContent = `Embedded (${videoInfo?.key || 'video' + currentVideoIdx})`;
            document.getElementById('metricTotal').textContent = backend.frameCount;
            document.getElementById('metricFrame').textContent = 1;

            // Render timeline marks
            renderEmbeddedTimelineMarks();

            log(`Embedded mode: ${fallbackVideoWidth}x${fallbackVideoHeight}, ${backend.frameCount} frames`, 'success');
        }

        function exitEmbeddedMode() {
            embeddedMode = false;
            currentBackend = null;
            document.getElementById('fallbackIndicator').style.display = 'none';
        }

        function setupEmbeddedCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const containerRect = canvasContainer.getBoundingClientRect();

            const aspectRatio = fallbackVideoWidth / fallbackVideoHeight;
            let displayWidth = containerRect.width;
            let displayHeight = containerRect.height;

            if (displayWidth / displayHeight > aspectRatio) {
                displayWidth = displayHeight * aspectRatio;
            } else {
                displayHeight = displayWidth / aspectRatio;
            }

            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
        }

        async function renderEmbeddedFrame() {
            if (!embeddedMode || !currentBackend) return;

            const dpr = window.devicePixelRatio || 1;
            const ctx = canvas.getContext('2d');
            const displayWidth = canvas.width / dpr;
            const displayHeight = canvas.height / dpr;

            // Clear canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Get frame from backend
            const frameResult = await currentBackend.getFrame(embeddedFrameIndex);

            if (frameResult && frameResult.bitmap) {
                // Calculate scale and centering
                const scale = Math.min(displayWidth / fallbackVideoWidth, displayHeight / fallbackVideoHeight);
                const offsetX = (displayWidth - fallbackVideoWidth * scale) / 2;
                const offsetY = (displayHeight - fallbackVideoHeight * scale) / 2;

                // Draw frame
                ctx.save();
                ctx.scale(dpr, dpr);
                ctx.imageSmoothingEnabled = scale < 2;
                ctx.drawImage(
                    frameResult.bitmap,
                    offsetX, offsetY,
                    fallbackVideoWidth * scale,
                    fallbackVideoHeight * scale
                );
                ctx.restore();

                // Create info object for overlays
                const info = {
                    frameIndex: frameResult.displayFrame,
                    totalFrames: currentBackend.frameCount,
                    drawX: 0,
                    drawY: 0,
                    offsetX: offsetX,
                    offsetY: offsetY,
                    effectiveScale: scale,
                    dpr: dpr
                };

                // Render poses
                const key = `${currentVideoIdx}:${frameResult.displayFrame}`;
                const frameData = frameIndexMap.get(key);
                if (frameData && document.getElementById('showPoses').checked) {
                    renderEmbeddedPoses(ctx, frameData, info);
                }

                // Render frame index overlay
                if (document.getElementById('showFrameIndex').checked) {
                    renderEmbeddedFrameIndex(ctx, info);
                }
            }

            // Update seekbar
            updateEmbeddedSeekbar();

            // Update metrics
            document.getElementById('metricFrame').textContent = embeddedFrameIndex + 1;
            if (frameResult) {
                const key = `${currentVideoIdx}:${frameResult.displayFrame}`;
                const frameData = frameIndexMap.get(key);
                document.getElementById('metricInstances').textContent = frameData?.instances.length || 0;
            }

            // Update URL
            updateFrameInUrl();
        }

        function renderEmbeddedPoses(ctx, frameData, info) {
            const skeleton = poseData.skeleton;
            const showEdges = document.getElementById('showEdges').checked;
            const showNodes = document.getElementById('showNodes').checked;
            const nodeSize = parseInt(document.getElementById('nodeSize').value);
            const edgeWidth = parseInt(document.getElementById('edgeWidth').value);

            const { offsetX, offsetY, effectiveScale, dpr } = info;

            ctx.save();
            ctx.scale(dpr, dpr);

            for (const inst of frameData.instances) {
                const color = getTrackColor(inst.trackIdx);
                const points = inst.points;

                if (showEdges) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = edgeWidth;
                    ctx.lineCap = 'round';

                    for (const [srcIdx, dstIdx] of skeleton.edges) {
                        const srcPt = points[srcIdx];
                        const dstPt = points[dstIdx];
                        if (!srcPt || !dstPt) continue;

                        const x1 = offsetX + srcPt[0] * effectiveScale;
                        const y1 = offsetY + srcPt[1] * effectiveScale;
                        const x2 = offsetX + dstPt[0] * effectiveScale;
                        const y2 = offsetY + dstPt[1] * effectiveScale;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }

                if (showNodes) {
                    ctx.fillStyle = color;

                    for (const pt of points) {
                        if (!pt) continue;

                        const cx = offsetX + pt[0] * effectiveScale;
                        const cy = offsetY + pt[1] * effectiveScale;

                        ctx.beginPath();
                        ctx.arc(cx, cy, nodeSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            ctx.restore();
        }

        function renderEmbeddedFrameIndex(ctx, info) {
            const displayFrame = currentBackend ? currentBackend.getDisplayFrame(embeddedFrameIndex) : embeddedFrameIndex;
            const text = `Frame ${displayFrame} (${embeddedFrameIndex + 1}/${currentBackend?.frameCount || 0})`;
            const padding = 8;
            const fontSize = 14;

            ctx.save();
            ctx.scale(info.dpr, info.dpr);

            ctx.font = `bold ${fontSize}px monospace`;
            const metrics = ctx.measureText(text);
            const boxWidth = metrics.width + padding * 2;
            const boxHeight = fontSize + padding * 2;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(10, 10, boxWidth, boxHeight);

            ctx.fillStyle = '#ffffff';
            ctx.fillText(text, 10 + padding, 10 + padding + fontSize - 2);

            ctx.restore();
        }

        function updateEmbeddedSeekbar() {
            if (!currentBackend) return;
            const progress = currentBackend.frameCount > 1
                ? (embeddedFrameIndex / (currentBackend.frameCount - 1)) * 100
                : 0;
            seekbarProgress.style.width = progress + '%';
            seekbarThumb.style.left = progress + '%';
        }

        function renderEmbeddedTimelineMarks() {
            const container = document.getElementById('seekbarMarks');
            if (!container || !poseData || !currentBackend) {
                if (container) container.innerHTML = '';
                return;
            }

            const fragments = [];
            const totalFrames = currentBackend.frameCount;

            for (let i = 0; i < totalFrames; i++) {
                const displayFrame = currentBackend.getDisplayFrame(i);
                const key = `${currentVideoIdx}:${displayFrame}`;
                const frame = frameIndexMap.get(key);
                if (!frame) continue;

                const left = (i / (totalFrames - 1 || 1)) * 100;

                const hasUser = frame.instances.some(inst => inst.type === 'user');
                const hasPred = frame.instances.some(inst => inst.type === 'predicted');
                const markClass = hasUser && hasPred ? 'mark-both' :
                                  hasUser ? 'mark-user' : 'mark-predicted';

                fragments.push(`<div class="seekbar-mark ${markClass}" style="left:${left}%"></div>`);
            }

            container.innerHTML = fragments.join('');
        }

        function embeddedSeek(index) {
            if (!embeddedMode || !currentBackend) return;
            embeddedFrameIndex = Math.max(0, Math.min(currentBackend.frameCount - 1, index));
            renderEmbeddedFrame();
        }

        function updateTrackLegend() {
            const trackList = document.getElementById('trackList');
            trackList.innerHTML = '';

            if (!poseData || poseData.tracks.length === 0) {
                // Show untracked indicator
                const item = document.createElement('div');
                item.className = 'track-item';
                item.innerHTML = `
                    <span class="track-color" style="background: #888;"></span>
                    <span class="track-name">Untracked instances</span>
                `;
                trackList.appendChild(item);
            } else {
                for (let i = 0; i < poseData.tracks.length; i++) {
                    const item = document.createElement('div');
                    item.className = 'track-item';
                    item.innerHTML = `
                        <span class="track-color" style="background: ${getTrackColor(i)};"></span>
                        <span class="track-name">${poseData.tracks[i]}</span>
                    `;
                    trackList.appendChild(item);
                }
            }
        }

        function updateVideoSelector() {
            const container = document.getElementById('videoSelectorContainer');
            const select = document.getElementById('videoSelect');
            const videos = poseData?.videos || [];

            if (videos.length <= 1) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'flex';
            select.innerHTML = videos.map((v, i) => {
                // For embedded videos, show "Video N" since filename is just "."
                let name;
                if (v.embedded || v.filename === '.') {
                    name = `Video ${i}`;
                } else {
                    name = v.filename?.split(/[/\\]/).pop() || `Video ${i}`;
                }

                // Status indicator
                let status;
                if (v.embedded) {
                    status = 'üì¶';
                } else if (videoSources.has(i)) {
                    status = '‚úÖ';
                } else {
                    status = '‚ùå';
                }

                const labelCount = labeledFramesByVideo.get(i)?.size || 0;
                return `<option value="${i}">${status} ${name} (${labelCount} labeled)</option>`;
            }).join('');

            select.value = currentVideoIdx;

            // Update info
            const currentVideo = videos[currentVideoIdx];
            const info = document.getElementById('videoInfo');
            if (currentVideo?.shape) {
                const [frames, h, w] = currentVideo.shape;
                info.textContent = `${w}√ó${h}, ${frames} frames`;
            } else {
                info.textContent = '';
            }
        }

        function updateStatusBanner() {
            const banner = document.getElementById('statusBanner');
            const typeEl = document.getElementById('statusType');
            const detailsEl = document.getElementById('statusDetails');

            if (!poseData) {
                banner.style.display = 'none';
                return;
            }

            banner.style.display = 'flex';

            // Detect type
            const videos = poseData.videos || [];
            const hasEmbedded = videos.some(v => v.embedded);
            const frames = poseData.frames;
            const hasUser = frames.some(f => f.instances.some(i => i.type === 'user'));
            const hasPred = frames.some(f => f.instances.some(i => i.type === 'predicted'));

            let type, icon;
            if (hasEmbedded) {
                type = 'Package';
                icon = 'üì¶';
            } else if (!hasUser && hasPred) {
                type = 'Predictions';
                icon = 'üìä';
            } else {
                type = 'Labeling Project';
                icon = 'üìÅ';
            }

            typeEl.textContent = `${icon} ${type}`;

            // Build details
            const parts = [];
            parts.push(`${videos.length} video${videos.length !== 1 ? 's' : ''}`);
            parts.push(`${frames.length} labeled frames`);
            if (poseData.tracks.length > 0) {
                parts.push(`${poseData.tracks.length} tracks`);
            }

            detailsEl.textContent = parts.join(' ‚Ä¢ ');
        }

        // ============================================
        // Video Resolution Panel
        // ============================================

        function showVideoResolutionPanel() {
            const panel = document.getElementById('videoResolutionPanel');
            const videos = poseData?.videos || [];

            // Don't show if no videos
            if (videos.length === 0) {
                panel.style.display = 'none';
                return;
            }

            // Check for external videos that need resolution
            const externalVideos = videos.filter(v => !v.embedded);
            if (externalVideos.length === 0) {
                // All videos are embedded - hide panel
                panel.style.display = 'none';
                log('All videos embedded, no resolution needed', 'success');
                return;
            }

            // Show panel
            panel.style.display = 'block';
            document.getElementById('videoCount').textContent = videos.length;

            // Reset video sources
            videoSources = new Map();

            // Update the video list UI
            updateVideoResolutionList();
        }

        function updateVideoResolutionList() {
            const videoList = document.getElementById('videoList');
            const videos = poseData?.videos || [];

            videoList.innerHTML = videos.map((v, i) => {
                const isResolved = videoSources.has(i);
                const isEmbedded = v.embedded;
                const resolvedClass = isResolved ? 'resolved' : '';

                // Display name
                let name;
                if (isEmbedded) {
                    name = `Video ${i} (embedded)`;
                } else {
                    name = v.filename?.split(/[/\\]/).pop() || `Video ${i}`;
                }

                // Status icon
                let status;
                if (isEmbedded) {
                    status = 'üì¶';
                } else if (isResolved) {
                    status = '‚úÖ';
                } else {
                    status = '‚ùå';
                }

                // Buttons
                let buttons = '';
                if (isEmbedded) {
                    buttons = `<button class="play-embedded-btn" data-index="${i}" style="background:#60a5fa;">‚ñ∂ Play</button>`;
                } else if (!isResolved) {
                    buttons = `<button class="select-video-btn" data-index="${i}">Select</button>`;
                } else {
                    buttons = `<button class="play-video-btn" data-index="${i}" style="background:#4ade80;">‚ñ∂ Play</button>`;
                }

                return `<div class="video-item ${resolvedClass}" data-index="${i}">
                    <span class="video-status">${status}</span>
                    <span class="video-filename" title="${v.filename || 'Unknown'}">${name}</span>
                    ${buttons}
                </div>`;
            }).join('');

            // Add click handlers for select buttons
            videoList.querySelectorAll('.select-video-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const index = parseInt(e.target.dataset.index);
                    await selectVideoFile(index);
                });
            });

            // Add click handlers for play buttons
            videoList.querySelectorAll('.play-video-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const source = videoSources.get(index);
                    if (source && source.type === 'file') {
                        currentVideoIdx = index;
                        document.getElementById('videoResolutionPanel').style.display = 'none';
                        await initVideoPlayer(source.file, source.file.name);
                    }
                });
            });

            // Add click handlers for embedded play buttons
            videoList.querySelectorAll('.play-embedded-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    if (videoBackends.has(index)) {
                        currentVideoIdx = index;
                        document.getElementById('videoResolutionPanel').style.display = 'none';
                        enterEmbeddedMode();
                    }
                });
            });

            // Update video selector dropdown to reflect resolution status
            updateVideoSelector();

            // Check if all external videos are resolved
            checkAllVideosResolved();
        }

        async function selectVideoFile(videoIndex) {
            const videos = poseData?.videos || [];
            const video = videos[videoIndex];
            if (!video) return;

            const expectedFilename = video.filename?.split(/[/\\]/).pop() || '';

            // Use File System Access API if available
            if ('showOpenFilePicker' in window) {
                try {
                    const [handle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'Video files',
                            accept: {
                                'video/mp4': ['.mp4', '.m4v'],
                                'video/quicktime': ['.mov'],
                                'video/webm': ['.webm'],
                                'video/avi': ['.avi']
                            }
                        }],
                        multiple: false
                    });
                    const file = await handle.getFile();
                    videoSources.set(videoIndex, { type: 'file', file });
                    log(`Resolved video ${videoIndex}: ${file.name}`, 'success');
                    updateVideoResolutionList();
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        log(`File picker error: ${err.message}`, 'warn');
                    }
                }
            } else {
                // Fallback: create hidden file input
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'video/mp4,video/quicktime,video/webm,.mp4,.mov,.m4v,.webm,.avi';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        videoSources.set(videoIndex, { type: 'file', file });
                        log(`Resolved video ${videoIndex}: ${file.name}`, 'success');
                        updateVideoResolutionList();
                    }
                };
                input.click();
            }
        }

        async function resolveVideosFromDirectory(dirHandle) {
            const videos = poseData?.videos || [];
            let resolved = 0;

            for (let i = 0; i < videos.length; i++) {
                if (videos[i].embedded || videoSources.has(i)) continue;

                const filename = videos[i].filename?.split(/[/\\]/).pop();
                if (!filename) continue;

                try {
                    // Try exact match first
                    const fileHandle = await dirHandle.getFileHandle(filename);
                    const file = await fileHandle.getFile();
                    videoSources.set(i, { type: 'file', file });
                    resolved++;
                    log(`Resolved video ${i}: ${filename}`, 'success');
                } catch (e) {
                    // File not found in directory
                    log(`Could not find ${filename} in directory`, 'warn');
                }
            }

            if (resolved > 0) {
                log(`Resolved ${resolved} video(s) from directory`, 'success');
            }

            updateVideoResolutionList();
        }

        function checkAllVideosResolved() {
            const videos = poseData?.videos || [];
            const externalVideos = videos.filter(v => !v.embedded);
            const resolvedCount = Array.from(videoSources.keys()).filter(i => {
                const v = videos[i];
                return v && !v.embedded;
            }).length;

            if (resolvedCount === externalVideos.length && externalVideos.length > 0) {
                log('All videos resolved!', 'success');
                // Hide panel and auto-load first video
                document.getElementById('videoResolutionPanel').style.display = 'none';

                // Find first resolved video and load it
                const firstResolved = Array.from(videoSources.entries())[0];
                if (firstResolved) {
                    const [idx, source] = firstResolved;
                    currentVideoIdx = idx;
                    if (source.type === 'file') {
                        initVideoPlayer(source.file, source.file.name);
                    }
                }
            }
        }

        // Directory picker button handler
        document.getElementById('loadDirectoryBtn')?.addEventListener('click', async () => {
            if (!('showDirectoryPicker' in window)) {
                log('Directory picker not supported in this browser', 'warn');
                showError('Directory picker not supported. Please select videos individually.');
                return;
            }

            try {
                const dirHandle = await window.showDirectoryPicker();
                log('Scanning directory for video files...', 'info');
                await resolveVideosFromDirectory(dirHandle);
            } catch (e) {
                if (e.name !== 'AbortError') {
                    log(`Directory picker error: ${e.message}`, 'error');
                }
            }
        });

        // Skip button handler - enter fallback mode
        document.getElementById('skipAllVideosBtn')?.addEventListener('click', () => {
            if (!poseData) return;
            document.getElementById('videoResolutionPanel').style.display = 'none';
            enterFallbackMode();
        });

        function renderTimelineMarks() {
            const container = document.getElementById('seekbarMarks');
            if (!container || !poseData) {
                if (container) container.innerHTML = '';
                return;
            }

            const totalFrames = player?.frames || 0;
            if (totalFrames === 0) {
                container.innerHTML = '';
                return;
            }

            const fragments = [];
            const labeledSet = labeledFramesByVideo.get(currentVideoIdx) || new Set();

            for (const frameIdx of labeledSet) {
                const key = `${currentVideoIdx}:${frameIdx}`;
                const frame = frameIndexMap.get(key);
                if (!frame) continue;

                const left = (frameIdx / totalFrames) * 100;

                // Determine mark type
                const hasUser = frame.instances.some(i => i.type === 'user');
                const hasPred = frame.instances.some(i => i.type === 'predicted');
                const markClass = hasUser && hasPred ? 'mark-both' :
                                  hasUser ? 'mark-user' : 'mark-predicted';

                fragments.push(`<div class="seekbar-mark ${markClass}" style="left:${left}%"></div>`);
            }

            container.innerHTML = fragments.join('');
        }

        // Video selector change handler
        document.getElementById('videoSelect').addEventListener('change', async (e) => {
            const newVideoIdx = parseInt(e.target.value);

            // Update video info display
            const videos = poseData?.videos || [];
            const newVideo = videos[newVideoIdx];
            const info = document.getElementById('videoInfo');
            if (newVideo?.shape) {
                const [frames, h, w] = newVideo.shape;
                info.textContent = `${w}√ó${h}, ${frames} frames`;
            } else {
                info.textContent = '';
            }

            // Determine target mode based on new video
            const source = videoSources.get(newVideoIdx);
            const isNewVideoEmbedded = videoBackends.has(newVideoIdx);

            // Exit current mode if needed
            if (fallbackMode && (source || isNewVideoEmbedded)) {
                exitFallbackMode();
            }
            if (embeddedMode && !isNewVideoEmbedded) {
                exitEmbeddedMode();
            }

            currentVideoIdx = newVideoIdx;

            // Enter appropriate mode for new video
            if (isNewVideoEmbedded) {
                // Switch to embedded video
                if (embeddedMode) {
                    // Already in embedded mode - just switch backends
                    currentBackend = videoBackends.get(newVideoIdx);
                    embeddedFrameIndex = 0;

                    // Update video dimensions
                    const videoInfo = embeddedVideos.get(newVideoIdx);
                    if (videoInfo) {
                        fallbackVideoWidth = videoInfo.width || 640;
                        fallbackVideoHeight = videoInfo.height || 480;
                    }

                    // Re-setup and render
                    setupEmbeddedCanvas();
                    renderEmbeddedFrame();
                    renderEmbeddedTimelineMarks();

                    // Update metrics
                    document.getElementById('metricVideo').textContent = `Embedded (${videoInfo?.key || 'video' + newVideoIdx})`;
                    document.getElementById('metricTotal').textContent = currentBackend.frameCount;
                    document.getElementById('metricFrame').textContent = 1;
                } else {
                    // Enter embedded mode
                    enterEmbeddedMode();
                }
            } else if (source && source.type === 'file') {
                // Load resolved external video
                await initVideoPlayer(source.file, source.file.name);
            } else {
                // No source available - enter fallback mode
                enterFallbackMode();
            }

            const videoName = newVideo?.embedded ? `Video ${newVideoIdx}` :
                              newVideo?.filename?.split(/[/\\]/).pop() || 'Unknown';
            log(`Switched to video ${newVideoIdx}: ${videoName}`, 'info');
        });

        // ============================================
        // Fallback Mode (View Poses Only)
        // ============================================

        function enterFallbackMode() {
            if (!poseData) return;

            fallbackMode = true;
            fallbackFrameIndex = 0;

            // Get video dimensions from SLP metadata
            const videos = poseData.videos || [];
            const currentVideo = videos[currentVideoIdx];
            if (currentVideo?.shape) {
                // shape is [frames, height, width, channels]
                fallbackVideoHeight = currentVideo.shape[1] || 480;
                fallbackVideoWidth = currentVideo.shape[2] || 640;
            } else {
                // Default dimensions
                fallbackVideoWidth = 640;
                fallbackVideoHeight = 480;
            }

            // Build sorted list of labeled frames for current video
            updateSortedLabeledFrames();

            // Clean up any existing video player
            if (player) {
                player.destroy();
                player = null;
            }
            if (seekbarController) {
                seekbarController.destroy();
                seekbarController = null;
            }

            // Replace canvas with a fresh one (the old one may have been transferred to OffscreenCanvas)
            const oldCanvas = document.getElementById('canvas');
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'canvas';
            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
            // Update the canvas reference
            canvas = newCanvas;

            // Show UI elements
            canvasContainer.style.display = 'block';
            resizeHandle.style.display = 'flex';
            seekbarContainer.style.display = 'block';
            document.getElementById('infoRow').style.display = 'flex';
            document.getElementById('fallbackIndicator').style.display = 'flex';
            cacheVizContainer.style.display = 'none'; // No cache in fallback mode

            // Setup canvas
            setupFallbackCanvas();

            // Initial render
            renderFallbackFrame();

            // Update metrics
            document.getElementById('metricVideo').textContent = 'None (poses only)';
            document.getElementById('metricTotal').textContent = sortedLabeledFrames.length;
            document.getElementById('metricFrame').textContent = 1;

            // Render timeline marks
            renderFallbackTimelineMarks();

            log(`Fallback mode: ${fallbackVideoWidth}x${fallbackVideoHeight}, ${sortedLabeledFrames.length} labeled frames`, 'success');
        }

        function exitFallbackMode() {
            fallbackMode = false;
            document.getElementById('fallbackIndicator').style.display = 'none';
        }

        function updateSortedLabeledFrames() {
            const labeledSet = labeledFramesByVideo.get(currentVideoIdx) || new Set();
            sortedLabeledFrames = Array.from(labeledSet).sort((a, b) => a - b);
        }

        function setupFallbackCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const containerRect = canvasContainer.getBoundingClientRect();

            // Calculate aspect ratio to fit canvas
            const aspectRatio = fallbackVideoWidth / fallbackVideoHeight;
            let displayWidth = containerRect.width;
            let displayHeight = containerRect.height;

            if (displayWidth / displayHeight > aspectRatio) {
                displayWidth = displayHeight * aspectRatio;
            } else {
                displayHeight = displayWidth / aspectRatio;
            }

            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
        }

        function renderFallbackFrame() {
            if (!fallbackMode || !poseData) return;

            const dpr = window.devicePixelRatio || 1;
            const ctx = canvas.getContext('2d');
            const displayWidth = canvas.width / dpr;
            const displayHeight = canvas.height / dpr;

            // Clear and fill with black
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Get current labeled frame index
            const frameIdx = sortedLabeledFrames[fallbackFrameIndex] ?? 0;
            const key = `${currentVideoIdx}:${frameIdx}`;
            const frameData = frameIndexMap.get(key);

            // Calculate scale and centering
            const scale = Math.min(displayWidth / fallbackVideoWidth, displayHeight / fallbackVideoHeight);
            const offsetX = (displayWidth - fallbackVideoWidth * scale) / 2;
            const offsetY = (displayHeight - fallbackVideoHeight * scale) / 2;

            // Create info object similar to VideoPlayer's renderOverlay
            const info = {
                frameIndex: frameIdx,
                totalFrames: sortedLabeledFrames.length,
                drawX: 0,
                drawY: 0,
                offsetX: offsetX,
                offsetY: offsetY,
                effectiveScale: scale,
                dpr: dpr
            };

            // Render poses
            if (frameData && document.getElementById('showPoses').checked) {
                renderFallbackPoses(ctx, frameData, info);
            }

            // Render frame index overlay
            if (document.getElementById('showFrameIndex').checked) {
                renderFallbackFrameIndex(ctx, info);
            }

            // Update seekbar
            updateFallbackSeekbar();

            // Update metrics
            document.getElementById('metricFrame').textContent = fallbackFrameIndex + 1;
            updateFallbackInstanceCount(frameData);

            // Update URL with current frame
            updateFrameInUrl();
        }

        function renderFallbackPoses(ctx, frameData, info) {
            const skeleton = poseData.skeleton;
            const showEdges = document.getElementById('showEdges').checked;
            const showNodes = document.getElementById('showNodes').checked;
            const nodeSize = parseInt(document.getElementById('nodeSize').value);
            const edgeWidth = parseInt(document.getElementById('edgeWidth').value);

            const { offsetX, offsetY, effectiveScale, dpr } = info;

            ctx.save();
            ctx.scale(dpr, dpr);

            for (const inst of frameData.instances) {
                const color = getTrackColor(inst.trackIdx);
                const points = inst.points;

                // Draw edges
                if (showEdges) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = edgeWidth;
                    ctx.lineCap = 'round';

                    for (const [srcIdx, dstIdx] of skeleton.edges) {
                        const srcPt = points[srcIdx];
                        const dstPt = points[dstIdx];
                        if (!srcPt || !dstPt) continue;

                        const x1 = offsetX + srcPt[0] * effectiveScale;
                        const y1 = offsetY + srcPt[1] * effectiveScale;
                        const x2 = offsetX + dstPt[0] * effectiveScale;
                        const y2 = offsetY + dstPt[1] * effectiveScale;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }

                // Draw nodes
                if (showNodes) {
                    ctx.fillStyle = color;

                    for (const pt of points) {
                        if (!pt) continue;

                        const cx = offsetX + pt[0] * effectiveScale;
                        const cy = offsetY + pt[1] * effectiveScale;

                        ctx.beginPath();
                        ctx.arc(cx, cy, nodeSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            ctx.restore();
        }

        function renderFallbackFrameIndex(ctx, info) {
            const frameIdx = sortedLabeledFrames[fallbackFrameIndex] ?? 0;
            const text = `Frame ${frameIdx} (${fallbackFrameIndex + 1}/${sortedLabeledFrames.length})`;
            const padding = 8;
            const fontSize = 14;

            ctx.save();
            ctx.scale(info.dpr, info.dpr);

            ctx.font = `bold ${fontSize}px monospace`;
            const metrics = ctx.measureText(text);
            const boxWidth = metrics.width + padding * 2;
            const boxHeight = fontSize + padding * 2;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(10, 10, boxWidth, boxHeight);

            ctx.fillStyle = '#ffffff';
            ctx.fillText(text, 10 + padding, 10 + padding + fontSize - 2);

            ctx.restore();
        }

        function updateFallbackSeekbar() {
            const progress = sortedLabeledFrames.length > 1
                ? (fallbackFrameIndex / (sortedLabeledFrames.length - 1)) * 100
                : 0;
            seekbarProgress.style.width = progress + '%';
            seekbarThumb.style.left = progress + '%';
        }

        function updateFallbackInstanceCount(frameData) {
            if (frameData) {
                document.getElementById('metricInstances').textContent = frameData.instances.length;
            } else {
                document.getElementById('metricInstances').textContent = '0';
            }
        }

        function renderFallbackTimelineMarks() {
            const container = document.getElementById('seekbarMarks');
            if (!container || !poseData || sortedLabeledFrames.length === 0) {
                if (container) container.innerHTML = '';
                return;
            }

            // In fallback mode, all frames are labeled, so show marks evenly distributed
            const fragments = [];
            for (let i = 0; i < sortedLabeledFrames.length; i++) {
                const frameIdx = sortedLabeledFrames[i];
                const key = `${currentVideoIdx}:${frameIdx}`;
                const frame = frameIndexMap.get(key);
                if (!frame) continue;

                const left = (i / (sortedLabeledFrames.length - 1 || 1)) * 100;

                const hasUser = frame.instances.some(inst => inst.type === 'user');
                const hasPred = frame.instances.some(inst => inst.type === 'predicted');
                const markClass = hasUser && hasPred ? 'mark-both' :
                                  hasUser ? 'mark-user' : 'mark-predicted';

                fragments.push(`<div class="seekbar-mark ${markClass}" style="left:${left}%"></div>`);
            }

            container.innerHTML = fragments.join('');
        }

        function fallbackSeek(index) {
            if (!fallbackMode) return;
            fallbackFrameIndex = Math.max(0, Math.min(sortedLabeledFrames.length - 1, index));
            renderFallbackFrame();
        }

        function fallbackSeekByFrameIdx(frameIdx) {
            if (!fallbackMode) return;
            const idx = sortedLabeledFrames.indexOf(frameIdx);
            if (idx >= 0) {
                fallbackFrameIndex = idx;
                renderFallbackFrame();
            }
        }

        // Fallback seekbar interaction
        let fallbackSeeking = false;
        let embeddedSeeking = false;

        function handleFallbackSeekbarClick(e) {
            if (!fallbackMode || sortedLabeledFrames.length === 0) return;

            const rect = seekbar.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const pct = Math.max(0, Math.min(1, x / rect.width));
            const idx = Math.round(pct * (sortedLabeledFrames.length - 1));
            fallbackSeek(idx);
        }

        function handleEmbeddedSeekbarClick(e) {
            if (!embeddedMode || !currentBackend) return;

            const rect = seekbar.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const pct = Math.max(0, Math.min(1, x / rect.width));
            const idx = Math.round(pct * (currentBackend.frameCount - 1));
            embeddedSeek(idx);
        }

        seekbar.addEventListener('mousedown', (e) => {
            if (fallbackMode) {
                fallbackSeeking = true;
                handleFallbackSeekbarClick(e);
            } else if (embeddedMode) {
                embeddedSeeking = true;
                handleEmbeddedSeekbarClick(e);
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (fallbackSeeking && fallbackMode) {
                handleFallbackSeekbarClick(e);
            } else if (embeddedSeeking && embeddedMode) {
                handleEmbeddedSeekbarClick(e);
            }
        });

        document.addEventListener('mouseup', () => {
            fallbackSeeking = false;
            embeddedSeeking = false;
        });

        // ============================================
        // UI Helpers
        // ============================================
        function showLoading(text) {
            loadingText.textContent = text;
            loading.classList.add('visible');
        }

        function hideLoading() {
            loading.classList.remove('visible');
        }

        function showError(msg) {
            errorMsg.textContent = msg;
            errorMsg.style.display = 'block';
        }

        function hideError() {
            errorMsg.style.display = 'none';
        }

        // ============================================
        // URL State Management
        // ============================================

        // Debounce timer for frame URL updates
        let frameUrlUpdateTimer = null;

        /**
         * Update browser URL with current SLP and video URLs
         * @param {boolean} includeFrame - Whether to include frame in hash
         */
        function updateUrlState(includeFrame = false) {
            const params = new URLSearchParams();
            if (currentSlpUrl) params.set('slp', currentSlpUrl);
            if (currentVideoUrl) params.set('video', currentVideoUrl);

            let newUrl = params.toString()
                ? `${window.location.pathname}?${params.toString()}`
                : window.location.pathname;

            // Add frame to hash if requested and we have a valid frame
            if (includeFrame) {
                let frameIdx = 0;
                if (fallbackMode && sortedLabeledFrames.length > 0) {
                    frameIdx = sortedLabeledFrames[fallbackFrameIndex] ?? 0;
                } else if (player) {
                    frameIdx = player.frame;
                }
                if (frameIdx > 0) {
                    newUrl += `#frame=${frameIdx}`;
                }
            }

            // Use replaceState to avoid polluting history
            window.history.replaceState({}, '', newUrl);
        }

        /**
         * Debounced update of frame in URL hash
         * Called on every frame change, but only updates URL after 500ms of no changes
         */
        function updateFrameInUrl() {
            if (!currentSlpUrl) return; // Only update URL if we have a shareable SLP URL

            clearTimeout(frameUrlUpdateTimer);
            frameUrlUpdateTimer = setTimeout(() => {
                updateUrlState(true);
            }, 500);
        }

        /**
         * Read URL params and return SLP/video URLs if present
         */
        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            const hashParams = new URLSearchParams(window.location.hash.slice(1));
            return {
                slp: params.get('slp'),
                video: params.get('video'),
                frame: parseInt(hashParams.get('frame')) || 0
            };
        }

        /**
         * Load SLP from URL (returns promise that resolves when loaded)
         */
        function loadSlpFromUrl(url) {
            return new Promise((resolve, reject) => {
                pendingSlpSource = { type: 'url', url };
                initSlpWorker();
                showLoading('Loading SLP from URL...');

                const originalOnMessage = slpWorker.onmessage;
                slpWorker.onmessage = (e) => {
                    originalOnMessage(e);
                    if (e.data.type === 'result') {
                        currentSlpUrl = url;
                        resolve();
                    } else if (e.data.type === 'error') {
                        reject(new Error(e.data.data.message));
                    }
                };

                slpWorker.postMessage({ type: 'loadUrl', url });
            });
        }

        /**
         * Load both SLP and video from URLs
         * @param {string} slpUrl - URL to SLP file
         * @param {string} videoUrl - URL to video file (optional)
         * @param {number} frame - Frame index to seek to after loading (optional)
         */
        async function loadFromUrls(slpUrl, videoUrl, frame = 0) {
            hideError();
            log(`Loading from URLs...`, 'info');

            try {
                // Load SLP first
                await loadSlpFromUrl(slpUrl);

                // Then load video
                if (videoUrl) {
                    const videoName = videoUrl.split('/').pop().split('?')[0] || 'video.mp4';
                    await initVideoPlayer(videoUrl, videoName);
                    currentVideoUrl = videoUrl;
                }

                // Seek to frame if specified
                if (frame > 0) {
                    if (player) {
                        player.seek(frame);
                        log(`Seeked to frame ${frame}`, 'info');
                    } else if (fallbackMode && sortedLabeledFrames.length > 0) {
                        // In fallback mode, find the closest labeled frame
                        const idx = sortedLabeledFrames.findIndex(f => f >= frame);
                        if (idx >= 0) {
                            fallbackSeek(idx);
                            log(`Seeked to labeled frame ${sortedLabeledFrames[idx]} (index ${idx})`, 'info');
                        }
                    }
                }

                // Update URL state for sharing (include frame if specified)
                updateUrlState(frame > 0);
                log('Loaded from URL - shareable link updated', 'success');

            } catch (err) {
                hideLoading();
                showError('Error loading from URL: ' + err.message);
                log(`Error: ${err.message}`, 'error');
            }
        }

        /**
         * Check URL params on page load and auto-load if present
         */
        async function checkUrlParamsOnLoad() {
            const { slp, video, frame } = getUrlParams();

            if (slp) {
                log(`Found URL params - slp: ${slp}`, 'info');
                if (video) {
                    log(`Found URL params - video: ${video}`, 'info');
                }
                if (frame > 0) {
                    log(`Found URL params - frame: ${frame}`, 'info');
                }
                await loadFromUrls(slp, video, frame);
            }
        }

        // ============================================
        // Load SLP
        // ============================================
        async function loadSlpFile(file) {
            hideError();
            log(`Loading SLP: ${file.name}`, 'info');

            // Clear URL state since local files can't be shared
            currentSlpUrl = null;
            currentVideoUrl = null;
            updateUrlState();

            // Track the pending source for embedded video loading
            pendingSlpSource = { type: 'file', file };

            initSlpWorker();
            showLoading('Initializing h5wasm...');
            slpWorker.postMessage({ type: 'loadLocal', file });
        }

        document.getElementById('loadSlpBtn').addEventListener('click', async () => {
            // Use File System Access API if available (better UX, no file copy)
            if ('showOpenFilePicker' in window) {
                try {
                    const [handle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'SLEAP files',
                            accept: { 'application/x-hdf5': ['.slp'] }
                        }],
                        multiple: false
                    });
                    const file = await handle.getFile();
                    await loadSlpFile(file);
                } catch (err) {
                    // User cancelled or API error
                    if (err.name !== 'AbortError') {
                        log(`File picker error: ${err.message}`, 'warn');
                        document.getElementById('slpInput').click();
                    }
                }
            } else {
                document.getElementById('slpInput').click();
            }
        });

        // Fallback file input handler
        document.getElementById('slpInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            await loadSlpFile(file);
        });

        // ============================================
        // Load Video
        // ============================================
        loadVideoBtn.addEventListener('click', async () => {
            // Use File System Access API if available (better UX, no file copy)
            if ('showOpenFilePicker' in window) {
                try {
                    const [handle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'Video files',
                            accept: {
                                'video/mp4': ['.mp4', '.m4v'],
                                'video/quicktime': ['.mov'],
                                'video/webm': ['.webm']
                            }
                        }],
                        multiple: false
                    });
                    const file = await handle.getFile();
                    // Clear video URL since local files can't be shared
                    currentVideoUrl = null;
                    updateUrlState();
                    // Store in videoSources and hide resolution panel
                    videoSources.set(currentVideoIdx, { type: 'file', file });
                    document.getElementById('videoResolutionPanel').style.display = 'none';
                    await initVideoPlayer(file, file.name);
                } catch (err) {
                    // User cancelled or API error
                    if (err.name !== 'AbortError') {
                        log(`File picker error: ${err.message}`, 'warn');
                        document.getElementById('videoInput').click();
                    }
                }
            } else {
                document.getElementById('videoInput').click();
            }
        });

        async function initVideoPlayer(source, name) {
            hideError();
            log(`Loading video: ${name}`, 'info');
            showLoading('Loading video...');

            // Exit fallback mode when loading a video
            exitFallbackMode();

            // Replace canvas with a fresh one (required because:
            // 1. Fallback mode uses getContext('2d') which prevents transferControlToOffscreen
            // 2. Previous VideoPlayer may have transferred control to OffscreenCanvas)
            const oldCanvas = document.getElementById('canvas');
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'canvas';
            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
            canvas = newCanvas;

            try {
                // Clean up previous player
                if (player) player.destroy();
                if (seekbarController) seekbarController.destroy();

                // Create new player with overlay callback
                player = new VideoPlayer({
                    container: canvasContainer,
                    canvas: canvas,
                    cacheSize: parseInt(document.getElementById('cacheSize').value),
                    lookahead: parseInt(document.getElementById('lookahead').value),
                    showTimingOverlay: document.getElementById('showTiming').checked,
                    onFrameChange: (frameIndex, totalFrames) => {
                        document.getElementById('metricFrame').textContent = frameIndex + 1;
                        seekbarController?.update(frameIndex, totalFrames);
                        updateInstanceCount();
                        renderCacheVisualization();
                        updateFrameInUrl();
                    },
                    renderOverlay: renderAllOverlays,
                    onLog: log
                });

                // Create seekbar controller
                seekbarController = new SeekbarController({
                    seekbar: seekbar,
                    progress: seekbarProgress,
                    thumb: seekbarThumb,
                    onSeek: (frame) => player.seek(frame),
                    getTotal: () => player.frames
                });

                // Show container before loading so canvas has dimensions
                canvasContainer.style.display = 'block';
                resizeHandle.style.display = 'flex';
                seekbarContainer.style.display = 'block';
                document.getElementById('infoRow').style.display = 'flex';

                const info = await player.load(source);

                log(`Video: ${info.width}x${info.height}, ${player.frames} frames, ${player.fps.toFixed(1)} fps`, 'success');

                document.getElementById('metricVideo').textContent = name;
                document.getElementById('metricTotal').textContent = player.frames;
                document.getElementById('metricFrame').textContent = 1;

                // Show and render cache visualization
                cacheVizContainer.style.display = 'block';
                renderCacheVisualization();

                // Render timeline marks for labeled frames
                renderTimelineMarks();

                // Hide resolution panel since video loaded successfully
                document.getElementById('videoResolutionPanel').style.display = 'none';

                hideLoading();

            } catch (err) {
                hideLoading();
                showError('Error loading video: ' + err.message);
                log(`Error: ${err.message}`, 'error');
            }
        }

        // Fallback file input handler
        document.getElementById('videoInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            // Clear video URL since local files can't be shared
            currentVideoUrl = null;
            updateUrlState();
            // Store in videoSources and hide resolution panel
            videoSources.set(currentVideoIdx, { type: 'file', file });
            document.getElementById('videoResolutionPanel').style.display = 'none';
            await initVideoPlayer(file, file.name);
        });

        // ============================================
        // Load Demo
        // ============================================
        document.getElementById('loadDemoBtn').addEventListener('click', async () => {
            const baseUrl = window.location.origin + '/slp-viewer/';
            const slpUrl = baseUrl + 'mice.tracked.slp';
            const videoUrl = baseUrl + 'mice.mp4';

            log('Loading demo data...', 'info');
            await loadFromUrls(slpUrl, videoUrl);
        });

        // ============================================
        // View Poses Only (Fallback Mode)
        // ============================================
        document.getElementById('viewPosesBtn').addEventListener('click', () => {
            if (!poseData) return;
            exitFallbackMode(); // Clean up if already in fallback mode
            enterFallbackMode();
        });

        // ============================================
        // Overlay Rendering (called by VideoPlayer)
        // ============================================

        /**
         * Render all overlays - called by VideoPlayer after each frame
         * @param {CanvasRenderingContext2D} ctx
         * @param {Object} info - { bitmap, frameIndex, totalFrames, offsetX, offsetY, drawX, drawY, effectiveScale, dpr }
         */
        function renderAllOverlays(ctx, info) {
            renderPoseOverlay(ctx, info);
            renderFrameIndexOverlay(ctx, info);
        }

        function renderPoseOverlay(ctx, info) {
            if (!poseData) return;
            if (!document.getElementById('showPoses').checked) return;

            // Use composite key for multi-video support
            const key = `${currentVideoIdx}:${info.frameIndex}`;
            const frameData = frameIndexMap.get(key);
            if (!frameData) return;

            const skeleton = poseData.skeleton;
            const showEdges = document.getElementById('showEdges').checked;
            const showNodes = document.getElementById('showNodes').checked;
            const nodeSize = parseInt(document.getElementById('nodeSize').value);
            const edgeWidth = parseInt(document.getElementById('edgeWidth').value);

            const { drawX, drawY, offsetX, offsetY, effectiveScale, dpr } = info;

            ctx.save();
            ctx.scale(dpr, dpr);

            for (const inst of frameData.instances) {
                const color = getTrackColor(inst.trackIdx);
                const points = inst.points;

                // Draw edges first (behind nodes)
                if (showEdges) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = edgeWidth;
                    ctx.lineCap = 'round';

                    for (const [srcIdx, dstIdx] of skeleton.edges) {
                        const srcPt = points[srcIdx];
                        const dstPt = points[dstIdx];
                        if (!srcPt || !dstPt) continue;

                        const x1 = drawX + offsetX + srcPt[0] * effectiveScale;
                        const y1 = drawY + offsetY + srcPt[1] * effectiveScale;
                        const x2 = drawX + offsetX + dstPt[0] * effectiveScale;
                        const y2 = drawY + offsetY + dstPt[1] * effectiveScale;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }

                // Draw nodes
                if (showNodes) {
                    ctx.fillStyle = color;

                    for (const pt of points) {
                        if (!pt) continue;

                        const cx = drawX + offsetX + pt[0] * effectiveScale;
                        const cy = drawY + offsetY + pt[1] * effectiveScale;

                        ctx.beginPath();
                        ctx.arc(cx, cy, nodeSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            ctx.restore();
        }

        function renderFrameIndexOverlay(ctx, info) {
            if (!document.getElementById('showFrameIndex').checked) return;

            const text = `${info.frameIndex + 1} / ${info.totalFrames}`;
            const padding = 8;
            const fontSize = 14;

            ctx.save();
            ctx.scale(info.dpr, info.dpr);

            ctx.font = `bold ${fontSize}px monospace`;
            const metrics = ctx.measureText(text);
            const boxWidth = metrics.width + padding * 2;
            const boxHeight = fontSize + padding * 2;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(10, 10, boxWidth, boxHeight);

            ctx.fillStyle = '#ffffff';
            ctx.fillText(text, 10 + padding, 10 + padding + fontSize - 2);

            ctx.restore();
        }

        function updateInstanceCount() {
            if (!player || !frameIndexMap) return;
            const key = `${currentVideoIdx}:${player.frame}`;
            const frameData = frameIndexMap.get(key);
            if (frameData) {
                document.getElementById('metricInstances').textContent = frameData.instances.length;
            } else {
                document.getElementById('metricInstances').textContent = '0';
            }
        }

        // ============================================
        // Cache Visualization
        // ============================================
        function renderCacheVisualization() {
            if (!player || player.frames === 0) return;

            // In OffscreenCanvas mode, we don't have detailed cache info
            // Just show a simplified visualization based on controller's cache.size
            const isOffscreenMode = player.useOffscreenCanvas && player.offscreenController;
            const decoder = player.decoder;
            const totalFrames = player.frames;

            const rect = cacheVizCanvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const width = rect.width * dpr;
            const height = rect.height * dpr;

            if (cacheVizCanvas.width !== width || cacheVizCanvas.height !== height) {
                cacheVizCanvas.width = width;
                cacheVizCanvas.height = height;
            }

            cacheVizCtx.fillStyle = '#333';
            cacheVizCtx.fillRect(0, 0, width, height);

            if (isOffscreenMode) {
                // Simplified visualization for OffscreenCanvas mode
                // Show a bar indicating approximate cache coverage around current frame
                const controller = player.offscreenController;
                const cacheSize = controller.cache?.size || controller._cacheSize || 0;
                const currentFrame = player.frame;

                // Estimate cache range (assumes cache is centered around current frame)
                const halfCache = Math.floor(cacheSize / 2);
                const cacheStart = Math.max(0, currentFrame - halfCache);
                const cacheEnd = Math.min(totalFrames - 1, currentFrame + halfCache);

                // Draw estimated cached region
                const startX = (cacheStart / totalFrames) * width;
                const endX = (cacheEnd / totalFrames) * width;
                cacheVizCtx.fillStyle = '#4ade80';
                cacheVizCtx.fillRect(startX, 0, endX - startX, height);

                // Draw current frame indicator
                const currentX = (currentFrame / totalFrames) * width;
                cacheVizCtx.fillStyle = '#667eea';
                cacheVizCtx.fillRect(currentX - 1, 0, 3, height);
            } else if (decoder) {
                // Full visualization for traditional mode
                const framesPerPixel = Math.max(1, totalFrames / width);
                const pixelsPerFrame = width / totalFrames;

                const cachedFrames = new Set(decoder.cache.keys());
                const keyframes = new Set(decoder.keyframeIndices);

                if (framesPerPixel <= 1) {
                    const frameWidth = Math.max(1, pixelsPerFrame);

                    // Draw keyframes first
                    cacheVizCtx.fillStyle = '#fbbf24';
                    for (const kf of keyframes) {
                        const x = (kf / totalFrames) * width;
                        cacheVizCtx.fillRect(x, 0, Math.max(1, frameWidth), height);
                    }

                    // Draw cached frames
                    cacheVizCtx.fillStyle = '#4ade80';
                    for (const frame of cachedFrames) {
                        const x = (frame / totalFrames) * width;
                        cacheVizCtx.fillRect(x, 0, Math.max(1, frameWidth), height);
                    }
                } else {
                    for (let px = 0; px < width; px++) {
                        const frameStart = Math.floor(px * framesPerPixel);
                        const frameEnd = Math.floor((px + 1) * framesPerPixel);

                        let hasCached = false;
                        let hasKeyframe = false;

                        for (let f = frameStart; f < frameEnd; f++) {
                            if (cachedFrames.has(f)) hasCached = true;
                            if (keyframes.has(f)) hasKeyframe = true;
                        }

                        if (hasCached) {
                            cacheVizCtx.fillStyle = '#4ade80';
                            cacheVizCtx.fillRect(px, 0, 1, height);
                        } else if (hasKeyframe) {
                            cacheVizCtx.fillStyle = '#fbbf24';
                            cacheVizCtx.fillRect(px, 0, 1, height);
                        }
                    }
                }

                // Draw current frame indicator
                const currentX = (player.frame / totalFrames) * width;
                cacheVizCtx.fillStyle = '#667eea';
                cacheVizCtx.fillRect(currentX - 1, 0, 3, height);
            }
        }

        // ============================================
        // Playback Controls
        // ============================================
        playBtn.addEventListener('click', () => {
            if (!player) return;
            player.toggle();
            playBtn.textContent = player.playing ? '‚è∏' : '‚ñ∂';
        });

        // ============================================
        // Controls
        // ============================================
        document.getElementById('firstFrameBtn').addEventListener('click', () => {
            if (fallbackMode) {
                fallbackSeek(0);
            } else {
                player?.seek(0);
            }
        });
        document.getElementById('prevFrameBtn').addEventListener('click', () => {
            if (fallbackMode) {
                fallbackSeek(fallbackFrameIndex - 1);
            } else {
                player?.seek(player.frame - 1);
            }
        });
        document.getElementById('nextFrameBtn').addEventListener('click', () => {
            if (fallbackMode) {
                fallbackSeek(fallbackFrameIndex + 1);
            } else {
                player?.seek(player.frame + 1);
            }
        });
        document.getElementById('lastFrameBtn').addEventListener('click', () => {
            if (fallbackMode) {
                fallbackSeek(sortedLabeledFrames.length - 1);
            } else {
                player?.seek(player.frames - 1);
            }
        });

        document.getElementById('zoomInBtn').addEventListener('click', () => {
            if (fallbackMode) return; // No zoom in fallback mode (for now)
            if (!player) return;
            player.setZoom(player.zoom * 1.25);
        });
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            if (fallbackMode) return; // No zoom in fallback mode (for now)
            if (!player) return;
            player.setZoom(player.zoom * 0.8);
        });
        document.getElementById('resetZoomBtn').addEventListener('click', () => {
            if (fallbackMode) {
                setupFallbackCanvas();
                renderFallbackFrame();
            } else {
                player?.resetView();
            }
        });

        // Overlay toggles - re-render when changed
        document.getElementById('showPoses').addEventListener('change', () => {
            if (fallbackMode) renderFallbackFrame();
            else player?.render();
        });
        document.getElementById('showEdges').addEventListener('change', () => {
            if (fallbackMode) renderFallbackFrame();
            else player?.render();
        });
        document.getElementById('showNodes').addEventListener('change', () => {
            if (fallbackMode) renderFallbackFrame();
            else player?.render();
        });
        document.getElementById('showFrameIndex').addEventListener('change', () => {
            if (fallbackMode) renderFallbackFrame();
            else player?.render();
        });
        document.getElementById('showTiming').addEventListener('change', (e) => {
            if (player) {
                player.showTimingOverlay = e.target.checked;
                player.render();
            }
        });

        // Sliders
        document.getElementById('nodeSize').addEventListener('input', (e) => {
            document.getElementById('nodeSizeValue').textContent = e.target.value;
            if (fallbackMode) renderFallbackFrame();
            else player?.render();
        });
        document.getElementById('edgeWidth').addEventListener('input', (e) => {
            document.getElementById('edgeWidthValue').textContent = e.target.value;
            if (fallbackMode) renderFallbackFrame();
            else player?.render();
        });

        // Cache settings (apply immediately)
        cacheSizeInput.addEventListener('change', () => {
            const value = parseInt(cacheSizeInput.value);
            if (value >= 10 && value <= 500 && player?.decoder) {
                player.decoder.cacheSize = value;
                log(`Cache size updated to ${value}`, 'info');
                renderCacheVisualization();
            }
        });
        lookaheadInput.addEventListener('change', () => {
            const value = parseInt(lookaheadInput.value);
            if (value >= 1 && value <= 200 && player?.decoder) {
                player.decoder.lookahead = value;
                log(`Lookahead updated to ${value}`, 'info');
            }
        });

        // Re-render cache viz on window resize
        window.addEventListener('resize', () => {
            if (player?.decoder) {
                renderCacheVisualization();
            }
        });

        // Keyboard
        document.addEventListener('keydown', (e) => {
            // Handle fallback mode navigation
            if (fallbackMode) {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    fallbackSeek(fallbackFrameIndex - (e.ctrlKey ? 10 : 1));
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    fallbackSeek(fallbackFrameIndex + (e.ctrlKey ? 10 : 1));
                } else if (e.key === 'Home') {
                    e.preventDefault();
                    fallbackSeek(0);
                } else if (e.key === 'End') {
                    e.preventDefault();
                    fallbackSeek(sortedLabeledFrames.length - 1);
                } else if (e.key === 'p' || e.key === 'P') {
                    const cb = document.getElementById('showPoses');
                    cb.checked = !cb.checked;
                    renderFallbackFrame();
                }
                return;
            }

            // Handle embedded video mode navigation
            if (embeddedMode && currentBackend) {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    embeddedSeek(embeddedFrameIndex - (e.ctrlKey ? 10 : 1));
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    embeddedSeek(embeddedFrameIndex + (e.ctrlKey ? 10 : 1));
                } else if (e.key === 'Home') {
                    e.preventDefault();
                    embeddedSeek(0);
                } else if (e.key === 'End') {
                    e.preventDefault();
                    embeddedSeek(currentBackend.frameCount - 1);
                } else if (e.key === 'p' || e.key === 'P') {
                    const cb = document.getElementById('showPoses');
                    cb.checked = !cb.checked;
                    renderEmbeddedFrame();
                }
                return;
            }

            // Handle video player navigation
            if (!player) return;

            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                player.seek(player.frame - (e.ctrlKey ? 30 : 1));
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                player.seek(player.frame + (e.ctrlKey ? 30 : 1));
            } else if (e.key === ' ') {
                e.preventDefault();
                player.toggle();
                playBtn.textContent = player.playing ? '‚è∏' : '‚ñ∂';
            } else if (e.key === 'Home') {
                e.preventDefault();
                player.seek(0);
            } else if (e.key === 'End') {
                e.preventDefault();
                player.seek(player.frames - 1);
            } else if (e.key === 'p' || e.key === 'P') {
                const cb = document.getElementById('showPoses');
                cb.checked = !cb.checked;
                player.render();
            }
        });

        // Resize handle
        let isResizing = false;
        let resizeStartY = 0;
        let resizeStartHeight = 0;

        resizeHandle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isResizing = true;
            resizeStartY = e.clientY;
            resizeStartHeight = canvasContainer.clientHeight;
            document.body.style.cursor = 'ns-resize';
        });

        document.addEventListener('mousemove', (e) => {
            if (isResizing) {
                const delta = e.clientY - resizeStartY;
                const newHeight = Math.max(150, Math.min(window.innerHeight * 0.9, resizeStartHeight + delta));
                canvasContainer.style.height = newHeight + 'px';
                if (fallbackMode) {
                    setupFallbackCanvas();
                    renderFallbackFrame();
                } else {
                    player?.render();
                }
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
            }
        });

        // ============================================
        // Auto-load from URL params on page load
        // ============================================
        checkUrlParamsOnLoad();
    </script>
</body>
</html>
