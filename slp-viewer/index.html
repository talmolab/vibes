<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLP Viewer - SLEAP Pose Visualization</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        h1 { margin-bottom: 0.5rem; color: #fff; }
        .description { color: #aaa; margin-top: 0; }
        .container { max-width: 1200px; margin: 0 auto; }
        .controls {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 6px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            margin: 3px;
        }
        button:hover { background: #5568d3; }
        button:disabled { background: #444; cursor: not-allowed; }
        .canvas-container {
            position: relative;
            background: #000;
            border-radius: 8px 8px 0 0;
            overflow: hidden;
            margin: 20px 0 0 0;
            cursor: grab;
            height: 70vh;
            min-height: 150px;
            max-height: 90vh;
        }
        .canvas-container:active { cursor: grabbing; }
        .resize-handle {
            height: 8px;
            background: #2a2a2a;
            border-radius: 0 0 8px 8px;
            cursor: ns-resize;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }
        .resize-handle:hover { background: #3a3a3a; }
        .resize-handle::after {
            content: '';
            width: 40px;
            height: 3px;
            background: #555;
            border-radius: 2px;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: crisp-edges;
        }
        .seekbar-container {
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .seekbar {
            width: 100%;
            height: 8px;
            background: #444;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            margin: 10px 0;
        }
        .seekbar-progress {
            height: 100%;
            background: #667eea;
            border-radius: 4px;
            width: 0%;
            pointer-events: none;
        }
        .seekbar-thumb {
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            left: 0%;
            pointer-events: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .playback-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 6px;
            margin-top: 10px;
        }
        .playback-controls button {
            width: 26px;
            height: 26px;
            padding: 0;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .control-separator {
            width: 1px;
            height: 18px;
            background: #444;
            margin: 0 6px;
        }
        .info-row {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .metrics {
            flex: 2;
            min-width: 300px;
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #aaa;
        }
        .metrics h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            font-family: system-ui, -apple-system, sans-serif;
            color: #ccc;
        }
        .metrics-row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .metric { margin: 5px 0; }
        .metric-label { color: #667eea; font-weight: bold; }
        .overlay-controls {
            flex: 1;
            min-width: 200px;
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
        }
        .overlay-controls h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #ccc;
        }
        .overlay-controls label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 14px;
            color: #ccc;
            margin: 5px 0;
        }
        .overlay-controls input[type="checkbox"] { cursor: pointer; }
        .overlay-controls input[type="range"] {
            flex: 1;
            max-width: 100px;
        }
        .track-legend {
            flex: 1;
            min-width: 150px;
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
        }
        .track-legend h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #ccc;
        }
        .track-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            font-size: 13px;
        }
        .track-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        .track-name { color: #aaa; }
        .decoder-settings {
            flex: 1;
            min-width: 180px;
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
        }
        .decoder-settings h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #ccc;
        }
        .decoder-hint {
            font-size: 11px;
            color: #666;
            margin-top: 8px;
            font-style: italic;
        }
        .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
        }
        .slider-row label {
            font-size: 13px;
            color: #aaa;
            min-width: 80px;
        }
        .slider-row input[type="range"] { flex: 1; }
        .slider-row .slider-value {
            font-size: 12px;
            color: #667eea;
            min-width: 35px;
            text-align: right;
        }
        .diagnostic-console {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        .diagnostic-console-header {
            background: #2a2a2a;
            padding: 8px 15px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .diagnostic-console-header h3 { margin: 0; color: #fff; font-size: 12px; }
        .diagnostic-console-header button {
            background: #444;
            padding: 4px 10px;
            font-size: 11px;
            margin: 0;
        }
        .diagnostic-console-body {
            height: 120px;
            overflow-y: auto;
            padding: 10px 15px;
        }
        .log-entry { margin: 2px 0; display: flex; gap: 10px; }
        .log-time { color: #666; flex-shrink: 0; }
        .log-msg { color: #aaa; }
        .log-msg.info { color: #667eea; }
        .log-msg.success { color: #4ade80; }
        .log-msg.warn { color: #fbbf24; }
        .log-msg.error { color: #ff6b6b; }
        .error-msg {
            background: #4a2020;
            border: 1px solid #ff6b6b;
            color: #ff6b6b;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
            display: none;
        }
        .loading {
            display: none;
            align-items: center;
            gap: 10px;
            color: #667eea;
            margin: 20px 0;
        }
        .loading.visible { display: flex; }
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #333;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .hotkeys {
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 14px;
        }
        .hotkeys h3 { margin-top: 0; color: #fff; }
        .hotkeys-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px 20px;
        }
        .hotkey { display: flex; gap: 10px; }
        .hotkey-key {
            color: #667eea;
            font-family: 'Courier New', monospace;
            min-width: 100px;
        }
        .hotkey-desc { color: #aaa; }
        @media (max-width: 600px) {
            body { padding: 10px; }
            .controls { padding: 8px 10px; }
            button { padding: 6px 12px; font-size: 13px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SLP Viewer</h1>
        <p class="description">View SLEAP pose predictions overlaid on video. Load an SLP file and its corresponding video.</p>

        <div class="controls">
            <input type="file" id="slpInput" accept=".slp" style="display: none;">
            <input type="file" id="videoInput" accept="video/mp4,video/quicktime,video/webm,.mp4,.mov,.m4v,.webm" style="display: none;">
            <button id="loadDemoBtn">Load Demo</button>
            <button id="loadSlpBtn">Load SLP File</button>
            <button id="loadVideoBtn" disabled>Load Video</button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <span id="loadingText">Loading...</span>
        </div>

        <div class="error-msg" id="errorMsg"></div>

        <div class="canvas-container" id="canvasContainer" style="display: none;">
            <canvas id="canvas"></canvas>
        </div>
        <div class="resize-handle" id="resizeHandle" style="display: none;"></div>

        <div class="seekbar-container" id="seekbarContainer" style="display: none;">
            <div class="seekbar" id="seekbar">
                <div class="seekbar-progress" id="seekbarProgress"></div>
                <div class="seekbar-thumb" id="seekbarThumb"></div>
            </div>
            <div class="playback-controls">
                <button id="firstFrameBtn" title="First frame (Home)">|❮</button>
                <button id="prevFrameBtn" title="Previous frame (←)">❮</button>
                <button id="playBtn">▶</button>
                <button id="nextFrameBtn" title="Next frame (→)">❯</button>
                <button id="lastFrameBtn" title="Last frame (End)">❯|</button>
                <span class="control-separator"></span>
                <button id="zoomOutBtn" title="Zoom out">−</button>
                <button id="zoomInBtn" title="Zoom in">+</button>
                <button id="resetZoomBtn" title="Reset view">⟲</button>
            </div>
        </div>

        <div class="info-row" id="infoRow" style="display: none;">
            <div class="metrics" id="metrics">
                <h3>Info</h3>
                <div class="metrics-row">
                    <div class="metric"><span class="metric-label">Video:</span> <span id="metricVideo">-</span></div>
                    <div class="metric"><span class="metric-label">SLP:</span> <span id="metricSlp">-</span></div>
                </div>
                <div class="metrics-row">
                    <div class="metric"><span class="metric-label">Frame:</span> <span id="metricFrame">-</span>/<span id="metricTotal">-</span></div>
                    <div class="metric"><span class="metric-label">Instances:</span> <span id="metricInstances">-</span></div>
                    <div class="metric"><span class="metric-label">Skeleton:</span> <span id="metricSkeleton">-</span></div>
                </div>
            </div>

            <div class="overlay-controls" id="overlayControls">
                <h3>Overlays</h3>
                <label><input type="checkbox" id="showPoses" checked> Show Poses</label>
                <label><input type="checkbox" id="showEdges" checked> Show Edges</label>
                <label><input type="checkbox" id="showNodes" checked> Show Nodes</label>
                <label><input type="checkbox" id="showFrameIndex" checked> Frame Index</label>
                <div class="slider-row">
                    <label>Node Size:</label>
                    <input type="range" id="nodeSize" min="2" max="12" value="5">
                    <span class="slider-value" id="nodeSizeValue">5</span>
                </div>
                <div class="slider-row">
                    <label>Edge Width:</label>
                    <input type="range" id="edgeWidth" min="1" max="6" value="2">
                    <span class="slider-value" id="edgeWidthValue">2</span>
                </div>
            </div>

            <div class="track-legend" id="trackLegend">
                <h3>Tracks</h3>
                <div id="trackList">
                    <div class="track-item">
                        <span class="track-color" style="background: #888;"></span>
                        <span class="track-name">No tracks loaded</span>
                    </div>
                </div>
            </div>

            <div class="decoder-settings" id="decoderSettings">
                <h3>Decoder</h3>
                <div class="slider-row">
                    <label>Cache Size:</label>
                    <input type="range" id="cacheSize" min="30" max="300" value="120" step="10">
                    <span class="slider-value" id="cacheSizeValue">120</span>
                </div>
                <div class="slider-row">
                    <label>Lookahead:</label>
                    <input type="range" id="lookahead" min="10" max="120" value="60" step="10">
                    <span class="slider-value" id="lookaheadValue">60</span>
                </div>
                <div class="decoder-hint">Changes apply on next video load</div>
            </div>
        </div>

        <div class="diagnostic-console" id="diagnosticConsole">
            <div class="diagnostic-console-header">
                <h3>Log</h3>
                <button id="copyLogBtn">Copy</button>
            </div>
            <div class="diagnostic-console-body" id="logBody"></div>
        </div>

        <div class="hotkeys">
            <h3>Keyboard Shortcuts</h3>
            <div class="hotkeys-grid">
                <div class="hotkey"><span class="hotkey-key">← / →</span><span class="hotkey-desc">±1 frame</span></div>
                <div class="hotkey"><span class="hotkey-key">Ctrl+← / →</span><span class="hotkey-desc">±30 frames</span></div>
                <div class="hotkey"><span class="hotkey-key">Home / End</span><span class="hotkey-desc">First/Last frame</span></div>
                <div class="hotkey"><span class="hotkey-key">Space</span><span class="hotkey-desc">Play/Pause</span></div>
                <div class="hotkey"><span class="hotkey-key">P</span><span class="hotkey-desc">Toggle poses</span></div>
                <div class="hotkey"><span class="hotkey-key">Mouse Wheel</span><span class="hotkey-desc">Zoom</span></div>
                <div class="hotkey"><span class="hotkey-key">Click + Drag</span><span class="hotkey-desc">Pan</span></div>
            </div>
        </div>
    </div>

    <!-- mp4box.js for demuxing -->
    <script src="https://cdn.jsdelivr.net/npm/mp4box@0.5.2/dist/mp4box.all.min.js"></script>
    <!-- Video player module -->
    <script src="./video-player.js"></script>

    <script>
        // ============================================
        // Track Colors
        // ============================================
        const TRACK_COLORS = [
            '#667eea',  // blue
            '#4ade80',  // green
            '#fbbf24',  // yellow
            '#f472b6',  // pink
            '#06b6d4',  // cyan
            '#f97316',  // orange
            '#a855f7',  // purple
            '#ef4444',  // red
        ];

        function getTrackColor(trackIdx) {
            if (trackIdx < 0) return '#888888';
            return TRACK_COLORS[trackIdx % TRACK_COLORS.length];
        }

        // ============================================
        // Logging
        // ============================================
        const logBody = document.getElementById('logBody');
        const MAX_LOG_ENTRIES = 100;

        function log(msg, level = 'info') {
            const time = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">${time}</span><span class="log-msg ${level}">${msg}</span>`;
            logBody.appendChild(entry);
            while (logBody.children.length > MAX_LOG_ENTRIES) {
                logBody.removeChild(logBody.firstChild);
            }
            logBody.scrollTop = logBody.scrollHeight;
        }

        document.getElementById('copyLogBtn').addEventListener('click', () => {
            const lines = Array.from(logBody.querySelectorAll('.log-entry')).map(entry => {
                const time = entry.querySelector('.log-time').textContent;
                const msg = entry.querySelector('.log-msg').textContent;
                return `${time} ${msg}`;
            });
            navigator.clipboard.writeText(lines.join('\n')).then(() => {
                log('Log copied to clipboard', 'success');
            });
        });

        log('SLP Viewer initialized', 'info');

        // ============================================
        // State
        // ============================================
        let poseData = null;       // Loaded SLP data
        let frameIndexMap = null;  // Map frameIdx -> frame data
        let player = null;         // VideoPlayer instance
        let seekbarController = null; // SeekbarController instance

        // UI Elements
        const canvas = document.getElementById('canvas');
        const canvasContainer = document.getElementById('canvasContainer');
        const resizeHandle = document.getElementById('resizeHandle');
        const seekbar = document.getElementById('seekbar');
        const seekbarProgress = document.getElementById('seekbarProgress');
        const seekbarThumb = document.getElementById('seekbarThumb');
        const seekbarContainer = document.getElementById('seekbarContainer');
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');
        const errorMsg = document.getElementById('errorMsg');
        const playBtn = document.getElementById('playBtn');
        const loadVideoBtn = document.getElementById('loadVideoBtn');

        // ============================================
        // SLP Worker
        // ============================================
        let slpWorker = null;

        function initSlpWorker() {
            if (slpWorker) slpWorker.terminate();

            slpWorker = new Worker('./slp-worker.js');

            slpWorker.onmessage = (e) => {
                const { type, data } = e.data;

                if (type === 'log') {
                    log(data.message, data.level);
                } else if (type === 'loading') {
                    showLoading(data.message);
                } else if (type === 'result') {
                    hideLoading();
                    handleSlpLoaded(data);
                } else if (type === 'error') {
                    hideLoading();
                    showError(data.message);
                    log(`Error: ${data.message}`, 'error');
                }
            };

            slpWorker.onerror = (e) => {
                hideLoading();
                log(`Worker error: ${e.message}`, 'error');
            };
        }

        function handleSlpLoaded(data) {
            poseData = data;

            // Build frame index map for fast lookup
            frameIndexMap = new Map();
            for (const frame of data.frames) {
                frameIndexMap.set(frame.frameIdx, frame);
            }

            log(`Loaded ${data.frames.length} frames of pose data`, 'success');

            // Update track legend
            updateTrackLegend();

            // Enable video loading
            loadVideoBtn.disabled = false;

            // Update metrics
            document.getElementById('metricSlp').textContent = data.filename;
            document.getElementById('metricSkeleton').textContent = `${data.skeleton.nodes.length} nodes`;

            // If video path is available, show it
            if (data.videoPath) {
                log(`Video reference: ${data.videoPath}`, 'info');
            }
        }

        function updateTrackLegend() {
            const trackList = document.getElementById('trackList');
            trackList.innerHTML = '';

            if (!poseData || poseData.tracks.length === 0) {
                // Show untracked indicator
                const item = document.createElement('div');
                item.className = 'track-item';
                item.innerHTML = `
                    <span class="track-color" style="background: #888;"></span>
                    <span class="track-name">Untracked instances</span>
                `;
                trackList.appendChild(item);
            } else {
                for (let i = 0; i < poseData.tracks.length; i++) {
                    const item = document.createElement('div');
                    item.className = 'track-item';
                    item.innerHTML = `
                        <span class="track-color" style="background: ${getTrackColor(i)};"></span>
                        <span class="track-name">${poseData.tracks[i]}</span>
                    `;
                    trackList.appendChild(item);
                }
            }
        }

        // ============================================
        // UI Helpers
        // ============================================
        function showLoading(text) {
            loadingText.textContent = text;
            loading.classList.add('visible');
        }

        function hideLoading() {
            loading.classList.remove('visible');
        }

        function showError(msg) {
            errorMsg.textContent = msg;
            errorMsg.style.display = 'block';
        }

        function hideError() {
            errorMsg.style.display = 'none';
        }

        // ============================================
        // Load SLP
        // ============================================
        async function loadSlpFile(file) {
            hideError();
            log(`Loading SLP: ${file.name}`, 'info');

            initSlpWorker();
            showLoading('Initializing h5wasm...');
            slpWorker.postMessage({ type: 'loadLocal', file });
        }

        document.getElementById('loadSlpBtn').addEventListener('click', async () => {
            // Use File System Access API if available (better UX, no file copy)
            if ('showOpenFilePicker' in window) {
                try {
                    const [handle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'SLEAP files',
                            accept: { 'application/x-hdf5': ['.slp'] }
                        }],
                        multiple: false
                    });
                    const file = await handle.getFile();
                    await loadSlpFile(file);
                } catch (err) {
                    // User cancelled or API error
                    if (err.name !== 'AbortError') {
                        log(`File picker error: ${err.message}`, 'warn');
                        document.getElementById('slpInput').click();
                    }
                }
            } else {
                document.getElementById('slpInput').click();
            }
        });

        // Fallback file input handler
        document.getElementById('slpInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            await loadSlpFile(file);
        });

        // ============================================
        // Load Video
        // ============================================
        loadVideoBtn.addEventListener('click', async () => {
            // Use File System Access API if available (better UX, no file copy)
            if ('showOpenFilePicker' in window) {
                try {
                    const [handle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'Video files',
                            accept: {
                                'video/mp4': ['.mp4', '.m4v'],
                                'video/quicktime': ['.mov'],
                                'video/webm': ['.webm']
                            }
                        }],
                        multiple: false
                    });
                    const file = await handle.getFile();
                    await initVideoPlayer(file, file.name);
                } catch (err) {
                    // User cancelled or API error
                    if (err.name !== 'AbortError') {
                        log(`File picker error: ${err.message}`, 'warn');
                        document.getElementById('videoInput').click();
                    }
                }
            } else {
                document.getElementById('videoInput').click();
            }
        });

        async function initVideoPlayer(source, name) {
            hideError();
            log(`Loading video: ${name}`, 'info');
            showLoading('Loading video...');

            try {
                // Clean up previous player
                if (player) player.destroy();
                if (seekbarController) seekbarController.destroy();

                // Create new player with overlay callback
                player = new VideoPlayer({
                    container: canvasContainer,
                    canvas: canvas,
                    cacheSize: parseInt(document.getElementById('cacheSize').value),
                    lookahead: parseInt(document.getElementById('lookahead').value),
                    onFrameChange: (frameIndex, totalFrames) => {
                        document.getElementById('metricFrame').textContent = frameIndex + 1;
                        seekbarController?.update(frameIndex, totalFrames);
                        updateInstanceCount();
                    },
                    renderOverlay: renderAllOverlays,
                    onLog: log
                });

                // Create seekbar controller
                seekbarController = new SeekbarController({
                    seekbar: seekbar,
                    progress: seekbarProgress,
                    thumb: seekbarThumb,
                    onSeek: (frame) => player.seek(frame),
                    getTotal: () => player.frames
                });

                // Show container before loading so canvas has dimensions
                canvasContainer.style.display = 'block';
                resizeHandle.style.display = 'flex';
                seekbarContainer.style.display = 'block';
                document.getElementById('infoRow').style.display = 'flex';

                const info = await player.load(source);

                log(`Video: ${info.width}x${info.height}, ${player.frames} frames, ${player.fps.toFixed(1)} fps`, 'success');

                document.getElementById('metricVideo').textContent = name;
                document.getElementById('metricTotal').textContent = player.frames;
                document.getElementById('metricFrame').textContent = 1;

                hideLoading();

            } catch (err) {
                hideLoading();
                showError('Error loading video: ' + err.message);
                log(`Error: ${err.message}`, 'error');
            }
        }

        // Fallback file input handler
        document.getElementById('videoInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            await initVideoPlayer(file, file.name);
        });

        // ============================================
        // Load Demo
        // ============================================
        document.getElementById('loadDemoBtn').addEventListener('click', async () => {
            const baseUrl = window.location.origin + '/slp-viewer/';
            const slpUrl = baseUrl + 'mice.tracked.slp';
            const videoUrl = baseUrl + 'mice.mp4';

            hideError();
            log('Loading demo data...', 'info');

            // Load SLP first
            initSlpWorker();
            showLoading('Loading demo SLP...');

            // Wait for SLP to load
            const slpLoaded = new Promise((resolve, reject) => {
                const originalOnMessage = slpWorker.onmessage;
                slpWorker.onmessage = (e) => {
                    originalOnMessage(e);
                    if (e.data.type === 'result') resolve();
                    else if (e.data.type === 'error') reject(new Error(e.data.data.message));
                };
            });

            slpWorker.postMessage({ type: 'loadUrl', url: slpUrl });

            try {
                await slpLoaded;
                // Now load video
                await initVideoPlayer(videoUrl, 'mice.mp4');
            } catch (err) {
                hideLoading();
                showError('Error loading demo: ' + err.message);
                log(`Error: ${err.message}`, 'error');
            }
        });

        // ============================================
        // Overlay Rendering (called by VideoPlayer)
        // ============================================

        /**
         * Render all overlays - called by VideoPlayer after each frame
         * @param {CanvasRenderingContext2D} ctx
         * @param {Object} info - { bitmap, frameIndex, totalFrames, offsetX, offsetY, drawX, drawY, effectiveScale, dpr }
         */
        function renderAllOverlays(ctx, info) {
            renderPoseOverlay(ctx, info);
            renderFrameIndexOverlay(ctx, info);
        }

        function renderPoseOverlay(ctx, info) {
            if (!poseData) return;
            if (!document.getElementById('showPoses').checked) return;

            const frameData = frameIndexMap.get(info.frameIndex);
            if (!frameData) return;

            const skeleton = poseData.skeleton;
            const showEdges = document.getElementById('showEdges').checked;
            const showNodes = document.getElementById('showNodes').checked;
            const nodeSize = parseInt(document.getElementById('nodeSize').value);
            const edgeWidth = parseInt(document.getElementById('edgeWidth').value);

            const { drawX, drawY, offsetX, offsetY, effectiveScale, dpr } = info;

            ctx.save();
            ctx.scale(dpr, dpr);

            for (const inst of frameData.instances) {
                const color = getTrackColor(inst.trackIdx);
                const points = inst.points;

                // Draw edges first (behind nodes)
                if (showEdges) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = edgeWidth;
                    ctx.lineCap = 'round';

                    for (const [srcIdx, dstIdx] of skeleton.edges) {
                        const srcPt = points[srcIdx];
                        const dstPt = points[dstIdx];
                        if (!srcPt || !dstPt) continue;

                        const x1 = drawX + offsetX + srcPt[0] * effectiveScale;
                        const y1 = drawY + offsetY + srcPt[1] * effectiveScale;
                        const x2 = drawX + offsetX + dstPt[0] * effectiveScale;
                        const y2 = drawY + offsetY + dstPt[1] * effectiveScale;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }

                // Draw nodes
                if (showNodes) {
                    ctx.fillStyle = color;

                    for (const pt of points) {
                        if (!pt) continue;

                        const cx = drawX + offsetX + pt[0] * effectiveScale;
                        const cy = drawY + offsetY + pt[1] * effectiveScale;

                        ctx.beginPath();
                        ctx.arc(cx, cy, nodeSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            ctx.restore();
        }

        function renderFrameIndexOverlay(ctx, info) {
            if (!document.getElementById('showFrameIndex').checked) return;

            const text = `${info.frameIndex + 1} / ${info.totalFrames}`;
            const padding = 8;
            const fontSize = 14;

            ctx.save();
            ctx.scale(info.dpr, info.dpr);

            ctx.font = `bold ${fontSize}px monospace`;
            const metrics = ctx.measureText(text);
            const boxWidth = metrics.width + padding * 2;
            const boxHeight = fontSize + padding * 2;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(10, 10, boxWidth, boxHeight);

            ctx.fillStyle = '#ffffff';
            ctx.fillText(text, 10 + padding, 10 + padding + fontSize - 2);

            ctx.restore();
        }

        function updateInstanceCount() {
            if (!player || !frameIndexMap) return;
            const frameData = frameIndexMap.get(player.frame);
            if (frameData) {
                document.getElementById('metricInstances').textContent = frameData.instances.length;
            }
        }

        // ============================================
        // Playback Controls
        // ============================================
        playBtn.addEventListener('click', () => {
            if (!player) return;
            player.toggle();
            playBtn.textContent = player.playing ? '⏸' : '▶';
        });

        // ============================================
        // Controls
        // ============================================
        document.getElementById('firstFrameBtn').addEventListener('click', () => player?.seek(0));
        document.getElementById('prevFrameBtn').addEventListener('click', () => player?.seek(player.frame - 1));
        document.getElementById('nextFrameBtn').addEventListener('click', () => player?.seek(player.frame + 1));
        document.getElementById('lastFrameBtn').addEventListener('click', () => player?.seek(player.frames - 1));

        document.getElementById('zoomInBtn').addEventListener('click', () => {
            if (!player) return;
            player.setZoom(player.zoom * 1.25);
        });
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            if (!player) return;
            player.setZoom(player.zoom * 0.8);
        });
        document.getElementById('resetZoomBtn').addEventListener('click', () => {
            player?.resetView();
        });

        // Overlay toggles - re-render when changed
        document.getElementById('showPoses').addEventListener('change', () => player?.render());
        document.getElementById('showEdges').addEventListener('change', () => player?.render());
        document.getElementById('showNodes').addEventListener('change', () => player?.render());
        document.getElementById('showFrameIndex').addEventListener('change', () => player?.render());

        // Sliders
        document.getElementById('nodeSize').addEventListener('input', (e) => {
            document.getElementById('nodeSizeValue').textContent = e.target.value;
            player?.render();
        });
        document.getElementById('edgeWidth').addEventListener('input', (e) => {
            document.getElementById('edgeWidthValue').textContent = e.target.value;
            player?.render();
        });

        // Decoder settings (display only, applied on next load)
        document.getElementById('cacheSize').addEventListener('input', (e) => {
            document.getElementById('cacheSizeValue').textContent = e.target.value;
        });
        document.getElementById('lookahead').addEventListener('input', (e) => {
            document.getElementById('lookaheadValue').textContent = e.target.value;
        });

        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (!player) return;

            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                player.seek(player.frame - (e.ctrlKey ? 30 : 1));
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                player.seek(player.frame + (e.ctrlKey ? 30 : 1));
            } else if (e.key === ' ') {
                e.preventDefault();
                player.toggle();
                playBtn.textContent = player.playing ? '⏸' : '▶';
            } else if (e.key === 'Home') {
                e.preventDefault();
                player.seek(0);
            } else if (e.key === 'End') {
                e.preventDefault();
                player.seek(player.frames - 1);
            } else if (e.key === 'p' || e.key === 'P') {
                const cb = document.getElementById('showPoses');
                cb.checked = !cb.checked;
                player.render();
            }
        });

        // Resize handle
        let isResizing = false;
        let resizeStartY = 0;
        let resizeStartHeight = 0;

        resizeHandle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isResizing = true;
            resizeStartY = e.clientY;
            resizeStartHeight = canvasContainer.clientHeight;
            document.body.style.cursor = 'ns-resize';
        });

        document.addEventListener('mousemove', (e) => {
            if (isResizing) {
                const delta = e.clientY - resizeStartY;
                const newHeight = Math.max(150, Math.min(window.innerHeight * 0.9, resizeStartHeight + delta));
                canvasContainer.style.height = newHeight + 'px';
                player?.render();
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
            }
        });
    </script>
</body>
</html>
