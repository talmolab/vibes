<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLP Skeleton Viewer</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        h1 { margin-bottom: 0.5rem; color: #fff; }
        .description { color: #aaa; margin-top: 0; }
        .container { max-width: 1400px; margin: 0 auto; }
        .controls {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        input[type="text"] {
            flex: 1;
            min-width: 200px;
            padding: 10px 12px;
            border: 1px solid #444;
            border-radius: 6px;
            background: #1a1a1a;
            color: #e0e0e0;
            font-size: 14px;
        }
        input[type="text"]:focus { outline: none; border-color: #667eea; }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }
        button:hover { background: #5568d3; }
        button:disabled { background: #444; cursor: not-allowed; }
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            margin: 20px 0;
        }
        .viewer-panel {
            background: #0a0a0a;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            min-height: 500px;
        }
        canvas { display: block; width: 100%; height: 100%; }
        .info-panel {
            background: #2a2a2a;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: 600px;
        }
        .info-header {
            background: #333;
            padding: 12px 15px;
            font-weight: 600;
            color: #fff;
            border-bottom: 1px solid #444;
        }
        .info-tabs {
            display: flex;
            border-bottom: 1px solid #444;
        }
        .info-tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            color: #888;
            font-size: 13px;
            border: none;
            background: none;
        }
        .info-tab:hover { color: #ccc; }
        .info-tab.active { color: #667eea; border-bottom: 2px solid #667eea; }
        .info-content { flex: 1; overflow-y: auto; }
        .tab-panel { display: none; padding: 0; }
        .tab-panel.active { display: block; }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        th, td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #333;
        }
        th {
            background: #222;
            color: #888;
            font-weight: 500;
            position: sticky;
            top: 0;
        }
        tr { cursor: pointer; }
        tr:hover { background: #333; }
        tr.highlight { background: #667eea40 !important; }
        tr.selected { background: #667eea60 !important; }
        .color-swatch {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            display: inline-block;
            vertical-align: middle;
        }
        .node-label {
            position: absolute;
            font-size: 11px;
            color: #fff;
            background: rgba(0,0,0,0.7);
            padding: 2px 5px;
            border-radius: 3px;
            pointer-events: none;
            white-space: nowrap;
        }
        .loading {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: #667eea;
            padding: 40px;
        }
        .loading.visible { display: flex; }
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #333;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .frame-nav {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: #222;
            border-top: 1px solid #444;
        }
        .frame-nav button { padding: 6px 12px; font-size: 12px; }
        .frame-nav span { color: #aaa; font-size: 13px; }
        .frame-slider { flex: 1; accent-color: #667eea; }
        .stats-row {
            display: flex;
            gap: 15px;
            padding: 10px 15px;
            background: #1a1a1a;
            font-size: 12px;
            color: #888;
            flex-wrap: wrap;
        }
        .stat { display: flex; gap: 5px; }
        .stat-label { color: #667eea; }
        @media (max-width: 900px) {
            .main-layout { grid-template-columns: 1fr; }
            .info-panel { max-height: 400px; }
        }
        @media (max-width: 600px) {
            body { padding: 10px; }
            .controls { padding: 10px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SLP Skeleton Viewer</h1>
        <p class="description">View skeleton structure from SLEAP .slp files with interactive node/edge inspection.</p>

        <div class="controls">
            <input type="text" id="urlInput" placeholder="Enter SLP file URL...">
            <button id="loadUrlBtn">Load URL</button>
            <button id="loadFileBtn">Open File</button>
            <input type="file" id="fileInput" accept=".slp,.pkg.slp" style="display: none;">
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <span id="loadingText">Loading...</span>
        </div>

        <div class="main-layout" id="mainLayout" style="display: none;">
            <div class="viewer-panel">
                <canvas id="canvas"></canvas>
                <div id="nodeLabels"></div>
            </div>
            <div class="info-panel">
                <div class="info-header" id="skeletonName">Skeleton</div>
                <div class="stats-row" id="statsRow">
                    <div class="stat"><span class="stat-label">Nodes:</span> <span id="nodeCount">0</span></div>
                    <div class="stat"><span class="stat-label">Edges:</span> <span id="edgeCount">0</span></div>
                    <div class="stat"><span class="stat-label">Symmetries:</span> <span id="symCount">0</span></div>
                </div>
                <div class="info-tabs">
                    <button class="info-tab active" data-tab="nodes">Nodes</button>
                    <button class="info-tab" data-tab="edges">Edges</button>
                    <button class="info-tab" data-tab="symmetries">Symmetries</button>
                </div>
                <div class="info-content">
                    <div class="tab-panel active" id="nodesPanel">
                        <table>
                            <thead><tr><th>#</th><th>Name</th></tr></thead>
                            <tbody id="nodesTable"></tbody>
                        </table>
                    </div>
                    <div class="tab-panel" id="edgesPanel">
                        <table>
                            <thead><tr><th>Color</th><th>Source</th><th>Target</th></tr></thead>
                            <tbody id="edgesTable"></tbody>
                        </table>
                    </div>
                    <div class="tab-panel" id="symmetriesPanel">
                        <table>
                            <thead><tr><th>Node A</th><th>Node B</th></tr></thead>
                            <tbody id="symmetriesTable"></tbody>
                        </table>
                    </div>
                </div>
                <div class="frame-nav" id="frameNav" style="display: none;">
                    <button id="prevFrameBtn">&#9664;</button>
                    <input type="range" id="frameSlider" class="frame-slider" min="0" value="0">
                    <button id="nextFrameBtn">&#9654;</button>
                    <span id="frameInfo">Frame 0/0</span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Edge colors
        const EDGE_COLORS = [
            '#667eea', '#4ade80', '#fbbf24', '#f472b6',
            '#06b6d4', '#f97316', '#a855f7', '#ef4444',
        ];

        // State
        let skeleton = null;
        let frames = [];
        let currentFrameIdx = 0;
        let selectedNode = null;
        let selectedEdge = null;
        let hoveredNode = null;
        let hoveredEdge = null;
        let nodePositions = [];

        // UI Elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const mainLayout = document.getElementById('mainLayout');
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');
        const urlInput = document.getElementById('urlInput');
        const fileInput = document.getElementById('fileInput');
        const nodeLabelsContainer = document.getElementById('nodeLabels');

        // Worker
        let worker = null;

        function initWorker() {
            if (worker) worker.terminate();
            worker = new Worker('./skeleton-worker.js');
            worker.onmessage = handleWorkerMessage;
            worker.onerror = (e) => {
                hideLoading();
                alert('Worker error: ' + e.message);
            };
        }

        function handleWorkerMessage(e) {
            const { type, data } = e.data;
            if (type === 'loading') {
                showLoading(data.message);
            } else if (type === 'result') {
                hideLoading();
                handleResult(data);
            } else if (type === 'error') {
                hideLoading();
                alert('Error: ' + data.message);
            }
        }

        function handleResult(data) {
            skeleton = data.skeleton;
            frames = data.frames || [];
            currentFrameIdx = 0;

            // Update UI
            document.getElementById('skeletonName').textContent = skeleton.name || 'Skeleton';
            document.getElementById('nodeCount').textContent = skeleton.nodes.length;
            document.getElementById('edgeCount').textContent = skeleton.edges.length;
            document.getElementById('symCount').textContent = skeleton.symmetries.length;

            populateNodesTable();
            populateEdgesTable();
            populateSymmetriesTable();

            // Frame navigation
            const frameNav = document.getElementById('frameNav');
            if (frames.length > 0) {
                frameNav.style.display = 'flex';
                document.getElementById('frameSlider').max = frames.length - 1;
                updateFrameInfo();
            } else {
                frameNav.style.display = 'none';
            }

            mainLayout.style.display = 'grid';
            resizeCanvas();
        }

        // Canvas resize
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            render();
        }

        // Loading UI
        function showLoading(text) {
            loadingText.textContent = text;
            loading.classList.add('visible');
        }
        function hideLoading() {
            loading.classList.remove('visible');
        }

        function getEdgeColor(idx) {
            return EDGE_COLORS[idx % EDGE_COLORS.length];
        }

        // Table population
        function populateNodesTable() {
            const tbody = document.getElementById('nodesTable');
            tbody.innerHTML = '';
            skeleton.nodes.forEach((name, idx) => {
                const tr = document.createElement('tr');
                tr.dataset.nodeIdx = idx;
                tr.innerHTML = `<td>${idx}</td><td>${name}</td>`;
                tr.addEventListener('mouseenter', () => hoverNode(idx));
                tr.addEventListener('mouseleave', () => hoverNode(null));
                tr.addEventListener('click', () => selectNode(idx));
                tbody.appendChild(tr);
            });
        }

        function populateEdgesTable() {
            const tbody = document.getElementById('edgesTable');
            tbody.innerHTML = '';
            skeleton.edges.forEach(([srcIdx, dstIdx], idx) => {
                const color = getEdgeColor(idx);
                const tr = document.createElement('tr');
                tr.dataset.edgeIdx = idx;
                tr.innerHTML = `
                    <td><span class="color-swatch" style="background:${color}"></span></td>
                    <td>${skeleton.nodes[srcIdx]}</td>
                    <td>${skeleton.nodes[dstIdx]}</td>
                `;
                tr.addEventListener('mouseenter', () => hoverEdge(idx));
                tr.addEventListener('mouseleave', () => hoverEdge(null));
                tr.addEventListener('click', () => selectEdge(idx));
                tbody.appendChild(tr);
            });
        }

        function populateSymmetriesTable() {
            const tbody = document.getElementById('symmetriesTable');
            tbody.innerHTML = '';
            if (skeleton.symmetries.length === 0) {
                tbody.innerHTML = '<tr><td colspan="2" style="color:#666;text-align:center;">No symmetries</td></tr>';
                return;
            }
            skeleton.symmetries.forEach(([nodeA, nodeB]) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td>${skeleton.nodes[nodeA]}</td><td>${skeleton.nodes[nodeB]}</td>`;
                tbody.appendChild(tr);
            });
        }

        // Hover/select
        function hoverNode(idx) {
            hoveredNode = idx;
            highlightTableRow('nodesTable', idx);
            render();
        }

        function hoverEdge(idx) {
            hoveredEdge = idx;
            highlightTableRow('edgesTable', idx);
            render();
        }

        function selectNode(idx) {
            selectedNode = selectedNode === idx ? null : idx;
            selectedEdge = null;
            updateTableSelection();
            render();
        }

        function selectEdge(idx) {
            selectedEdge = selectedEdge === idx ? null : idx;
            selectedNode = null;
            updateTableSelection();
            render();
        }

        function highlightTableRow(tableId, idx) {
            document.getElementById(tableId).querySelectorAll('tr').forEach((row, i) => {
                row.classList.toggle('highlight', i === idx);
            });
        }

        function updateTableSelection() {
            document.querySelectorAll('#nodesTable tr, #edgesTable tr').forEach(row => {
                row.classList.remove('selected');
            });
            if (selectedNode !== null) {
                const row = document.querySelector(`#nodesTable tr[data-node-idx="${selectedNode}"]`);
                if (row) row.classList.add('selected');
            }
            if (selectedEdge !== null) {
                const row = document.querySelector(`#edgesTable tr[data-edge-idx="${selectedEdge}"]`);
                if (row) row.classList.add('selected');
            }
        }

        // Render
        function render() {
            if (!skeleton) return;

            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentElement.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.scale(dpr, dpr);

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            // Get points from current frame
            let points = null;
            if (frames.length > 0 && frames[currentFrameIdx]?.instances?.[0]) {
                points = frames[currentFrameIdx].instances[0].points;
            }

            // Calculate positions
            nodePositions = [];
            if (points && points.length > 0 && points.some(p => p !== null)) {
                // Use actual pose positions
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                points.forEach(pt => {
                    if (pt) {
                        minX = Math.min(minX, pt[0]);
                        minY = Math.min(minY, pt[1]);
                        maxX = Math.max(maxX, pt[0]);
                        maxY = Math.max(maxY, pt[1]);
                    }
                });

                const padding = 80;
                const dataWidth = maxX - minX || 1;
                const dataHeight = maxY - minY || 1;
                const scale = Math.min((width - padding * 2) / dataWidth, (height - padding * 2) / dataHeight);
                const offsetX = (width - dataWidth * scale) / 2 - minX * scale;
                const offsetY = (height - dataHeight * scale) / 2 - minY * scale;

                points.forEach(pt => {
                    if (pt) {
                        nodePositions.push({ x: pt[0] * scale + offsetX, y: pt[1] * scale + offsetY });
                    } else {
                        nodePositions.push(null);
                    }
                });
            } else {
                // Circular layout for skeleton-only view
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) * 0.35;
                skeleton.nodes.forEach((_, idx) => {
                    const angle = (idx / skeleton.nodes.length) * Math.PI * 2 - Math.PI / 2;
                    nodePositions.push({
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius
                    });
                });
            }

            renderSkeleton(width, height);
        }

        function renderSkeleton(width, height) {
            nodeLabelsContainer.innerHTML = '';

            // Draw edges
            skeleton.edges.forEach(([srcIdx, dstIdx], idx) => {
                const srcPos = nodePositions[srcIdx];
                const dstPos = nodePositions[dstIdx];
                if (!srcPos || !dstPos) return;

                const isHovered = hoveredEdge === idx;
                const isSelected = selectedEdge === idx;
                const color = getEdgeColor(idx);

                ctx.strokeStyle = color;
                ctx.lineWidth = isHovered || isSelected ? 5 : 3;
                ctx.lineCap = 'round';
                ctx.globalAlpha = (hoveredEdge !== null && !isHovered && !isSelected) ? 0.3 : 1;

                ctx.beginPath();
                ctx.moveTo(srcPos.x, srcPos.y);
                ctx.lineTo(dstPos.x, dstPos.y);
                ctx.stroke();
            });

            ctx.globalAlpha = 1;

            // Draw nodes
            skeleton.nodes.forEach((name, idx) => {
                const pos = nodePositions[idx];
                if (!pos) return;

                const isHovered = hoveredNode === idx;
                const isSelected = selectedNode === idx;
                const radius = isHovered || isSelected ? 12 : 8;

                ctx.fillStyle = isSelected ? '#667eea' : (isHovered ? '#fff' : '#ddd');
                ctx.globalAlpha = (hoveredNode !== null && !isHovered && !isSelected) ? 0.3 : 1;

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.globalAlpha = 1;

                // Node label
                const label = document.createElement('div');
                label.className = 'node-label';
                label.textContent = name;
                label.style.left = (pos.x + 14) + 'px';
                label.style.top = (pos.y - 8) + 'px';
                if (isHovered || isSelected) {
                    label.style.background = '#667eea';
                }
                nodeLabelsContainer.appendChild(label);
            });
        }

        // Frame navigation
        function updateFrameInfo() {
            const frame = frames[currentFrameIdx];
            const frameIdx = frame?.frameIdx ?? currentFrameIdx;
            document.getElementById('frameInfo').textContent = `Frame ${frameIdx} (${currentFrameIdx + 1}/${frames.length})`;
            document.getElementById('frameSlider').value = currentFrameIdx;
        }

        function goToFrame(idx) {
            currentFrameIdx = Math.max(0, Math.min(frames.length - 1, idx));
            updateFrameInfo();
            render();
        }

        // Canvas mouse interaction
        canvas.addEventListener('mousemove', (e) => {
            if (!skeleton || nodePositions.length === 0) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check node proximity
            let foundNode = null;
            let minDist = 20;
            nodePositions.forEach((pos, idx) => {
                if (!pos) return;
                const dist = Math.hypot(pos.x - x, pos.y - y);
                if (dist < minDist) {
                    minDist = dist;
                    foundNode = idx;
                }
            });

            if (foundNode !== hoveredNode) {
                hoveredNode = foundNode;
                hoveredEdge = null;
                highlightTableRow('nodesTable', foundNode);
                highlightTableRow('edgesTable', null);
                render();
                return;
            }

            // Check edge proximity
            if (foundNode === null) {
                let foundEdge = null;
                let minEdgeDist = 10;
                skeleton.edges.forEach(([srcIdx, dstIdx], idx) => {
                    const srcPos = nodePositions[srcIdx];
                    const dstPos = nodePositions[dstIdx];
                    if (!srcPos || !dstPos) return;
                    const dist = pointToSegmentDist(x, y, srcPos.x, srcPos.y, dstPos.x, dstPos.y);
                    if (dist < minEdgeDist) {
                        minEdgeDist = dist;
                        foundEdge = idx;
                    }
                });

                if (foundEdge !== hoveredEdge) {
                    hoveredEdge = foundEdge;
                    hoveredNode = null;
                    highlightTableRow('edgesTable', foundEdge);
                    highlightTableRow('nodesTable', null);
                    render();
                }
            }
        });

        canvas.addEventListener('click', (e) => {
            if (hoveredNode !== null) {
                selectNode(hoveredNode);
            } else if (hoveredEdge !== null) {
                selectEdge(hoveredEdge);
            } else {
                selectedNode = null;
                selectedEdge = null;
                updateTableSelection();
                render();
            }
        });

        function pointToSegmentDist(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len2 = dx * dx + dy * dy;
            if (len2 === 0) return Math.hypot(px - x1, py - y1);
            let t = ((px - x1) * dx + (py - y1) * dy) / len2;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(px - (x1 + t * dx), py - (y1 + t * dy));
        }

        // Tab switching
        document.querySelectorAll('.info-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.info-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab + 'Panel').classList.add('active');
            });
        });

        // Event listeners
        document.getElementById('loadUrlBtn').addEventListener('click', () => {
            const url = urlInput.value.trim();
            if (url) loadFromUrl(url);
        });

        urlInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const url = urlInput.value.trim();
                if (url) loadFromUrl(url);
            }
        });

        document.getElementById('loadFileBtn').addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) loadFromFile(e.target.files[0]);
        });

        document.getElementById('prevFrameBtn').addEventListener('click', () => goToFrame(currentFrameIdx - 1));
        document.getElementById('nextFrameBtn').addEventListener('click', () => goToFrame(currentFrameIdx + 1));
        document.getElementById('frameSlider').addEventListener('input', (e) => goToFrame(parseInt(e.target.value)));

        window.addEventListener('resize', resizeCanvas);

        // Load functions
        function loadFromUrl(url) {
            initWorker();
            showLoading('Loading SLP file...');
            worker.postMessage({ type: 'loadUrl', url });
            updateUrl(url);
        }

        function loadFromFile(file) {
            initWorker();
            showLoading('Loading SLP file...');
            worker.postMessage({ type: 'loadFile', file });
        }

        function updateUrl(slpUrl) {
            const url = new URL(window.location.href);
            url.searchParams.set('url', slpUrl);
            history.replaceState({}, '', url);
        }

        // Check URL parameter on load
        const params = new URLSearchParams(window.location.search);
        const urlParam = params.get('url');
        if (urlParam) {
            urlInput.value = urlParam;
            loadFromUrl(urlParam);
        }
    </script>
</body>
</html>
