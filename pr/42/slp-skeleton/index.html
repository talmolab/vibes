<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLP Skeleton Viewer</title>
    <script type="importmap">
    {
        "imports": {
            "h5wasm": "https://unpkg.com/h5wasm@0.8.8/dist/esm/hdf5_hl.js",
            "yaml": "https://esm.sh/yaml@2.6.1",
            "skia-canvas": "data:text/javascript,export class Canvas{}",
            "child_process": "data:text/javascript,export function spawn(){}"
        }
    }
    </script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        h1 { margin-bottom: 0.5rem; color: #fff; }
        .description { color: #aaa; margin-top: 0; }
        .container { max-width: 1400px; margin: 0 auto; }
        .controls {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        input[type="text"] {
            flex: 1;
            min-width: 200px;
            padding: 10px 12px;
            border: 1px solid #444;
            border-radius: 6px;
            background: #1a1a1a;
            color: #e0e0e0;
            font-size: 14px;
        }
        input[type="text"]:focus { outline: none; border-color: #667eea; }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }
        button:hover { background: #5568d3; }
        button:disabled { background: #444; cursor: not-allowed; }
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            margin: 20px 0;
        }
        .viewer-panel {
            background: #0a0a0a;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            min-height: 500px;
        }
        canvas { display: block; width: 100%; height: 100%; cursor: grab; }
        canvas:active { cursor: grabbing; }
        .info-panel {
            background: #2a2a2a;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: 600px;
        }
        .info-header {
            background: #333;
            padding: 12px 15px;
            font-weight: 600;
            color: #fff;
            border-bottom: 1px solid #444;
        }
        .info-tabs {
            display: flex;
            border-bottom: 1px solid #444;
        }
        .info-tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            color: #888;
            font-size: 13px;
            border: none;
            background: none;
        }
        .info-tab:hover { color: #ccc; }
        .info-tab.active { color: #667eea; border-bottom: 2px solid #667eea; }
        .info-content { flex: 1; overflow-y: auto; }
        .tab-panel { display: none; padding: 0; }
        .tab-panel.active { display: block; }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        th, td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #333;
        }
        th {
            background: #222;
            color: #888;
            font-weight: 500;
            position: sticky;
            top: 0;
        }
        tr { cursor: pointer; }
        tr:hover { background: #333; }
        tr.highlight { background: #667eea40 !important; }
        tr.selected { background: #667eea60 !important; }
        .color-swatch {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            display: inline-block;
            vertical-align: middle;
        }
        .node-label {
            position: absolute;
            font-size: 11px;
            color: #fff;
            background: rgba(0,0,0,0.7);
            padding: 2px 5px;
            border-radius: 3px;
            pointer-events: none;
            white-space: nowrap;
        }
        .loading {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: #667eea;
            padding: 40px;
        }
        .loading.visible { display: flex; }
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #333;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .frame-nav {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: #222;
            border-top: 1px solid #444;
        }
        .frame-nav button { padding: 6px 12px; font-size: 12px; }
        .frame-nav span { color: #aaa; font-size: 13px; }
        .frame-slider { flex: 1; accent-color: #667eea; }
        .stats-row {
            display: flex;
            gap: 15px;
            padding: 10px 15px;
            background: #1a1a1a;
            font-size: 12px;
            color: #888;
            flex-wrap: wrap;
        }
        .stat { display: flex; gap: 5px; }
        .stat-label { color: #667eea; }
        .image-badge {
            display: inline-block;
            padding: 2px 6px;
            background: #4ade80;
            color: #000;
            font-size: 10px;
            border-radius: 3px;
            margin-left: 8px;
            font-weight: 600;
        }
        .image-badge.no-image {
            background: #666;
            color: #ccc;
        }
        @media (max-width: 900px) {
            .main-layout { grid-template-columns: 1fr; }
            .info-panel { max-height: 400px; }
        }
        @media (max-width: 600px) {
            body { padding: 10px; }
            .controls { padding: 10px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SLP Skeleton Viewer</h1>
        <p class="description">View skeleton structure from SLEAP .slp files with interactive node/edge inspection.</p>

        <div class="controls">
            <input type="text" id="urlInput" placeholder="Enter SLP file URL...">
            <button id="loadUrlBtn">Load URL</button>
            <button id="loadFileBtn">Open File</button>
            <input type="file" id="fileInput" accept=".slp,.pkg.slp" style="display: none;">
            <button id="resetViewBtn" title="Reset zoom and pan (R)">Reset View</button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <span id="loadingText">Loading...</span>
        </div>

        <div class="main-layout" id="mainLayout" style="display: none;">
            <div class="viewer-panel">
                <canvas id="canvas"></canvas>
                <div id="nodeLabels"></div>
            </div>
            <div class="info-panel">
                <div class="info-header" id="skeletonName">Skeleton</div>
                <div class="stats-row" id="statsRow">
                    <div class="stat"><span class="stat-label">Nodes:</span> <span id="nodeCount">0</span></div>
                    <div class="stat"><span class="stat-label">Edges:</span> <span id="edgeCount">0</span></div>
                    <div class="stat"><span class="stat-label">Symmetries:</span> <span id="symCount">0</span></div>
                </div>
                <div class="info-tabs">
                    <button class="info-tab active" data-tab="nodes">Nodes</button>
                    <button class="info-tab" data-tab="edges">Edges</button>
                    <button class="info-tab" data-tab="symmetries">Symmetries</button>
                </div>
                <div class="info-content">
                    <div class="tab-panel active" id="nodesPanel">
                        <table>
                            <thead><tr><th>#</th><th>Name</th></tr></thead>
                            <tbody id="nodesTable"></tbody>
                        </table>
                    </div>
                    <div class="tab-panel" id="edgesPanel">
                        <table>
                            <thead><tr><th>Color</th><th>Source</th><th>Target</th></tr></thead>
                            <tbody id="edgesTable"></tbody>
                        </table>
                    </div>
                    <div class="tab-panel" id="symmetriesPanel">
                        <table>
                            <thead><tr><th>Node A</th><th>Node B</th></tr></thead>
                            <tbody id="symmetriesTable"></tbody>
                        </table>
                    </div>
                </div>
                <div class="frame-nav" id="frameNav" style="display: none;">
                    <button id="prevFrameBtn">&#9664;</button>
                    <input type="range" id="frameSlider" class="frame-slider" min="0" value="0">
                    <button id="nextFrameBtn">&#9654;</button>
                    <span id="frameInfo">Frame 0/0</span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { loadSlp } from 'https://cdn.jsdelivr.net/npm/@talmolab/sleap-io.js@0.1.8/dist/index.js';

        // Edge colors
        const EDGE_COLORS = [
            '#667eea', '#4ade80', '#fbbf24', '#f472b6',
            '#06b6d4', '#f97316', '#a855f7', '#ef4444',
        ];

        // State
        let labels = null;
        let skeleton = null;
        let labeledFrames = [];
        let currentFrameIdx = 0;
        let selectedNode = null;
        let selectedEdge = null;
        let hoveredNode = null;
        let hoveredEdge = null;
        let nodePositions = [];
        let currentImage = null;
        let imageCache = new Map();
        let hasEmbeddedImages = false;
        let isImageLoading = false;
        let expectedImageSize = null; // { width, height } from video

        // Zoom/pan state
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        // Touch state
        let touchStartX = null;
        let touchStartY = null;
        let touchStartOffsetX = null;
        let touchStartOffsetY = null;
        let initialPinchDistance = null;
        let initialPinchScale = null;
        let pinchCenterX = null;
        let pinchCenterY = null;

        // Content bounds (for constraining pan)
        let contentBounds = { minX: 0, minY: 0, maxX: 0, maxY: 0 };

        // UI Elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const mainLayout = document.getElementById('mainLayout');
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');
        const urlInput = document.getElementById('urlInput');
        const fileInput = document.getElementById('fileInput');
        const nodeLabelsContainer = document.getElementById('nodeLabels');

        // Loading UI
        function showLoading(text) {
            loadingText.textContent = text;
            loading.classList.add('visible');
        }
        function hideLoading() {
            loading.classList.remove('visible');
        }

        function getEdgeColor(idx) {
            return EDGE_COLORS[idx % EDGE_COLORS.length];
        }

        // Handle loaded labels
        function handleResult(loadedLabels) {
            labels = loadedLabels;
            skeleton = labels.skeletons[0];
            labeledFrames = labels.labeledFrames;
            currentFrameIdx = 0;

            // Check for embedded images
            hasEmbeddedImages = labels.videos.some(v => v.hasEmbeddedImages);

            // Clear image cache
            imageCache.clear();
            currentImage = null;

            // Reset zoom/pan
            scale = 1;
            offsetX = 0;
            offsetY = 0;

            // Update UI
            const badgeHtml = hasEmbeddedImages
                ? '<span class="image-badge">Images</span>'
                : '<span class="image-badge no-image">No Images</span>';
            document.getElementById('skeletonName').innerHTML = (skeleton.name || 'Skeleton') + badgeHtml;
            document.getElementById('nodeCount').textContent = skeleton.nodes.length;
            document.getElementById('edgeCount').textContent = skeleton.edges.length;
            document.getElementById('symCount').textContent = skeleton.symmetries.length;

            populateNodesTable();
            populateEdgesTable();
            populateSymmetriesTable();

            // Frame navigation
            const frameNav = document.getElementById('frameNav');
            if (labeledFrames.length > 0) {
                frameNav.style.display = 'flex';
                document.getElementById('frameSlider').max = labeledFrames.length - 1;
                updateFrameInfo();
            } else {
                frameNav.style.display = 'none';
            }

            mainLayout.style.display = 'grid';
            resizeCanvas();

            // Load first frame image if available
            if (hasEmbeddedImages && labeledFrames.length > 0) {
                loadCurrentFrameImage();
            }
        }

        // Load image for current frame
        async function loadCurrentFrameImage() {
            if (!hasEmbeddedImages || labeledFrames.length === 0) return;

            const frame = labeledFrames[currentFrameIdx];
            const video = frame.video;
            const cacheKey = `${labels.videos.indexOf(video)}_${frame.frameIdx}`;

            // Get expected image size from video for positioning before image loads
            if (video.shape && video.shape.length >= 2) {
                expectedImageSize = { height: video.shape[0], width: video.shape[1] };
            }

            // Check cache first
            if (imageCache.has(cacheKey)) {
                currentImage = imageCache.get(cacheKey);
                isImageLoading = false;
                render();
                return;
            }

            // Show skeleton immediately while image loads
            isImageLoading = true;
            currentImage = null;
            render();

            // Get image from video backend
            if (video.backend) {
                try {
                    const image = await video.backend.getFrame(frame.frameIdx);
                    if (image) {
                        imageCache.set(cacheKey, image);
                        currentImage = image;
                    }
                } catch (err) {
                    console.warn('Error loading frame image:', err);
                }
            }
            isImageLoading = false;
            render();
        }

        // Canvas resize
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            render();
        }

        // Table population
        function populateNodesTable() {
            const tbody = document.getElementById('nodesTable');
            tbody.innerHTML = '';
            skeleton.nodes.forEach((node, idx) => {
                const name = node.name || node;
                const tr = document.createElement('tr');
                tr.dataset.nodeIdx = idx;
                tr.innerHTML = `<td>${idx}</td><td>${name}</td>`;
                tr.addEventListener('mouseenter', () => hoverNode(idx));
                tr.addEventListener('mouseleave', () => hoverNode(null));
                tr.addEventListener('click', () => selectNode(idx));
                tbody.appendChild(tr);
            });
        }

        function populateEdgesTable() {
            const tbody = document.getElementById('edgesTable');
            tbody.innerHTML = '';
            skeleton.edges.forEach((edge, idx) => {
                const srcName = edge.source.name || edge.source;
                const dstName = edge.destination.name || edge.destination;
                const color = getEdgeColor(idx);
                const tr = document.createElement('tr');
                tr.dataset.edgeIdx = idx;
                tr.innerHTML = `
                    <td><span class="color-swatch" style="background:${color}"></span></td>
                    <td>${srcName}</td>
                    <td>${dstName}</td>
                `;
                tr.addEventListener('mouseenter', () => hoverEdge(idx));
                tr.addEventListener('mouseleave', () => hoverEdge(null));
                tr.addEventListener('click', () => selectEdge(idx));
                tbody.appendChild(tr);
            });
        }

        function populateSymmetriesTable() {
            const tbody = document.getElementById('symmetriesTable');
            tbody.innerHTML = '';
            if (skeleton.symmetries.length === 0) {
                tbody.innerHTML = '<tr><td colspan="2" style="color:#666;text-align:center;">No symmetries</td></tr>';
                return;
            }
            skeleton.symmetries.forEach(symmetry => {
                // Symmetry objects have .at(0) and .at(1) methods or .nodes Set
                const nodeA = symmetry.at ? symmetry.at(0) : symmetry[0];
                const nodeB = symmetry.at ? symmetry.at(1) : symmetry[1];
                const nameA = nodeA?.name || nodeA;
                const nameB = nodeB?.name || nodeB;
                const tr = document.createElement('tr');
                tr.innerHTML = `<td>${nameA}</td><td>${nameB}</td>`;
                tbody.appendChild(tr);
            });
        }

        // Hover/select
        function hoverNode(idx) {
            hoveredNode = idx;
            highlightTableRow('nodesTable', idx);
            render();
        }

        function hoverEdge(idx) {
            hoveredEdge = idx;
            highlightTableRow('edgesTable', idx);
            render();
        }

        function selectNode(idx) {
            selectedNode = selectedNode === idx ? null : idx;
            selectedEdge = null;
            updateTableSelection();
            render();
        }

        function selectEdge(idx) {
            selectedEdge = selectedEdge === idx ? null : idx;
            selectedNode = null;
            updateTableSelection();
            render();
        }

        function highlightTableRow(tableId, idx) {
            document.getElementById(tableId).querySelectorAll('tr').forEach((row, i) => {
                row.classList.toggle('highlight', i === idx);
            });
        }

        function updateTableSelection() {
            document.querySelectorAll('#nodesTable tr, #edgesTable tr').forEach(row => {
                row.classList.remove('selected');
            });
            if (selectedNode !== null) {
                const row = document.querySelector(`#nodesTable tr[data-node-idx="${selectedNode}"]`);
                if (row) row.classList.add('selected');
            }
            if (selectedEdge !== null) {
                const row = document.querySelector(`#edgesTable tr[data-edge-idx="${selectedEdge}"]`);
                if (row) row.classList.add('selected');
            }
        }

        // Render
        function render() {
            if (!skeleton) return;

            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentElement.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.scale(dpr, dpr);

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            // Apply zoom/pan transform
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // Get points from current frame
            let points = null;
            if (labeledFrames.length > 0 && labeledFrames[currentFrameIdx]?.instances?.[0]) {
                const instance = labeledFrames[currentFrameIdx].instances[0];
                points = instance.points.map(p => {
                    if (!p || !p.visible) return null;
                    const [x, y] = p.xy;
                    if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
                    return [x, y];
                });
            }

            // Get image dimensions if available, or use expected size
            let imgWidth = 0, imgHeight = 0;
            if (currentImage) {
                if (currentImage instanceof ImageBitmap) {
                    imgWidth = currentImage.width;
                    imgHeight = currentImage.height;
                } else if (currentImage instanceof ImageData) {
                    imgWidth = currentImage.width;
                    imgHeight = currentImage.height;
                }
            } else if (expectedImageSize) {
                imgWidth = expectedImageSize.width;
                imgHeight = expectedImageSize.height;
            }

            // Calculate positions
            nodePositions = [];

            if (imgWidth > 0 && imgHeight > 0 && points && points.length > 0) {
                // Calculate transform to fit image in canvas with padding
                const padding = 20;
                const baseScale = Math.min((width - padding * 2) / imgWidth, (height - padding * 2) / imgHeight);
                const baseOffsetX = (width - imgWidth * baseScale) / 2;
                const baseOffsetY = (height - imgHeight * baseScale) / 2;

                // Draw image if available
                if (currentImage) {
                    ctx.drawImage(currentImage, baseOffsetX, baseOffsetY, imgWidth * baseScale, imgHeight * baseScale);
                }

                // Calculate node positions from pose data (in image coordinates)
                points.forEach(pt => {
                    if (pt) {
                        nodePositions.push({
                            x: pt[0] * baseScale + baseOffsetX,
                            y: pt[1] * baseScale + baseOffsetY
                        });
                    } else {
                        nodePositions.push(null);
                    }
                });
            } else if (points && points.length > 0 && points.some(p => p !== null)) {
                // No image - use pose bounds for positioning
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                points.forEach(pt => {
                    if (pt) {
                        minX = Math.min(minX, pt[0]);
                        minY = Math.min(minY, pt[1]);
                        maxX = Math.max(maxX, pt[0]);
                        maxY = Math.max(maxY, pt[1]);
                    }
                });

                const padding = 80;
                const dataWidth = maxX - minX || 1;
                const dataHeight = maxY - minY || 1;
                const baseScale = Math.min((width - padding * 2) / dataWidth, (height - padding * 2) / dataHeight);
                const baseOffsetX = (width - dataWidth * baseScale) / 2 - minX * baseScale;
                const baseOffsetY = (height - dataHeight * baseScale) / 2 - minY * baseScale;

                points.forEach(pt => {
                    if (pt) {
                        nodePositions.push({ x: pt[0] * baseScale + baseOffsetX, y: pt[1] * baseScale + baseOffsetY });
                    } else {
                        nodePositions.push(null);
                    }
                });
            } else {
                // Circular layout for skeleton-only view
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) * 0.35;
                skeleton.nodes.forEach((_, idx) => {
                    const angle = (idx / skeleton.nodes.length) * Math.PI * 2 - Math.PI / 2;
                    nodePositions.push({
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius
                    });
                });
            }

            renderSkeleton(width, height);

            // Restore context after zoom/pan transform
            ctx.restore();

            // Draw loading indicator if image is loading
            if (isImageLoading) {
                ctx.save();
                const indicatorX = 15;
                const indicatorY = height - 30;

                // Draw spinner
                const spinnerRadius = 8;
                const time = Date.now() / 1000;

                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                const startAngle = time * 4;
                ctx.arc(indicatorX + spinnerRadius, indicatorY, spinnerRadius, startAngle, startAngle + Math.PI * 1.5);
                ctx.stroke();

                // "Loading image..." text
                ctx.fillStyle = '#aaa';
                ctx.font = '12px system-ui, -apple-system, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('Loading image...', indicatorX + spinnerRadius * 2 + 8, indicatorY + 4);
                ctx.restore();

                // Animate spinner
                requestAnimationFrame(() => {
                    if (isImageLoading) render();
                });
            }

            // Update content bounds for pan constraints
            if (nodePositions.length > 0) {
                contentBounds.minX = Infinity;
                contentBounds.minY = Infinity;
                contentBounds.maxX = -Infinity;
                contentBounds.maxY = -Infinity;
                nodePositions.forEach(pos => {
                    if (pos) {
                        contentBounds.minX = Math.min(contentBounds.minX, pos.x);
                        contentBounds.minY = Math.min(contentBounds.minY, pos.y);
                        contentBounds.maxX = Math.max(contentBounds.maxX, pos.x);
                        contentBounds.maxY = Math.max(contentBounds.maxY, pos.y);
                    }
                });
            }
        }

        function renderSkeleton(width, height) {
            nodeLabelsContainer.innerHTML = '';

            // Draw edges (size stays constant regardless of zoom)
            skeleton.edges.forEach((edge, idx) => {
                const srcIdx = skeleton.index(edge.source.name || edge.source);
                const dstIdx = skeleton.index(edge.destination.name || edge.destination);
                const srcPos = nodePositions[srcIdx];
                const dstPos = nodePositions[dstIdx];
                if (!srcPos || !dstPos) return;

                const isHovered = hoveredEdge === idx;
                const isSelected = selectedEdge === idx;
                const color = getEdgeColor(idx);

                ctx.strokeStyle = color;
                ctx.lineWidth = (isHovered || isSelected ? 5 : 3) / scale;
                ctx.lineCap = 'round';
                ctx.globalAlpha = (hoveredEdge !== null && !isHovered && !isSelected) ? 0.3 : 1;

                ctx.beginPath();
                ctx.moveTo(srcPos.x, srcPos.y);
                ctx.lineTo(dstPos.x, dstPos.y);
                ctx.stroke();
            });

            ctx.globalAlpha = 1;

            // Draw nodes (size stays constant regardless of zoom)
            skeleton.nodes.forEach((node, idx) => {
                const name = node.name || node;
                const pos = nodePositions[idx];
                if (!pos) return;

                const isHovered = hoveredNode === idx;
                const isSelected = selectedNode === idx;
                const radius = (isHovered || isSelected ? 12 : 8) / scale;

                ctx.fillStyle = isSelected ? '#667eea' : (isHovered ? '#fff' : '#ddd');
                ctx.globalAlpha = (hoveredNode !== null && !isHovered && !isSelected) ? 0.3 : 1;

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2 / scale;
                ctx.stroke();

                ctx.globalAlpha = 1;

                // Node label (constant size, positioned in screen space)
                const label = document.createElement('div');
                label.className = 'node-label';
                label.textContent = name;
                const labelX = pos.x * scale + offsetX + 14;
                const labelY = pos.y * scale + offsetY - 8;
                label.style.left = labelX + 'px';
                label.style.top = labelY + 'px';
                if (isHovered || isSelected) {
                    label.style.background = '#667eea';
                }
                nodeLabelsContainer.appendChild(label);
            });
        }

        // Frame navigation
        function updateFrameInfo() {
            const frame = labeledFrames[currentFrameIdx];
            const frameIdx = frame?.frameIdx ?? currentFrameIdx;
            document.getElementById('frameInfo').textContent = `Frame ${frameIdx} (${currentFrameIdx + 1}/${labeledFrames.length})`;
            document.getElementById('frameSlider').value = currentFrameIdx;
        }

        function goToFrame(idx) {
            currentFrameIdx = Math.max(0, Math.min(labeledFrames.length - 1, idx));
            updateFrameInfo();
            updateUrl();

            // Load image for the new frame
            if (hasEmbeddedImages) {
                loadCurrentFrameImage();
            } else {
                render();
            }
        }

        // Canvas mouse interaction
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) return; // Don't detect hover during drag
            if (!skeleton || nodePositions.length === 0) return;
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;

            // Convert screen coordinates to content coordinates
            const x = (screenX - offsetX) / scale;
            const y = (screenY - offsetY) / scale;

            // Check node proximity (adjust threshold for zoom level)
            let foundNode = null;
            let minDist = 20 / scale;
            nodePositions.forEach((pos, idx) => {
                if (!pos) return;
                const dist = Math.hypot(pos.x - x, pos.y - y);
                if (dist < minDist) {
                    minDist = dist;
                    foundNode = idx;
                }
            });

            if (foundNode !== hoveredNode) {
                hoveredNode = foundNode;
                hoveredEdge = null;
                highlightTableRow('nodesTable', foundNode);
                highlightTableRow('edgesTable', null);
                render();
                return;
            }

            // Check edge proximity
            if (foundNode === null) {
                let foundEdge = null;
                let minEdgeDist = 10 / scale;
                skeleton.edges.forEach((edge, idx) => {
                    const srcIdx = skeleton.index(edge.source.name || edge.source);
                    const dstIdx = skeleton.index(edge.destination.name || edge.destination);
                    const srcPos = nodePositions[srcIdx];
                    const dstPos = nodePositions[dstIdx];
                    if (!srcPos || !dstPos) return;
                    const dist = pointToSegmentDist(x, y, srcPos.x, srcPos.y, dstPos.x, dstPos.y);
                    if (dist < minEdgeDist) {
                        minEdgeDist = dist;
                        foundEdge = idx;
                    }
                });

                if (foundEdge !== hoveredEdge) {
                    hoveredEdge = foundEdge;
                    hoveredNode = null;
                    highlightTableRow('edgesTable', foundEdge);
                    highlightTableRow('nodesTable', null);
                    render();
                }
            }
        });

        canvas.addEventListener('click', (e) => {
            if (hoveredNode !== null) {
                selectNode(hoveredNode);
            } else if (hoveredEdge !== null) {
                selectEdge(hoveredEdge);
            } else {
                selectedNode = null;
                selectedEdge = null;
                updateTableSelection();
                render();
            }
        });

        function pointToSegmentDist(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len2 = dx * dx + dy * dy;
            if (len2 === 0) return Math.hypot(px - x1, py - y1);
            let t = ((px - x1) * dx + (py - y1) * dy) / len2;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(px - (x1 + t * dx), py - (y1 + t * dy));
        }

        // Zoom/pan helper functions
        function constrainOffset() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            // If no content bounds yet, skip
            if (contentBounds.minX === Infinity) return;

            // Content dimensions in screen space
            const scaledWidth = (contentBounds.maxX - contentBounds.minX) * scale;
            const scaledHeight = (contentBounds.maxY - contentBounds.minY) * scale;

            // Require at least 25% visible on each axis (but cap at half the container)
            const minVisible = 0.25;
            const minVisibleX = Math.min(scaledWidth * minVisible, width * 0.5);
            const minVisibleY = Math.min(scaledHeight * minVisible, height * 0.5);

            // Calculate bounds based on where content actually is:
            // - Right edge of content (maxX * scale + offsetX) should be >= minVisibleX
            // - Left edge of content (minX * scale + offsetX) should be <= width - minVisibleX
            const minOffsetX = minVisibleX - contentBounds.maxX * scale;
            const maxOffsetX = width - minVisibleX - contentBounds.minX * scale;
            const minOffsetY = minVisibleY - contentBounds.maxY * scale;
            const maxOffsetY = height - minVisibleY - contentBounds.minY * scale;

            offsetX = Math.max(minOffsetX, Math.min(maxOffsetX, offsetX));
            offsetY = Math.max(minOffsetY, Math.min(maxOffsetY, offsetY));
        }

        function zoomToPoint(pointX, pointY, newScale) {
            const rect = canvas.parentElement.getBoundingClientRect();

            // Find content point under the cursor
            const contentX = (pointX - offsetX) / scale;
            const contentY = (pointY - offsetY) / scale;

            // Calculate new offset to keep that content point at the same position
            offsetX = pointX - contentX * newScale;
            offsetY = pointY - contentY * newScale;

            scale = newScale;
            constrainOffset();
        }

        function resetView() {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            render();
            updateUrl();
        }

        // Mouse wheel zoom handler
        function onWheel(e) {
            e.preventDefault();

            const rect = canvas.parentElement.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Normalize deltaY for different input devices
            let delta = e.deltaY;
            if (e.deltaMode === 1) delta *= 40;
            delta = Math.max(-100, Math.min(100, delta));

            // Exponential scaling
            const zoomFactor = Math.exp(-delta * 0.002);
            const newScale = Math.max(0.1, Math.min(50, scale * zoomFactor));

            zoomToPoint(mouseX, mouseY, newScale);
            render();
            updateUrlThrottled();
        }

        // Mouse drag pan handlers
        function onMouseDown(e) {
            // Only start drag if not clicking on a node/edge
            if (hoveredNode === null && hoveredEdge === null) {
                isDragging = true;
                dragStartX = e.clientX - offsetX;
                dragStartY = e.clientY - offsetY;
                canvas.style.cursor = 'grabbing';
            }
        }

        function onMouseMoveDrag(e) {
            if (isDragging) {
                offsetX = e.clientX - dragStartX;
                offsetY = e.clientY - dragStartY;
                constrainOffset();
                render();
            }
        }

        function onMouseUp() {
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = 'default';
                updateUrlThrottled();
            }
        }

        // Touch event handlers
        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getTouchCenter(touches, rect) {
            return {
                x: (touches[0].clientX + touches[1].clientX) / 2 - rect.left,
                y: (touches[0].clientY + touches[1].clientY) / 2 - rect.top
            };
        }

        function onTouchStart(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                initialPinchDistance = getTouchDistance(e.touches);
                initialPinchScale = scale;
                const rect = canvas.parentElement.getBoundingClientRect();
                const center = getTouchCenter(e.touches, rect);
                pinchCenterX = center.x;
                pinchCenterY = center.y;
                touchStartX = null;
                touchStartY = null;
            } else if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchStartOffsetX = offsetX;
                touchStartOffsetY = offsetY;
            }
        }

        function onTouchMove(e) {
            if (e.touches.length === 2 && initialPinchDistance !== null) {
                e.preventDefault();
                const rect = canvas.parentElement.getBoundingClientRect();
                const currentCenter = getTouchCenter(e.touches, rect);
                const currentDistance = getTouchDistance(e.touches);
                const pinchRatio = currentDistance / initialPinchDistance;
                const newScale = Math.max(0.1, Math.min(50, initialPinchScale * pinchRatio));

                // Zoom towards pinch center
                const contentX = (pinchCenterX - offsetX) / scale;
                const contentY = (pinchCenterY - offsetY) / scale;

                offsetX = pinchCenterX - contentX * newScale;
                offsetY = pinchCenterY - contentY * newScale;

                // Pan with pinch center movement
                offsetX += currentCenter.x - pinchCenterX;
                offsetY += currentCenter.y - pinchCenterY;
                pinchCenterX = currentCenter.x;
                pinchCenterY = currentCenter.y;

                scale = newScale;
                constrainOffset();
                render();
            } else if (e.touches.length === 1 && touchStartX !== null) {
                e.preventDefault();
                offsetX = touchStartOffsetX + (e.touches[0].clientX - touchStartX);
                offsetY = touchStartOffsetY + (e.touches[0].clientY - touchStartY);
                constrainOffset();
                render();
            }
        }

        function onTouchEnd(e) {
            if (e.touches.length < 2) {
                initialPinchDistance = null;
                initialPinchScale = null;
                pinchCenterX = null;
                pinchCenterY = null;
            }
            if (e.touches.length === 0) {
                touchStartX = null;
                touchStartY = null;
                updateUrlThrottled();
            }
        }

        // Tab switching
        document.querySelectorAll('.info-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.info-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab + 'Panel').classList.add('active');
            });
        });

        // Event listeners
        document.getElementById('loadUrlBtn').addEventListener('click', () => {
            const url = urlInput.value.trim();
            if (url) loadFromUrl(url);
        });

        urlInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const url = urlInput.value.trim();
                if (url) loadFromUrl(url);
            }
        });

        document.getElementById('loadFileBtn').addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) loadFromFile(e.target.files[0]);
        });

        document.getElementById('prevFrameBtn').addEventListener('click', () => goToFrame(currentFrameIdx - 1));
        document.getElementById('nextFrameBtn').addEventListener('click', () => goToFrame(currentFrameIdx + 1));
        document.getElementById('frameSlider').addEventListener('input', (e) => goToFrame(parseInt(e.target.value)));

        // Reset view button
        document.getElementById('resetViewBtn').addEventListener('click', resetView);

        // Zoom/pan event listeners
        canvas.addEventListener('wheel', onWheel, { passive: false });
        canvas.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mousemove', onMouseMoveDrag);
        document.addEventListener('mouseup', onMouseUp);
        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });
        canvas.addEventListener('touchend', onTouchEnd);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;
            if (e.key === 'r' || e.key === 'R') {
                resetView();
            }
        });

        window.addEventListener('resize', resizeCanvas);

        // Load functions
        async function loadFromUrl(url) {
            showLoading('Loading SLP file...');
            try {
                const loadedLabels = await loadSlp(url, {
                    openVideos: true,
                    h5: { stream: 'range', filenameHint: url.split('/').pop() }
                });
                hideLoading();
                handleResult(loadedLabels);
                updateUrl(url);
            } catch (err) {
                hideLoading();
                alert('Error: ' + err.message);
            }
        }

        async function loadFromFile(file) {
            showLoading('Loading SLP file...');
            try {
                const loadedLabels = await loadSlp(file, {
                    openVideos: true,
                    h5: { filenameHint: file.name }
                });
                hideLoading();
                handleResult(loadedLabels);
            } catch (err) {
                hideLoading();
                alert('Error: ' + err.message);
            }
        }

        // URL state management
        let urlUpdateTimeout = null;

        function updateUrl(slpUrl = null) {
            const url = new URL(window.location.href);
            if (slpUrl !== null) {
                url.searchParams.set('url', slpUrl);
            }
            // Only save view state if we have loaded content
            if (labeledFrames.length > 0) {
                url.searchParams.set('frame', currentFrameIdx);
            }
            if (scale !== 1 || offsetX !== 0 || offsetY !== 0) {
                url.searchParams.set('zoom', scale.toFixed(2));
                url.searchParams.set('panX', Math.round(offsetX));
                url.searchParams.set('panY', Math.round(offsetY));
            } else {
                url.searchParams.delete('zoom');
                url.searchParams.delete('panX');
                url.searchParams.delete('panY');
            }
            history.replaceState({}, '', url);
        }

        function updateUrlThrottled() {
            if (urlUpdateTimeout) clearTimeout(urlUpdateTimeout);
            urlUpdateTimeout = setTimeout(() => updateUrl(), 150);
        }

        // Check URL parameters on load
        const params = new URLSearchParams(window.location.search);
        const urlParam = params.get('url');
        const frameParam = params.get('frame');
        const zoomParam = params.get('zoom');
        const panXParam = params.get('panX');
        const panYParam = params.get('panY');

        // Store initial view state to apply after loading
        const initialViewState = {
            frame: frameParam !== null ? parseInt(frameParam) : null,
            zoom: zoomParam !== null ? parseFloat(zoomParam) : null,
            panX: panXParam !== null ? parseInt(panXParam) : null,
            panY: panYParam !== null ? parseInt(panYParam) : null
        };

        if (urlParam) {
            urlInput.value = urlParam;
            loadFromUrl(urlParam).then(() => {
                // Apply initial view state after loading
                // Set zoom/pan first (before goToFrame which updates URL)
                if (initialViewState.zoom !== null) {
                    scale = initialViewState.zoom;
                }
                if (initialViewState.panX !== null) {
                    offsetX = initialViewState.panX;
                }
                if (initialViewState.panY !== null) {
                    offsetY = initialViewState.panY;
                }
                // Now go to frame (which will update URL with correct zoom/pan)
                if (initialViewState.frame !== null && labeledFrames.length > 0) {
                    goToFrame(initialViewState.frame);
                } else if (initialViewState.zoom !== null || initialViewState.panX !== null || initialViewState.panY !== null) {
                    render();
                    updateUrl();
                }
            });
        }
    </script>
</body>
</html>
