<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLEAP-NN Config Picker</title>
    <style>
        * { box-sizing: border-box; }

        :root {
            --bg: #1a1a2e;
            --surface: #252542;
            --surface-hover: #2d2d4a;
            --border: #3a3a5c;
            --text: #e8e8f0;
            --text-dim: #8888aa;
            --accent: #667eea;
            --accent-dim: #5551cc;
            --success: #4ade80;
            --warning: #fbbf24;
            --error: #f87171;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        h1 { margin-bottom: 0.5rem; color: #fff; font-size: 1.8rem; }
        h2 { color: var(--accent); margin-top: 1.5rem; margin-bottom: 0.5rem; font-size: 1.2rem; }
        h3 { color: var(--text-dim); margin: 1rem 0 0.5rem; font-size: 1rem; }
        .description { color: var(--text-dim); margin-top: 0; }

        /* Cards */
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
        }
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .card-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #fff;
            margin: 0;
        }
        .badge {
            background: var(--accent);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        .badge.warning { background: var(--warning); }
        .badge.success { background: var(--success); }
        .badge.info { background: #3b82f6; }

        /* File upload */
        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(102, 126, 234, 0.02);
        }
        .upload-zone:hover, .upload-zone.dragover {
            border-color: var(--accent);
            background: rgba(102, 126, 234, 0.1);
        }
        .upload-zone input { display: none; }

        /* Buttons */
        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            margin: 3px;
            transition: all 0.2s;
        }
        button:hover { background: var(--accent-dim); transform: translateY(-1px); }
        button:disabled { background: var(--border); cursor: not-allowed; opacity: 0.6; transform: none; }
        button.secondary { background: var(--border); }
        button.secondary:hover { background: var(--surface-hover); }
        button.success { background: var(--success); }
        button.success:hover { background: #22c55e; }
        button.danger { background: var(--error); }
        button.danger:hover { background: #ef4444; }
        button.small { padding: 6px 12px; font-size: 12px; }

        /* Form elements */
        .form-group { margin: 15px 0; }
        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            font-size: 0.9rem;
            color: var(--text-dim);
        }
        select, input[type="number"], input[type="text"] {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg);
            color: var(--text);
            font-size: 14px;
            transition: border-color 0.2s;
        }
        select:focus, input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        select:hover, input[type="number"]:hover, input[type="text"]:hover {
            border-color: var(--text-dim);
        }

        /* Range slider */
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #444;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
        }
        .range-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #888;
            margin-top: 5px;
        }

        /* Grid layouts */
        .grid-2 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }
        .grid-3 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
        }

        /* Stats display */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 10px;
        }
        .stat-item {
            background: #333;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: #667eea;
        }
        .stat-label {
            font-size: 0.75rem;
            color: #888;
            margin-top: 4px;
        }

        /* Model type cards */
        .model-type-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 15px;
        }
        .model-type-card {
            background: #333;
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .model-type-card:hover { border-color: #667eea; }
        .model-type-card.selected {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.15);
        }
        .model-type-card.recommended { border-color: #10b981; }
        .model-type-card.disabled { opacity: 0.4; cursor: not-allowed; }
        .model-type-name {
            font-weight: 600;
            color: #fff;
            margin-bottom: 5px;
        }
        .model-type-desc {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 8px;
        }
        .model-type-details {
            font-size: 0.8rem;
            color: #888;
            background: #2a2a2a;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
        }

        /* Info box */
        .info-box {
            background: rgba(59, 130, 246, 0.15);
            border-left: 3px solid #3b82f6;
            padding: 12px 15px;
            border-radius: 0 6px 6px 0;
            margin: 10px 0;
            font-size: 0.9rem;
        }
        .info-box.warning {
            background: rgba(245, 158, 11, 0.15);
            border-color: #f59e0b;
        }
        .info-box.success {
            background: rgba(16, 185, 129, 0.15);
            border-color: #10b981;
        }

        /* Frame viewer */
        .frame-viewer {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            margin: 15px 0;
        }
        .frame-canvas {
            display: block;
            width: 100%;
            max-height: 400px;
            object-fit: contain;
        }
        .frame-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #222;
        }
        .frame-slider {
            flex: 1;
        }
        .frame-info {
            font-size: 0.8rem;
            color: #888;
        }

        /* Receptive field visualization */
        .rf-viz-container {
            position: relative;
            background: #1a1a1a;
            border-radius: 6px;
            overflow: hidden;
            margin: 15px 0;
        }
        .rf-canvas {
            display: block;
            width: 100%;
            max-height: 350px;
        }
        .rf-info-overlay {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.85);
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 0.85rem;
        }
        .rf-legend {
            display: flex;
            gap: 15px;
            margin-top: 8px;
            font-size: 0.75rem;
        }
        .rf-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .rf-legend-box {
            width: 12px;
            height: 12px;
            border: 2px solid;
            border-radius: 2px;
        }

        /* Model info panel */
        .model-info-panel {
            background: #333;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }
        .model-params {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .model-param-item {
            text-align: center;
        }
        .model-param-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #667eea;
        }
        .model-param-label {
            font-size: 0.75rem;
            color: #888;
        }
        .arch-diagram {
            background: #2a2a2a;
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
            overflow-x: auto;
        }
        .arch-blocks {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .arch-block {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            text-align: center;
            min-width: 60px;
        }
        .arch-block.input { background: #374151; color: #9ca3af; }
        .arch-block.encoder { background: #4338ca; color: #c7d2fe; }
        .arch-block.middle { background: #b45309; color: #fde68a; }
        .arch-block.decoder { background: #047857; color: #a7f3d0; }
        .arch-block.head { background: #be185d; color: #fbcfe8; }
        .arch-arrow {
            color: #555;
            font-size: 1.2rem;
        }
        .arch-details {
            margin-top: 10px;
            font-size: 0.75rem;
            color: #888;
            text-align: center;
        }

        /* PR28-style vertical UNet diagram */
        .unet-diagram {
            display: flex;
            flex-direction: column;
            gap: 2px;
            align-items: center;
            padding: 12px;
            background: var(--bg);
            border-radius: 6px;
        }
        .unet-diagram .diagram-title {
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 8px;
        }
        .unet-diagram .layer-box {
            padding: 4px 12px;
            border-radius: 4px;
            color: white;
            font-size: 0.7rem;
            text-align: center;
            min-width: 180px;
        }
        .unet-diagram .layer-box.input { background: #4a5568; }
        .unet-diagram .layer-box.encoder { background: #3b82f6; }
        .unet-diagram .layer-box.bottleneck { background: #8b5cf6; font-weight: bold; padding: 6px 16px; }
        .unet-diagram .layer-box.decoder { background: #10b981; }
        .unet-diagram .layer-box.head { background: #f59e0b; }
        .unet-diagram .section-label {
            color: var(--accent);
            font-weight: bold;
            font-size: 0.7rem;
            margin: 4px 0;
        }
        .unet-diagram .section-label.encoder { color: #60a5fa; }
        .unet-diagram .section-label.decoder { color: #34d399; }
        .unet-diagram .arrow {
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        /* GPU Memory Estimation */
        .memory-card {
            background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 100%);
            border: 1px solid #3a3a5c;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .memory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .memory-total {
            font-size: 1.5rem;
            font-weight: 700;
            color: #667eea;
        }
        .memory-total.warning { color: #f59e0b; }
        .memory-total.danger { color: #ef4444; }
        .memory-breakdown {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            font-size: 0.8rem;
        }
        .memory-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
        }
        .memory-item-label { color: #888; }
        .memory-item-value { color: #e0e0e0; font-weight: 500; }
        .memory-status {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            text-align: center;
        }
        .memory-status.ok { background: rgba(16, 185, 129, 0.2); color: #10b981; }
        .memory-status.warning { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }
        .memory-status.danger { background: rgba(239, 68, 68, 0.2); color: #ef4444; }

        /* Augmentation - slider layout like PR28 */
        .aug-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        .aug-sliders {
            flex: 1;
            min-width: 220px;
        }
        .aug-sliders h4 {
            margin: 0 0 12px;
            color: #888;
            font-size: 0.85rem;
            border-bottom: 1px solid #444;
            padding-bottom: 6px;
        }
        .aug-sliders h4:not(:first-child) {
            margin-top: 20px;
        }
        .slider-group {
            margin-bottom: 14px;
        }
        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        .slider-label {
            font-size: 0.8rem;
            color: #ccc;
        }
        .slider-value {
            font-size: 0.75rem;
            color: #667eea;
            font-weight: 500;
            min-width: 70px;
            text-align: right;
        }
        .aug-sliders input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        .aug-sliders input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }
        .aug-sliders input[type="range"]::-webkit-slider-thumb:hover {
            background: #8b9cf6;
        }
        .aug-sliders input[type="range"]:disabled {
            opacity: 0.4;
        }
        .aug-preview-container {
            flex: 0 0 320px;
            text-align: center;
        }
        .aug-preview-pair {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .aug-preview-box {
            text-align: center;
        }
        .aug-preview-box canvas {
            width: 150px;
            height: 150px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #1a1a2e;
        }
        .aug-preview-box .label {
            font-size: 0.75rem;
            color: #888;
            margin-top: 4px;
        }
        #randomize-aug-btn {
            margin-top: 10px;
            padding: 8px 16px;
            font-size: 0.8rem;
            background: #333;
            border: 1px solid #555;
            border-radius: 6px;
            color: #ccc;
            cursor: pointer;
            transition: all 0.2s;
        }
        #randomize-aug-btn:hover {
            background: #444;
            border-color: #667eea;
        }

        /* Anchor point selector */
        .anchor-selector {
            background: #333;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }
        .anchor-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .anchor-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #2a2a2a;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .anchor-item:hover { border-color: #667eea; }
        .anchor-item.selected {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.2);
        }
        .anchor-visibility {
            font-size: 0.75rem;
            color: #888;
        }
        .anchor-visibility.high { color: #10b981; }
        .anchor-visibility.medium { color: #f59e0b; }
        .anchor-visibility.low { color: #ef4444; }

        /* Anchor preview visualization */
        .anchor-preview {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            margin-top: 15px;
        }
        .anchor-preview-canvas {
            background: #222;
            border-radius: 6px;
            flex-shrink: 0;
            cursor: pointer;
        }
        .anchor-preview-info {
            font-size: 0.85rem;
            color: #aaa;
        }
        .anchor-canvas-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
        }

        /* Effective size display */
        .effective-size-display {
            background: #333;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .size-arrow {
            font-size: 1.5rem;
            color: #667eea;
        }
        .size-box {
            text-align: center;
        }
        .size-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: #fff;
        }
        .size-label {
            font-size: 0.75rem;
            color: #888;
        }

        /* YAML output */
        .yaml-output {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
            color: #a5d6ff;
        }
        .yaml-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        .tab {
            padding: 8px 16px;
            background: #333;
            border: none;
            border-radius: 6px 6px 0 0;
            color: #aaa;
            cursor: pointer;
            font-size: 14px;
        }
        .tab:hover { background: #3a3a3a; color: #fff; }
        .tab.active {
            background: #2a2a2a;
            color: #667eea;
            font-weight: 600;
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* Toggle */
        .toggle-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        .toggle-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* Hidden */
        .hidden { display: none !important; }

        /* Steps */
        .steps {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
        }
        .step {
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0.5;
        }
        .step.active, .step.completed { opacity: 1; }
        .step-number {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #444;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            margin-bottom: 5px;
        }
        .step.active .step-number { background: #667eea; }
        .step.completed .step-number { background: #10b981; }
        .step-label { font-size: 0.8rem; color: #888; }

        /* Collapsible */
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 10px 0;
        }
        .collapsible-header:hover { color: #667eea; }
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s;
        }
        .collapsible-content.expanded { max-height: 3000px; overflow: visible; }
        .chevron { transition: transform 0.3s; }
        .chevron.rotated { transform: rotate(180deg); }

        /* Tooltip */
        .tooltip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #444;
            color: #aaa;
            font-size: 10px;
            font-weight: 600;
            cursor: help;
            margin-left: 6px;
            position: relative;
            vertical-align: middle;
        }
        .tooltip:hover {
            background: #667eea;
            color: white;
        }
        .tooltip .tooltip-text {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a2e;
            color: #e8e8f0;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 400;
            width: 260px;
            max-width: 90vw;
            text-align: left;
            line-height: 1.5;
            z-index: 99999;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            border: 1px solid #3a3a5c;
            transition: opacity 0.2s, visibility 0.2s;
            white-space: normal;
            word-wrap: break-word;
            pointer-events: none;
        }
        .tooltip .tooltip-text::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #3a3a5c;
        }
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        /* Tooltip repositioning for elements near edges */
        .tooltip.tooltip-left .tooltip-text {
            left: auto;
            right: 0;
            transform: translateX(0);
        }
        .tooltip.tooltip-left .tooltip-text::after {
            left: auto;
            right: 10px;
            transform: none;
        }

        @media (max-width: 600px) {
            body { padding: 15px; }
            .grid-2, .grid-3, .model-type-grid { grid-template-columns: 1fr; }
            .steps { gap: 15px; flex-wrap: wrap; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SLEAP-NN Config Picker</h1>
        <p class="description">Upload your SLP file to get intelligent configuration recommendations for sleap-nn training.</p>

        <!-- Step indicator -->
        <div class="steps">
            <div class="step active" id="step1">
                <div class="step-number">1</div>
                <div class="step-label">Upload Data</div>
            </div>
            <div class="step" id="step2">
                <div class="step-number">2</div>
                <div class="step-label">Model Type</div>
            </div>
            <div class="step" id="step3">
                <div class="step-number">3</div>
                <div class="step-label">Parameters</div>
            </div>
            <div class="step" id="step4">
                <div class="step-number">4</div>
                <div class="step-label">Export</div>
            </div>
        </div>

        <!-- Step 1: Upload -->
        <div id="upload-section" class="card">
            <div class="card-header">
                <h2 class="card-title">Step 1: Upload SLP File</h2>
            </div>
            <div class="upload-zone" id="upload-zone">
                <input type="file" id="file-input" accept=".slp">
                <p style="margin: 0; font-size: 1.1rem;">Drop your .slp file here or click to browse</p>
                <p style="margin: 5px 0 0; color: #888; font-size: 0.9rem;">Supports SLEAP labels files (.slp)</p>
            </div>
            <div id="loading-status" class="hidden" style="text-align: center; padding: 20px;">
                <p>Loading SLP file...</p>
            </div>
            <!-- Video upload (shown after SLP is loaded) -->
            <div id="video-upload-section" class="hidden" style="margin-top: 15px;">
                <div class="info-box warning">
                    <strong>Video not embedded:</strong> Upload the video file to preview frames and visualize keypoints.
                </div>
                <div class="upload-zone" id="video-upload-zone" style="padding: 20px;">
                    <input type="file" id="video-input" accept="video/*,.mp4,.avi,.mov,.mkv">
                    <p style="margin: 0; font-size: 0.95rem;">Drop video file here or click to browse</p>
                    <p style="margin: 5px 0 0; color: #888; font-size: 0.8rem;">Supports .mp4, .avi, .mov, .mkv</p>
                </div>
            </div>

            <!-- Load existing config (shown after SLP is loaded) -->
            <div id="config-upload-section" class="hidden" style="margin-top: 15px;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                    <strong style="color: var(--text-dim);">Load Existing Config (Optional)</strong>
                </div>
                <!-- Centroid config -->
                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
                    <button class="secondary small" onclick="document.getElementById('centroid-config-input').click()" style="min-width: 140px;">
                        Centroid Config
                    </button>
                    <input type="file" id="centroid-config-input" accept=".yaml,.yml" style="display: none;">
                    <span id="centroid-config-name" style="color: var(--text-dim); font-size: 0.85rem;"></span>
                    <span id="centroid-config-badge" class="badge info hidden">Loaded</span>
                    <button id="clear-centroid-config-btn" class="small danger hidden" onclick="clearLoadedConfig('centroid')">Clear</button>
                </div>
                <!-- Centered Instance config -->
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button class="secondary small" onclick="document.getElementById('ci-config-input').click()" style="min-width: 140px;">
                        Centered Instance
                    </button>
                    <input type="file" id="ci-config-input" accept=".yaml,.yml" style="display: none;">
                    <span id="ci-config-name" style="color: var(--text-dim); font-size: 0.85rem;"></span>
                    <span id="ci-config-badge" class="badge info hidden">Loaded</span>
                    <button id="clear-ci-config-btn" class="small danger hidden" onclick="clearLoadedConfig('ci')">Clear</button>
                </div>
                <p style="margin: 8px 0 0; color: #888; font-size: 0.8rem;">
                    For Top-Down models, load both configs. For other models, either button works.
                </p>
            </div>
        </div>

        <!-- Data Summary with Frame Viewer -->
        <div id="data-summary" class="card hidden">
            <div class="card-header" style="cursor: pointer;" onclick="toggleCollapsible('data-summary-content')">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <h2 class="card-title">Data Summary</h2>
                    <span class="badge success" id="file-name-badge"></span>
                </div>
                <span class="chevron" id="data-summary-content-chevron">&#9660;</span>
            </div>
            <div class="collapsible-content expanded" id="data-summary-content">
                <!-- Frame Viewer -->
                <div class="frame-viewer" id="frame-viewer">
                    <canvas id="frame-canvas" class="frame-canvas"></canvas>
                    <div class="frame-controls">
                        <button class="small secondary" id="prev-frame-btn">&lt;</button>
                        <input type="range" id="frame-slider" class="frame-slider" min="0" max="0" value="0">
                        <button class="small secondary" id="next-frame-btn">&gt;</button>
                        <span class="frame-info" id="frame-info">Frame 0 / 0</span>
                    </div>
                </div>

                <div class="stats-grid" id="stats-grid"></div>
                <div id="skeleton-info" style="margin-top: 15px;"></div>
            </div>
        </div>

        <!-- Step 2: Model Type Selection -->
        <div id="model-type-section" class="card hidden">
            <div class="card-header" style="cursor: pointer;" onclick="toggleCollapsible('model-type-content')">
                <h2 class="card-title">Step 2: Select Model Type</h2>
                <span class="chevron" id="model-type-content-chevron">&#9660;</span>
            </div>
            <div class="collapsible-content expanded" id="model-type-content">
                <div id="model-recommendation" class="info-box success"></div>

                <div class="model-type-grid" id="model-type-grid"></div>

                <div id="topdown-info" class="info-box warning hidden">
                    <strong>Top-Down Pipeline:</strong> This requires training two models sequentially:
                    <ol style="margin: 10px 0 0; padding-left: 20px;">
                        <li><strong>Centroid Model</strong> - Detects animal centers in full images</li>
                        <li><strong>Centered Instance Model</strong> - Detects keypoints in cropped regions</li>
                    </ol>
                    You'll configure both models and get two YAML configs.
                </div>
            </div>
        </div>

        <!-- Step 3: Parameters -->
        <div id="parameters-section" class="card hidden">
            <div class="card-header">
                <h2 class="card-title">Step 3: Configure Parameters</h2>
            </div>

            <!-- Tabs for top-down models + Config Preview -->
            <div class="tabs" id="model-tabs">
                <button class="tab active" data-tab="centroid">Centroid Model</button>
                <button class="tab hidden" data-tab="centered-instance">Centered Instance Model</button>
                <button class="tab" data-tab="config-preview" style="margin-left: auto; background: #3a3a5c;">ðŸ“„ Config Preview</button>
            </div>

            <!-- Main config -->
            <div class="tab-content active" id="tab-main">
                <!-- Data Config -->
                <div class="collapsible-header" onclick="toggleCollapsible('data-config')">
                    <h3>Data Configuration</h3>
                    <span class="chevron" id="data-config-chevron">&#9660;</span>
                </div>
                <div class="collapsible-content expanded" id="data-config">
                    <div class="grid-3">
                        <div class="form-group">
                            <label>
                                Input Scale
                                <span class="tooltip">?
                                    <span class="tooltip-text">Factor to resize images before feeding to the model. Lower = faster training + larger effective receptive field. Higher = more detail preserved but slower. For Top-Down models, we default to 0.5 for the centroid model because it only needs to detect animal centers (single keypoint per animal), so high resolution is unnecessary and wastes compute.</span>
                                </span>
                            </label>
                            <input type="range" id="scale" min="0.125" max="1" step="0.125" value="1">
                            <div class="range-labels">
                                <span>0.125</span>
                                <span id="scale-value">1.0</span>
                                <span>1.0</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>
                                Validation Fraction
                                <span class="tooltip">?
                                    <span class="tooltip-text">Fraction of labeled frames held out for validation. Used to monitor training progress and for early stopping. 10-20% is typical. More data = can use smaller fraction.</span>
                                </span>
                            </label>
                            <input type="range" id="val-fraction" min="0.05" max="0.3" step="0.05" value="0.1">
                            <div class="range-labels">
                                <span>5%</span>
                                <span id="val-fraction-value">10%</span>
                                <span>30%</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>
                                Input Channels
                                <span class="tooltip">?
                                    <span class="tooltip-text">Number of color channels. Grayscale (1) is more efficient for single-channel videos. RGB (3) required for pretrained backbones.</span>
                                </span>
                            </label>
                            <select id="input-channels">
                                <option value="1">Grayscale (1 channel)</option>
                                <option value="3">RGB (3 channels)</option>
                            </select>
                        </div>
                    </div>
                    <div class="grid-2" style="margin-top: 10px;">
                        <div class="form-group">
                            <label>
                                Max Height
                                <span class="tooltip">?
                                    <span class="tooltip-text">Maximum height to resize/pad images to before scaling. Leave empty to use original image height. Applied before scale.</span>
                                </span>
                            </label>
                            <input type="number" id="max-height" placeholder="None (use original)" min="32" max="4096" step="16">
                        </div>
                        <div class="form-group">
                            <label>
                                Max Width
                                <span class="tooltip">?
                                    <span class="tooltip-text">Maximum width to resize/pad images to before scaling. Leave empty to use original image width. Applied before scale.</span>
                                </span>
                            </label>
                            <input type="number" id="max-width" placeholder="None (use original)" min="32" max="4096" step="16">
                        </div>
                    </div>

                    <!-- Effective Size Display -->
                    <div class="effective-size-display">
                        <div class="size-box">
                            <div class="size-value" id="original-size">1024x768</div>
                            <div class="size-label">Original Image</div>
                            <div class="size-detail" id="original-size-detail" style="font-size: 0.65rem; color: #666;">(max_height/max_width)</div>
                        </div>
                        <div class="size-arrow">â†’</div>
                        <div class="size-box">
                            <div class="size-value" id="effective-size">1024x768</div>
                            <div class="size-label">Input to Model</div>
                            <div class="size-detail" id="effective-size-detail" style="font-size: 0.65rem; color: #666;">(after scale)</div>
                        </div>
                        <div class="size-arrow">â†’</div>
                        <div class="size-box">
                            <div class="size-value" id="output-size">1024x768</div>
                            <div class="size-label">Model Output</div>
                            <div class="size-detail" id="output-size-detail" style="font-size: 0.65rem; color: #666;">(confmaps)</div>
                        </div>
                    </div>

                    <div class="toggle-group">
                        <input type="checkbox" id="use-augmentation">
                        <label for="use-augmentation" style="display: inline; margin: 0;">
                            Enable Data Augmentation
                            <span class="tooltip">?
                                <span class="tooltip-text">Data augmentation artificially expands your training data by applying random transformations (rotation, scaling, brightness changes, etc.) during training. This helps the model generalize better to new videos and reduces overfitting, especially with small datasets. Recommended for most training scenarios.</span>
                            </span>
                        </label>
                    </div>

                    <!-- Augmentation - Slider Layout (PR28 style) -->
                    <div id="aug-preview-section" class="hidden">
                        <div class="aug-container">
                            <!-- Left: Sliders -->
                            <div class="aug-sliders">
                                <h4>Geometric</h4>
                                <div class="slider-group">
                                    <div class="slider-header">
                                        <span class="slider-label">Rotation</span>
                                        <span class="slider-value" id="rotation-value">Â±15Â°</span>
                                    </div>
                                    <input type="range" id="aug-rotation-val" min="0" max="180" value="15" oninput="updateAugSliderValue('rotation')">
                                </div>
                                <div class="slider-group">
                                    <div class="slider-header">
                                        <span class="slider-label">Scale</span>
                                        <span class="slider-value" id="scale-aug-value">0.9 - 1.1</span>
                                    </div>
                                    <input type="range" id="aug-scale-val" min="0" max="50" value="10" oninput="updateAugSliderValue('scale')">
                                </div>
                                <div class="slider-group">
                                    <div class="slider-header">
                                        <span class="slider-label">Translate</span>
                                        <span class="slider-value" id="translate-value">0%</span>
                                    </div>
                                    <input type="range" id="aug-translate-val" min="0" max="30" value="0" oninput="updateAugSliderValue('translate')">
                                </div>

                                <h4>Intensity</h4>
                                <div class="slider-group">
                                    <div class="slider-header">
                                        <span class="slider-label">Brightness</span>
                                        <span class="slider-value" id="brightness-value">0%</span>
                                    </div>
                                    <input type="range" id="aug-brightness-val" min="0" max="50" value="0" oninput="updateAugSliderValue('brightness')">
                                </div>
                                <div class="slider-group">
                                    <div class="slider-header">
                                        <span class="slider-label">Contrast</span>
                                        <span class="slider-value" id="contrast-value">0%</span>
                                    </div>
                                    <input type="range" id="aug-contrast-val" min="0" max="50" value="0" oninput="updateAugSliderValue('contrast')">
                                </div>
                            </div>

                            <!-- Right: Preview -->
                            <div class="aug-preview-container">
                                <div class="aug-preview-pair">
                                    <div class="aug-preview-box">
                                        <canvas id="aug-original" width="150" height="150"></canvas>
                                        <div class="label">Original</div>
                                    </div>
                                    <div class="aug-preview-box">
                                        <canvas id="aug-preview" width="150" height="150"></canvas>
                                        <div class="label">Augmented</div>
                                    </div>
                                </div>
                                <button id="randomize-aug-btn" onclick="randomizeAugPreview()">Randomize</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Model Config -->
                <div class="collapsible-header" onclick="toggleCollapsible('model-config')">
                    <h3>Model Configuration</h3>
                    <span class="chevron" id="model-config-chevron">&#9660;</span>
                </div>
                <div class="collapsible-content expanded" id="model-config">
                    <!-- Receptive Field Note -->
                    <div class="info-box">
                        <strong>Receptive Field Tip:</strong> The receptive field (RF) determines how much context the model sees.
                        Adjust <strong>Input Scale</strong> and <strong>Max Stride</strong> so the RF covers approximately the size of one animal.
                        <ul style="margin: 5px 0 0; padding-left: 20px; font-size: 0.85rem;">
                            <li>Lower scale â†’ larger effective RF (good for large animals)</li>
                            <li>Higher max_stride â†’ larger RF but more parameters</li>
                        </ul>
                    </div>

                    <div class="grid-2">
                        <div class="form-group">
                            <label>
                                Backbone
                                <span class="tooltip">?
                                    <span class="tooltip-text">UNet is recommended for most cases. ConvNeXt/SwinT have pretrained weights but require RGB images and have fixed max_stride=32.</span>
                                </span>
                            </label>
                            <select id="backbone">
                                <option value="unet">UNet (Default)</option>
                                <option value="unet_medium_rf">UNet Medium RF</option>
                                <option value="unet_large_rf">UNet Large RF</option>
                                <option value="convnext_tiny">ConvNeXt Tiny (Pretrained, RGB)</option>
                                <option value="convnext_small">ConvNeXt Small (Pretrained, RGB)</option>
                                <option value="swint_tiny">SwinT Tiny (Pretrained, RGB)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>
                                Max Stride
                                <span class="tooltip">?
                                    <span class="tooltip-text">Determines network depth and receptive field. Higher = larger RF but more parameters and memory.</span>
                                </span>
                            </label>
                            <select id="max-stride">
                                <option value="8">8 (RF: ~36px, fast)</option>
                                <option value="16" selected>16 (RF: ~76px, balanced)</option>
                                <option value="32">32 (RF: ~156px, large context)</option>
                                <option value="64">64 (RF: ~316px, very large)</option>
                            </select>
                        </div>
                    </div>

                    <!-- Pretrained Weights (shown for ConvNeXt/SwinT) -->
                    <div id="pretrained-weights-section" class="hidden" style="margin-top: 10px;">
                        <div class="form-group" style="margin-bottom: 10px;">
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="use-imagenet-pretrained" checked style="width: auto;">
                                <span>Use ImageNet pretrained weights</span>
                                <span class="tooltip">?
                                    <span class="tooltip-text">Load weights pretrained on ImageNet. Recommended for most cases. Disable if you want to train from scratch or use custom weights.</span>
                                </span>
                            </label>
                        </div>
                        <div class="form-group">
                            <label>
                                Custom Backbone Weights (optional)
                                <span class="tooltip">?
                                    <span class="tooltip-text">Path to custom pretrained backbone weights (.ckpt file). If provided, these weights are loaded after ImageNet weights (fine-tuning) or as the only weights if ImageNet is disabled.</span>
                                </span>
                            </label>
                            <input type="text" id="pretrained-backbone-weights" placeholder="None (use ImageNet weights only)" style="width: 100%;">
                        </div>
                    </div>

                    <!-- Receptive Field Visualization with Image -->
                    <div class="rf-viz-container">
                        <canvas id="rf-canvas" class="rf-canvas"></canvas>
                        <div class="rf-info-overlay">
                            <div>RF: <strong id="rf-value">63</strong>px | Effective RF: <strong id="rf-effective">63</strong>px</div>
                            <div class="rf-legend">
                                <div class="rf-legend-item">
                                    <div class="rf-legend-box" style="border-color: #f43f5e;"></div>
                                    <span>Receptive Field</span>
                                </div>
                                <div class="rf-legend-item">
                                    <div class="rf-legend-box" style="border-color: #10b981;"></div>
                                    <span>Avg Animal Size</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Stride & Sigma Guide -->
                    <div class="collapsible-header" onclick="toggleCollapsible('stride-sigma-guide')" style="margin-top: 10px;">
                        <span style="font-size: 0.9rem; color: #888;">ðŸ“– Guide: Choosing Stride & Sigma</span>
                        <span class="chevron" id="stride-sigma-guide-chevron">&#9654;</span>
                    </div>
                    <div class="collapsible-content" id="stride-sigma-guide" style="background: #252525; border-radius: 6px;">
                        <div style="padding: 15px; font-size: 0.85rem;">
                            <div style="margin-bottom: 12px;">
                                <strong style="color: #667eea;">Output Stride</strong> (precision vs speed tradeoff)
                                <table style="width: 100%; margin-top: 8px; font-size: 0.8rem; border-collapse: collapse;">
                                    <tr style="border-bottom: 1px solid #444;">
                                        <th style="text-align: left; padding: 4px;">Stride</th>
                                        <th style="text-align: left; padding: 4px;">Resolution</th>
                                        <th style="text-align: left; padding: 4px;">Memory</th>
                                        <th style="text-align: left; padding: 4px;">Best For</th>
                                    </tr>
                                    <tr><td style="padding: 4px; color: #10b981;">1</td><td>Full</td><td>High</td><td>High precision (small keypoints)</td></tr>
                                    <tr><td style="padding: 4px; color: #f59e0b;">2</td><td>Half</td><td>Medium</td><td>Balanced (default for most)</td></tr>
                                    <tr><td style="padding: 4px; color: #f43f5e;">4</td><td>Quarter</td><td>Low</td><td>Large animals, fast training</td></tr>
                                </table>
                            </div>
                            <div style="margin-bottom: 12px;">
                                <strong style="color: #667eea;">Sigma</strong> (Gaussian spread for confidence maps)
                                <div style="margin-top: 8px; color: #aaa;">
                                    Rule of thumb: <code style="background: #333; padding: 2px 6px; border-radius: 3px;">sigma â‰ˆ keypoint_size / (2 Ã— output_stride)</code>
                                </div>
                                <table style="width: 100%; margin-top: 8px; font-size: 0.8rem; border-collapse: collapse;">
                                    <tr style="border-bottom: 1px solid #444;">
                                        <th style="text-align: left; padding: 4px;">Scenario</th>
                                        <th style="text-align: left; padding: 4px;">Recommended Ïƒ</th>
                                    </tr>
                                    <tr><td style="padding: 4px;">Small keypoints, high precision</td><td>1.5 - 2.5</td></tr>
                                    <tr><td style="padding: 4px;">Standard pose estimation</td><td>3.0 - 5.0</td></tr>
                                    <tr><td style="padding: 4px;">Large animals, easier training</td><td>5.0 - 7.5</td></tr>
                                </table>
                            </div>
                            <div style="background: #333; padding: 8px; border-radius: 4px; color: #aaa; font-size: 0.8rem;">
                                <strong>ðŸ’¡ Tips:</strong>
                                <ul style="margin: 5px 0 0; padding-left: 20px;">
                                    <li>If using output_stride > 1, reduce sigma proportionally</li>
                                    <li>When adjusting sigma at stride=2, use half the value you'd use at stride=1</li>
                                    <li>Start with defaults and adjust if keypoints are jittery (increase Ïƒ) or imprecise (decrease Ïƒ)</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="grid-3">
                        <div class="form-group">
                            <label>
                                Base Filters
                                <span class="tooltip">?
                                    <span class="tooltip-text">Number of filters in the first encoder block. Each subsequent block multiplies by filters_rate (1.5Ã—). More filters = more capacity but slower training and more memory. Start with 24-32 for most cases.</span>
                                </span>
                            </label>
                            <select id="filters">
                                <option value="16">16 (Light)</option>
                                <option value="24">24</option>
                                <option value="32" selected>32 (Default)</option>
                                <option value="48">48</option>
                                <option value="64">64 (Heavy)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>
                                Sigma
                                <span class="tooltip">?
                                    <span class="tooltip-text">Gaussian spread for keypoint heatmaps. Smaller = more precise but harder to train. Larger = easier but less precise.</span>
                                </span>
                            </label>
                            <input type="number" id="sigma" value="5.0" min="1" max="15" step="0.5" oninput="updateSigmaVisualization()">
                        </div>
                        <div class="form-group">
                            <label>
                                Output Stride
                                <span class="tooltip">?
                                    <span class="tooltip-text">Stride of output confidence maps relative to input. Stride=2 means 0.5Ã— resolution output. Higher values speed up training and reduce memory but decrease spatial precision.</span>
                                </span>
                            </label>
                            <select id="output-stride" onchange="updateSigmaVisualization()">
                                <option value="1">1 (Full res)</option>
                                <option value="2" selected>2 (Half res)</option>
                                <option value="4">4 (Quarter)</option>
                            </select>
                        </div>
                    </div>

                    <!-- PAF Settings (shown only for bottom-up models) -->
                    <div id="paf-sigma-section" class="hidden" style="margin-top: 10px; padding: 12px; background: #2a2a3e; border-radius: 6px;">
                        <h4 style="margin: 0 0 10px; color: #888; font-size: 0.85rem;">Part Affinity Fields (PAFs)</h4>
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">
                                    PAF Sigma
                                    <span class="tooltip">?<span class="tooltip-text">Gaussian width for PAFs. Controls the width of the vector field along skeleton edges. Smaller values (10-20) are more precise but harder to learn. Default: 15.0</span></span>
                                </label>
                                <input type="number" id="paf-sigma" value="15.0" min="5" max="50" step="1">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">
                                    PAF Output Stride
                                    <span class="tooltip">?<span class="tooltip-text">Stride of PAF output. Higher values reduce memory but decrease precision. Usually 2Ã— the confmaps stride.</span></span>
                                </label>
                                <select id="paf-output-stride">
                                    <option value="1">1 (Full res)</option>
                                    <option value="2">2 (Half res)</option>
                                    <option value="4" selected>4 (Quarter)</option>
                                </select>
                            </div>
                        </div>
                        <div class="grid-2" style="gap: 10px; margin-top: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">
                                    Confmaps Loss Weight
                                    <span class="tooltip">?<span class="tooltip-text">Loss weight for confidence maps. Default: 1.0</span></span>
                                </label>
                                <input type="number" id="confmaps-loss-weight" value="1.0" min="0.1" max="10" step="0.1">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">
                                    PAFs Loss Weight
                                    <span class="tooltip">?<span class="tooltip-text">Loss weight for PAFs. Increase to emphasize limb grouping accuracy. Default: 1.0</span></span>
                                </label>
                                <input type="number" id="paf-loss-weight" value="1.0" min="0.1" max="10" step="0.1">
                            </div>
                        </div>
                    </div>

                    <!-- Multi-Class Settings (shown for multi_class models) -->
                    <div id="multi-class-section" class="hidden" style="margin-top: 10px; padding: 12px; background: #2a2a3e; border-radius: 6px;">
                        <h4 style="margin: 0 0 10px; color: #888; font-size: 0.85rem;">Identity Classification</h4>
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">
                                    Confmaps Loss Weight
                                    <span class="tooltip">?<span class="tooltip-text">Loss weight for keypoint confidence maps. Default: 1.0</span></span>
                                </label>
                                <input type="number" id="mc-confmaps-loss-weight" value="1.0" min="0.1" max="10" step="0.1">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">
                                    Class Loss Weight
                                    <span class="tooltip">?<span class="tooltip-text">Loss weight for identity classification head. Default: 1.0</span></span>
                                </label>
                                <input type="number" id="class-loss-weight" value="1.0" min="0.1" max="10" step="0.1">
                            </div>
                        </div>
                        <div id="class-vectors-config" class="hidden" style="margin-top: 10px;">
                            <div class="grid-2" style="gap: 10px;">
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 0.8rem;">
                                        FC Layers
                                        <span class="tooltip">?<span class="tooltip-text">Number of fully connected layers before classification. Default: 1</span></span>
                                    </label>
                                    <input type="number" id="class-fc-layers" value="1" min="1" max="5" step="1">
                                </div>
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 0.8rem;">
                                        FC Units
                                        <span class="tooltip">?<span class="tooltip-text">Number of units in each FC layer. Default: 64</span></span>
                                    </label>
                                    <input type="number" id="class-fc-units" value="64" min="16" max="512" step="16">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Sigma Visualization -->
                    <div class="sigma-guide-card" style="background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 12px; margin: 15px 0;">
                        <div style="display: flex; align-items: flex-start; gap: 16px;">
                            <div style="flex: 1;">
                                <h4 style="margin: 0 0 8px; color: var(--text-dim); font-size: 0.85rem;">Gaussian Spread Guide</h4>
                                <div style="font-size: 0.8rem; color: var(--text-dim);">
                                    <div>Effective radius: <strong id="sigma-radius" style="color: var(--text);">10</strong>px (2Ïƒ covers 95%)</div>
                                    <div style="margin-top: 4px;" id="sigma-suggest">
                                        <span id="sigma-centroid-info" style="display: none;">Min distance between animal centroids: <strong id="min-centroid-dist">-</strong>px (keep Ïƒ &lt; <span id="suggested-sigma">-</span>px to avoid overlap between animals)</span>
                                        <span id="sigma-keypoint-info">Each keypoint has its own confidence map channel - no overlap concern between keypoints.</span>
                                    </div>
                                    <div style="margin-top: 4px; color: #888;" id="min-keypoint-dist-info">
                                        Min distance between connected keypoints: <strong id="min-keypoint-dist">-</strong>px (from skeleton edges)
                                    </div>
                                </div>
                            </div>
                            <div style="flex-shrink: 0;">
                                <canvas id="sigma-viz" width="70" height="70" style="border: 1px solid var(--border); border-radius: 6px; background: var(--bg);"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- Model Info Panel -->
                    <div class="model-info-panel">
                        <h4 style="margin: 0 0 10px; color: #ccc;">Model Architecture</h4>
                        <div class="model-params">
                            <div class="model-param-item">
                                <div class="model-param-value" id="total-params">~1.3M</div>
                                <div class="model-param-label">Total Parameters</div>
                            </div>
                            <div class="model-param-item">
                                <div class="model-param-value" id="down-blocks">4</div>
                                <div class="model-param-label">Encoder Blocks</div>
                            </div>
                            <div class="model-param-item">
                                <div class="model-param-value" id="up-blocks">4</div>
                                <div class="model-param-label">Decoder Blocks</div>
                            </div>
                        </div>
                        <!-- Model Input Size with padding info -->
                        <div id="model-input-size-info" style="margin-top: 10px; background: #252525; padding: 10px; border-radius: 6px; font-size: 0.85rem;">
                            <div style="color: #888; margin-bottom: 5px;">Model Input Size:</div>
                            <div id="input-size-display" style="color: #e0e0e0;">
                                <span id="input-size-scaled">-</span>
                                <span style="color: #888;"> â†’ </span>
                                <span id="input-size-padded" style="color: #10b981;">-</span>
                                <span style="color: #888; font-size: 0.75rem;"> (padded)</span>
                            </div>
                            <div style="color: #666; font-size: 0.75rem; margin-top: 5px;">
                                <span class="tooltip" style="cursor: help;">â„¹ï¸ Why padding?
                                    <span class="tooltip-text">Images are padded to be divisible by max_stride. This is required because UNet uses repeated 2Ã— downsampling/upsampling, so dimensions must be divisible by 2^num_blocks to avoid size mismatches between encoder and decoder outputs.</span>
                                </span>
                            </div>
                        </div>
                        <details style="margin-top: 10px;">
                            <summary style="cursor: pointer; font-size: 0.85rem; color: var(--accent); font-weight: 500;">View UNet Architecture</summary>
                            <div class="arch-diagram" id="arch-diagram" style="margin-top: 8px;">
Input â†’ [Encoder] â†’ [Middle] â†’ [Decoder] â†’ Head â†’ Output
                            </div>
                        </details>
                    </div>

                    <!-- Anchor Point Selector (for centroid/centered_instance) -->
                    <div class="anchor-selector hidden" id="anchor-selector">
                        <h4 style="margin: 0 0 10px; color: #ccc;">
                            Anchor Part
                            <span class="tooltip">?
                                <span class="tooltip-text">The anchor part is used to center the crop around each instance. Choose a body part that is consistently visible and near the center of the animal. The percentage shows how often each keypoint is labeled (not NaN) across all instances.</span>
                            </span>
                        </h4>
                        <p style="font-size: 0.85rem; color: #888; margin: 0 0 10px;">Click a keypoint on the skeleton to select it as anchor. The percentage shows visibility (% of labeled/non-NaN instances):</p>
                        <div class="anchor-preview">
                            <div style="position: relative;">
                                <canvas id="anchor-preview-canvas" class="anchor-preview-canvas" width="280" height="240"></canvas>
                                <div id="anchor-canvas-tooltip" class="anchor-canvas-tooltip" style="display: none;"></div>
                            </div>
                            <div>
                                <div class="anchor-list" id="anchor-list">
                                    <!-- Populated by JS -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Pretrained Checkpoints -->
                    <div class="toggle-group" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border);">
                        <input type="checkbox" id="load-pretrained-ckpts">
                        <label for="load-pretrained-ckpts" style="display: inline; margin: 0;">
                            Load Pretrained Checkpoints
                            <span class="tooltip">?
                                <span class="tooltip-text">Load weights from previously trained models to fine-tune or resume training.<br><br><b>Backbone weights:</b> Load encoder/decoder weights from a prior model (useful for transfer learning).<br><br><b>Head weights:</b> Load the prediction head weights (useful when fine-tuning on similar data).</span>
                            </span>
                        </label>
                    </div>
                    <div id="pretrained-ckpts-options" class="hidden" style="margin-left: 25px; padding: 15px; background: #333; border-radius: 6px; margin-top: 10px;">
                        <div class="form-group" style="margin: 0 0 10px;">
                            <label style="font-size: 0.85rem;">
                                Pretrained Backbone Weights
                                <span class="tooltip">?
                                    <span class="tooltip-text">Path to a .ckpt file containing backbone (encoder/decoder) weights. The model architecture must match. Leave empty to train from scratch.</span>
                                </span>
                            </label>
                            <input type="text" id="pretrained-backbone-path" placeholder="e.g., ./models/prev_run/best.ckpt">
                        </div>
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 0.85rem;">
                                Pretrained Head Weights
                                <span class="tooltip">?
                                    <span class="tooltip-text">Path to a .ckpt file containing head (prediction layer) weights. Useful when fine-tuning on data with the same skeleton. Leave empty to initialize randomly.</span>
                                </span>
                            </label>
                            <input type="text" id="pretrained-head-path" placeholder="e.g., ./models/prev_run/best.ckpt">
                        </div>
                    </div>
                </div>

                <!-- Trainer Config -->
                <div class="collapsible-header" onclick="toggleCollapsible('trainer-config')">
                    <h3>Training Configuration</h3>
                    <span class="chevron" id="trainer-config-chevron">&#9660;</span>
                </div>
                <div class="collapsible-content expanded" id="trainer-config">
                    <!-- Additional Parameters Toggle -->
                    <div class="toggle-group">
                        <input type="checkbox" id="show-additional-params">
                        <label for="show-additional-params" style="display: inline; margin: 0;">
                            Additional Parameters
                            <span class="tooltip">?
                                <span class="tooltip-text">Advanced training parameters. The defaults work well for most cases, but you can customize batch size, learning rate, optimizer, and other settings here.</span>
                            </span>
                        </label>
                    </div>
                    <div id="additional-params-options" class="hidden" style="margin-left: 25px; padding: 15px; background: #333; border-radius: 6px; margin-top: 10px; margin-bottom: 15px;">
                    <div class="grid-3">
                        <div class="form-group">
                            <label>
                                Batch Size
                                <span class="tooltip">?
                                    <span class="tooltip-text">Number of samples per training batch. Larger batches train faster but use more GPU memory. If you get OOM errors, reduce batch size first. 4-8 is typical for 8GB GPUs.</span>
                                </span>
                            </label>
                            <select id="batch-size">
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="4" selected>4</option>
                                <option value="8">8</option>
                                <option value="16">16</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>
                                Max Epochs
                                <span class="tooltip">?
                                    <span class="tooltip-text">Maximum training epochs. Training may stop earlier if early stopping is enabled. 100-200 epochs is typical. More complex datasets may need more epochs.</span>
                                </span>
                            </label>
                            <input type="number" id="max-epochs" value="200" min="10" max="1000">
                        </div>
                        <div class="form-group">
                            <label>
                                Learning Rate
                                <span class="tooltip">?
                                    <span class="tooltip-text">Initial learning rate for the optimizer. Lower values train more slowly but may converge better. 1e-4 is a good default. Use schedulers to reduce LR during training.</span>
                                </span>
                            </label>
                            <select id="learning-rate">
                                <option value="0.0001" selected>1e-4 (Default)</option>
                                <option value="0.0005">5e-4</option>
                                <option value="0.001">1e-3</option>
                            </select>
                        </div>
                    </div>
                    <div class="grid-2">
                        <div class="form-group">
                            <label>
                                Optimizer
                                <span class="tooltip">?
                                    <span class="tooltip-text">Adam is the standard choice. AdamW adds weight decay regularization which can help prevent overfitting on small datasets.</span>
                                </span>
                            </label>
                            <select id="optimizer">
                                <option value="Adam" selected>Adam</option>
                                <option value="AdamW">AdamW</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>
                                Accelerator
                                <span class="tooltip">?
                                    <span class="tooltip-text">Hardware to use for training. "Auto" detects available hardware automatically. Use "GPU" for NVIDIA GPUs, "MPS" for Apple Silicon Macs, or "CPU" for CPU-only training (slow).</span>
                                </span>
                            </label>
                            <select id="accelerator">
                                <option value="auto" selected>Auto</option>
                                <option value="gpu">GPU</option>
                                <option value="mps">MPS (Apple Silicon)</option>
                                <option value="cpu">CPU</option>
                            </select>
                        </div>
                    </div>
                    <div class="toggle-group">
                        <input type="checkbox" id="early-stopping" checked onchange="toggleEarlyStoppingOptions()">
                        <label for="early-stopping" style="display: inline; margin: 0;">Enable Early Stopping
                            <span class="tooltip">?
                                <span class="tooltip-text">Stops training automatically when validation loss stops improving, preventing overfitting and wasted compute. Recommended for most training scenarios.</span>
                            </span>
                        </label>
                    </div>
                    <div id="early-stopping-options" class="toggle-options" style="margin-left: 25px; padding: 10px; background: #333; border-radius: 6px; font-size: 0.85rem;">
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Patience (epochs)
                                    <span class="tooltip">?<span class="tooltip-text">Number of epochs to wait for improvement before stopping. Higher values allow more time for the model to recover from plateaus but risk overfitting.</span></span>
                                </label>
                                <input type="number" id="es-patience" value="5" min="1" max="50" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Min Delta
                                    <span class="tooltip">?<span class="tooltip-text">Minimum change in validation loss to qualify as an improvement. Very small values (1e-6 to 1e-8) ensure training continues until truly converged.</span></span>
                                </label>
                                <input type="number" id="es-min-delta" value="0.000001" min="0" step="0.000001" style="padding: 6px;">
                            </div>
                        </div>
                    </div>

                    <div class="grid-2">
                        <div class="form-group">
                            <label>
                                Min Steps/Epoch
                                <span class="tooltip">?
                                    <span class="tooltip-text">Minimum training steps per epoch. Useful for small datasets to ensure enough gradient updates.</span>
                                </span>
                            </label>
                            <input type="number" id="min-steps" value="200" min="10" max="1000">
                        </div>
                        <div class="form-group">
                            <label>
                                Random Seed
                                <span class="tooltip">?
                                    <span class="tooltip-text">Seed for reproducibility. Leave empty for random initialization.</span>
                                </span>
                            </label>
                            <input type="number" id="random-seed" placeholder="None (random)">
                        </div>
                    </div>

                    <h4 style="margin: 15px 0 10px; color: #888; font-size: 0.9rem;">Learning Rate Scheduler
                        <span class="tooltip">?
                            <span class="tooltip-text">Adjusts the learning rate during training to improve convergence. A well-tuned scheduler can significantly improve final model accuracy.</span>
                        </span>
                    </h4>
                    <div class="grid-2">
                        <div class="form-group">
                            <label>
                                Scheduler Type
                                <span class="tooltip">?
                                    <span class="tooltip-text"><b>Reduce on Plateau:</b> Automatically reduces LR when validation loss stops improving. Best for most cases.<br><br><b>Cosine Annealing + Warmup:</b> Linear warmup then cosine decay to minimum LR. Good for longer training runs.<br><br><b>Linear Warmup + Decay:</b> Linear warmup then linear decay. Simple and effective.<br><br><b>Step LR:</b> Reduces LR by a fixed factor every N epochs. More predictable but requires tuning.<br><br><b>None:</b> Constant learning rate throughout training.</span>
                                </span>
                            </label>
                            <select id="lr-scheduler" onchange="updateSchedulerOptions()">
                                <option value="reduce_on_plateau" selected>Reduce on Plateau</option>
                                <option value="cosine_annealing_warmup">Cosine Annealing + Warmup</option>
                                <option value="linear_warmup_linear_decay">Linear Warmup + Decay</option>
                                <option value="step_lr">Step LR</option>
                                <option value="none">None (Constant)</option>
                            </select>
                        </div>
                        <div class="form-group" id="lr-patience-group">
                            <label>
                                Patience
                                <span class="tooltip">?
                                    <span class="tooltip-text">Epochs without improvement before reducing LR (for Reduce on Plateau) or early stopping.</span>
                                </span>
                            </label>
                            <input type="number" id="lr-patience" value="5" min="1" max="50">
                        </div>
                    </div>
                    <!-- Step LR options (shown when Step LR is selected) -->
                    <div id="step-lr-options" class="toggle-options" style="padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: none; margin-bottom: 10px;">
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Step Size (epochs)
                                    <span class="tooltip">?<span class="tooltip-text">Learning rate is reduced every N epochs. Default: 10</span></span>
                                </label>
                                <input type="number" id="step-lr-step-size" value="10" min="1" max="100" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Gamma (decay factor)
                                    <span class="tooltip">?<span class="tooltip-text">Multiply LR by this factor at each step. Default: 0.1 (reduce to 10%)</span></span>
                                </label>
                                <input type="number" id="step-lr-gamma" value="0.1" min="0.01" max="1" step="0.01" style="padding: 6px;">
                            </div>
                        </div>
                    </div>
                    <!-- Cosine Annealing + Warmup options -->
                    <div id="cosine-warmup-options" class="toggle-options" style="padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: none; margin-bottom: 10px;">
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Warmup Epochs
                                    <span class="tooltip">?<span class="tooltip-text">Number of epochs for linear warmup phase. LR increases from warmup_start_lr to base LR. Default: 5</span></span>
                                </label>
                                <input type="number" id="cosine-warmup-epochs" value="5" min="0" max="50" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Warmup Start LR
                                    <span class="tooltip">?<span class="tooltip-text">Learning rate at the start of warmup. Default: 0 (start from zero)</span></span>
                                </label>
                                <input type="number" id="cosine-warmup-start-lr" value="0" min="0" max="0.01" step="1e-6" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Min LR (eta_min)
                                    <span class="tooltip">?<span class="tooltip-text">Minimum learning rate at the end of cosine decay. Default: 0</span></span>
                                </label>
                                <input type="number" id="cosine-eta-min" value="0" min="0" max="0.01" step="1e-6" style="padding: 6px;">
                            </div>
                        </div>
                    </div>
                    <!-- Linear Warmup + Linear Decay options -->
                    <div id="linear-warmup-decay-options" class="toggle-options" style="padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: none; margin-bottom: 10px;">
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Warmup Epochs
                                    <span class="tooltip">?<span class="tooltip-text">Number of epochs for linear warmup phase. LR increases from warmup_start_lr to base LR. Default: 5</span></span>
                                </label>
                                <input type="number" id="linear-warmup-epochs" value="5" min="0" max="50" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Warmup Start LR
                                    <span class="tooltip">?<span class="tooltip-text">Learning rate at the start of warmup. Default: 0 (start from zero)</span></span>
                                </label>
                                <input type="number" id="linear-warmup-start-lr" value="0" min="0" max="0.01" step="1e-6" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">End LR
                                    <span class="tooltip">?<span class="tooltip-text">Learning rate at the end of training after linear decay. Default: 0</span></span>
                                </label>
                                <input type="number" id="linear-end-lr" value="0" min="0" max="0.01" step="1e-6" style="padding: 6px;">
                            </div>
                        </div>
                    </div>
                    <!-- Reduce on Plateau options (shown when ReduceLROnPlateau is selected) -->
                    <div id="reduce-lr-options" class="toggle-options" style="padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: block; margin-bottom: 10px;">
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Factor
                                    <span class="tooltip">?<span class="tooltip-text">Factor by which to reduce LR when plateau detected. Default: 0.5</span></span>
                                </label>
                                <input type="number" id="reduce-lr-factor" value="0.5" min="0.01" max="1" step="0.1" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Min LR
                                    <span class="tooltip">?<span class="tooltip-text">Minimum learning rate. Default: 1e-8</span></span>
                                </label>
                                <input type="number" id="reduce-lr-min" value="1e-8" min="0" max="0.01" step="1e-9" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Cooldown
                                    <span class="tooltip">?<span class="tooltip-text">Number of epochs to wait before resuming normal operation after LR has been reduced. Default: 3</span></span>
                                </label>
                                <input type="number" id="reduce-lr-cooldown" value="3" min="0" max="20" step="1" style="padding: 6px;">
                            </div>
                        </div>
                    </div>
                    </div>
                    <div class="toggle-group">
                        <input type="checkbox" id="save-ckpt" checked onchange="toggleSaveCkptOptions()">
                        <label for="save-ckpt" style="display: inline; margin: 0;">Save Checkpoints</label>
                    </div>
                    <div id="save-ckpt-options" class="toggle-options" style="margin-left: 25px; padding: 10px; background: #333; border-radius: 6px; font-size: 0.85rem;">
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Checkpoint Directory
                                    <span class="tooltip">?<span class="tooltip-text">Directory where the run folder will be created. Default: ./models</span></span>
                                </label>
                                <input type="text" id="ckpt-dir" value="./models" placeholder="./models" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Run Name
                                    <span class="tooltip">?<span class="tooltip-text">Name for this training run. Leave empty to auto-generate from timestamp + head type.</span></span>
                                </label>
                                <input type="text" id="run-name" placeholder="Auto (timestamp_head)" style="padding: 6px;">
                            </div>
                        </div>
                        <div class="grid-2" style="gap: 10px; margin-top: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Save Top K
                                    <span class="tooltip">?<span class="tooltip-text">Number of best checkpoints to save based on validation loss. Set to -1 to save all.</span></span>
                                </label>
                                <input type="number" id="ckpt-save-top-k" value="1" min="-1" max="10" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">
                                    <input type="checkbox" id="ckpt-save-last" checked style="margin-right: 5px;">
                                    Save Last Checkpoint
                                </label>
                            </div>
                        </div>
                        <div class="form-group" style="margin: 10px 0 0;">
                            <label style="font-size: 0.8rem;">Resume from Checkpoint
                                <span class="tooltip">?<span class="tooltip-text">Path to a checkpoint file (.ckpt) to resume training from. Leave empty to start fresh.</span></span>
                            </label>
                            <input type="text" id="resume-ckpt-path" placeholder="None (start fresh)" style="padding: 6px; width: 100%;">
                        </div>
                    </div>

                    <!-- Advanced Training Options (no longer hidden behind toggle) -->
                    <div id="advanced-options" style="margin-top: 15px;">
                        <h4 style="margin: 0 0 15px; color: #888; font-size: 0.9rem;">Additional Settings</h4>

                        <!-- Memory Cache Estimate Card -->
                        <div id="cache-memory-card" class="card" style="padding: 12px; margin-bottom: 15px; background: #222; border: 1px solid var(--border); display: none;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-weight: 600; color: #ccc;">ðŸ’¾ Image Cache Memory</span>
                                <span id="cache-memory-status" class="badge" style="padding: 4px 10px; border-radius: 4px; font-size: 0.75rem;">-</span>
                            </div>
                            <div style="font-size: 0.85rem; color: #888;">
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                    <div>Raw image data:</div>
                                    <div id="cache-raw-size" style="text-align: right; color: #ccc;">-</div>
                                    <div>With overhead (1.2Ã—):</div>
                                    <div id="cache-total-size" style="text-align: right; color: #ccc;">-</div>
                                    <div id="cache-workers-row" style="display: none;">Per-worker replication:</div>
                                    <div id="cache-workers-size" style="text-align: right; color: #ccc; display: none;">-</div>
                                </div>
                                <div id="cache-memory-note" style="margin-top: 8px; padding: 8px; background: rgba(234, 179, 8, 0.1); border-radius: 4px; font-size: 0.8rem; display: none;">
                                    âš ï¸ With memory caching + num_workers > 0, each worker gets a copy of the cache.
                                </div>
                            </div>
                        </div>

                        <div class="info-box" style="background: rgba(16, 185, 129, 0.15); border-color: #10b981; margin-bottom: 10px;">
                            <strong>Speed Tip:</strong> To improve training speed, set <strong>Num Workers</strong> to 2+ and change <strong>Data Pipeline</strong> to "Cache to Memory" or "Cache to Disk".
                        </div>
                        <div class="grid-2">
                            <div class="form-group">
                                <label>
                                    Num Workers
                                    <span class="tooltip">?
                                        <span class="tooltip-text">Number of parallel processes for loading data.<br><br><b>0 (Default):</b> Required when using torch_dataset (reading directly from video). This is the recommended setting.<br><br><b>>0:</b> Only use with caching pipelines (cache_img_memory/disk). More workers can speed up training but use more RAM.<br><br><b>Note:</b> On Mac/Windows, only use >0 with caching enabled.</span>
                                    </span>
                                </label>
                                <select id="num-workers" onchange="updateCacheMemoryEstimate()">
                                    <option value="0" selected>0 (Default)</option>
                                    <option value="2">2</option>
                                    <option value="4">4</option>
                                    <option value="8">8</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>
                                    Data Pipeline
                                    <span class="tooltip">?
                                        <span class="tooltip-text">How data is loaded. torch_dataset loads directly from video. Caching options preload images to memory or disk for faster training.</span>
                                    </span>
                                </label>
                                <select id="data-pipeline" onchange="updateCacheMemoryEstimate()">
                                    <option value="torch_dataset" selected>torch_dataset (Default)</option>
                                    <option value="torch_dataset_cache_img_memory">Cache to Memory</option>
                                    <option value="torch_dataset_cache_img_disk">Cache to Disk</option>
                                </select>
                            </div>
                        </div>

                        <h4 style="margin: 15px 0 10px; color: #888; font-size: 0.9rem;">Hard Keypoint Mining</h4>
                        <div class="toggle-group">
                            <input type="checkbox" id="enable-ohkm" onchange="toggleOhkmOptions()">
                            <label for="enable-ohkm" style="display: inline; margin: 0;">
                                Enable OHKM
                                <span class="tooltip">?
                                    <span class="tooltip-text">Online Hard Keypoint Mining focuses training on difficult keypoints. Can improve accuracy for challenging body parts.</span>
                                </span>
                            </label>
                        </div>
                        <div id="ohkm-options" class="toggle-options" style="margin-left: 25px; padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: none;">
                            <div class="grid-2" style="gap: 10px;">
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 0.8rem;">Hard-to-Easy Ratio
                                        <span class="tooltip">?<span class="tooltip-text">Min ratio of keypoint loss vs lowest loss to be considered "hard". Higher = stricter threshold. Default: 2.0</span></span>
                                    </label>
                                    <input type="number" id="ohkm-ratio" value="2.0" min="1" max="10" step="0.1" style="padding: 6px;">
                                </div>
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 0.8rem;">Loss Scale
                                        <span class="tooltip">?<span class="tooltip-text">Factor to scale hard keypoint losses. Higher = more focus on hard parts. Default: 5.0</span></span>
                                    </label>
                                    <input type="number" id="ohkm-loss-scale" value="5.0" min="1" max="20" step="0.5" style="padding: 6px;">
                                </div>
                            </div>
                            <div class="grid-2" style="gap: 10px; margin-top: 10px;">
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 0.8rem;">Min Hard Keypoints
                                        <span class="tooltip">?<span class="tooltip-text">Min keypoints considered "hard" even if below ratio threshold. Default: 2</span></span>
                                    </label>
                                    <input type="number" id="ohkm-min-hard" value="2" min="1" max="20" step="1" style="padding: 6px;">
                                </div>
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 0.8rem;">Max Hard Keypoints
                                        <span class="tooltip">?<span class="tooltip-text">Max keypoints to apply hard scaling to. Leave empty for no limit.</span></span>
                                    </label>
                                    <input type="number" id="ohkm-max-hard" placeholder="None" min="1" max="100" step="1" style="padding: 6px;">
                                </div>
                            </div>
                        </div>

                        <h4 style="margin: 15px 0 10px; color: #888; font-size: 0.9rem;">Logging</h4>
                        <div class="toggle-group">
                            <input type="checkbox" id="enable-wandb" onchange="toggleWandbOptions()">
                            <label for="enable-wandb" style="display: inline; margin: 0;">
                                Enable Weights & Biases Logging
                                <span class="tooltip">?
                                    <span class="tooltip-text">Log training metrics, visualizations, and model checkpoints to Weights & Biases (wandb.ai). Great for tracking experiments and comparing runs. Requires a free WandB account.</span>
                                </span>
                            </label>
                        </div>
                        <div id="wandb-options" class="toggle-options" style="margin-left: 25px; padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: none;">
                            <div class="grid-2" style="gap: 10px;">
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 0.8rem;">Entity (optional)
                                        <span class="tooltip">?<span class="tooltip-text">Your WandB username or team name</span></span>
                                    </label>
                                    <input type="text" id="wandb-entity" placeholder="your-username" style="padding: 6px;">
                                </div>
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 0.8rem;">Project
                                        <span class="tooltip">?<span class="tooltip-text">WandB project name to log to</span></span>
                                    </label>
                                    <input type="text" id="wandb-project" placeholder="sleap-training" style="padding: 6px;">
                                </div>
                            </div>
                            <div class="grid-2" style="gap: 10px; margin-top: 10px;">
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 0.8rem;">Run Name (optional)
                                        <span class="tooltip">?<span class="tooltip-text">Custom name for this run in WandB. Leave empty to use auto-generated name.</span></span>
                                    </label>
                                    <input type="text" id="wandb-name" placeholder="Auto" style="padding: 6px;">
                                </div>
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 0.8rem;">Mode
                                        <span class="tooltip">?<span class="tooltip-text">Online syncs to WandB servers. Offline logs locally only.</span></span>
                                    </label>
                                    <select id="wandb-mode" style="padding: 6px;">
                                        <option value="" selected>Online (default)</option>
                                        <option value="offline">Offline</option>
                                    </select>
                                </div>
                            </div>
                            <div class="form-group" style="margin: 10px 0 0;">
                                <label style="font-size: 0.8rem;">API Key (optional)
                                    <span class="tooltip">?<span class="tooltip-text">WandB API key for authentication. Leave empty to use environment variable WANDB_API_KEY or ~/.netrc credentials. The key is masked when saved to config files.</span></span>
                                </label>
                                <input type="password" id="wandb-api-key" placeholder="Leave empty to use env var" style="padding: 6px; width: 100%;">
                            </div>
                            <div style="margin-top: 10px;">
                                <label style="font-size: 0.8rem;">
                                    <input type="checkbox" id="wandb-viz-enabled" checked style="margin-right: 5px;">
                                    Log prediction visualizations
                                    <span class="tooltip">?<span class="tooltip-text">Log pre-rendered matplotlib images to WandB</span></span>
                                </label>
                            </div>
                            <div style="margin-top: 5px;">
                                <label style="font-size: 0.8rem;">
                                    <input type="checkbox" id="wandb-save-viz" style="margin-right: 5px;">
                                    Upload local viz images to WandB
                                    <span class="tooltip">?<span class="tooltip-text">Upload images saved to local viz folder to WandB</span></span>
                                </label>
                            </div>
                        </div>
                        <div class="toggle-group">
                            <input type="checkbox" id="enable-viz" onchange="toggleVizOptions()">
                            <label for="enable-viz" style="display: inline; margin: 0;">
                                Save Prediction Visualizations
                            </label>
                        </div>
                        <div id="viz-options" class="toggle-options" style="margin-left: 25px; padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: none;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">
                                    <input type="checkbox" id="viz-keep-folder" style="margin-right: 5px;">
                                    Keep viz folder after training
                                    <span class="tooltip">?<span class="tooltip-text">If unchecked, the visualization folder is deleted after training completes.</span></span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Evaluation (OKS metrics during training) -->
                    <div style="margin-top: 15px;">
                        <div class="toggle-group">
                            <input type="checkbox" id="enable-eval" onchange="toggleEvalOptions()">
                            <label for="enable-eval" style="display: inline; margin: 0;">Enable OKS Evaluation
                                <span class="tooltip">?
                                    <span class="tooltip-text">Run Object Keypoint Similarity (OKS) evaluation during training. OKS measures pose estimation accuracy accounting for keypoint scale. Adds compute overhead but provides useful metrics.</span>
                                </span>
                            </label>
                        </div>
                        <div id="eval-options" class="toggle-options" style="margin-left: 25px; padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: none; margin-top: 10px;">
                            <div class="grid-2" style="gap: 10px;">
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 0.8rem;">Frequency (epochs)
                                        <span class="tooltip">?<span class="tooltip-text">Run evaluation every N epochs. Higher frequency = more metrics but slower training.</span></span>
                                    </label>
                                    <input type="number" id="eval-frequency" value="1" min="1" max="50" style="padding: 6px;">
                                </div>
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 0.8rem;">OKS Stddev
                                        <span class="tooltip">?<span class="tooltip-text">Standard deviation for OKS Gaussian. Smaller = stricter matching. Default: 0.025</span></span>
                                    </label>
                                    <input type="number" id="eval-oks-stddev" value="0.025" min="0.001" max="0.5" step="0.005" style="padding: 6px;">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- GPU Memory Estimation -->
                    <div class="memory-card" id="gpu-memory-card">
                        <div class="memory-header">
                            <div>
                                <span style="font-size: 0.85rem; color: #888;">Estimated GPU Memory</span>
                                <span class="tooltip">?
                                    <span class="tooltip-text">Rough estimate based on batch size, image dimensions, model architecture. Actual usage varies by GPU and framework.</span>
                                </span>
                                <div id="mem-model-type" style="font-size: 0.7rem; color: #667eea; margin-top: 2px;">Single Instance</div>
                            </div>
                            <div class="memory-total" id="memory-total">~2.0 GB</div>
                        </div>
                        <div class="memory-breakdown">
                            <div class="memory-item">
                                <span class="memory-item-label">Model Params</span>
                                <span class="memory-item-value" id="mem-params">~1.1M</span>
                            </div>
                            <div class="memory-item">
                                <span class="memory-item-label">Weights</span>
                                <span class="memory-item-value" id="mem-weights">~4 MB</span>
                            </div>
                            <div class="memory-item">
                                <span class="memory-item-label">Batch Images</span>
                                <span class="memory-item-value" id="mem-batch-img">~16 MB</span>
                            </div>
                            <div class="memory-item">
                                <span class="memory-item-label">Feature Maps</span>
                                <span class="memory-item-value" id="mem-activations">~512 MB</span>
                            </div>
                            <div class="memory-item">
                                <span class="memory-item-label" id="mem-output-label">Conf Maps</span>
                                <span class="memory-item-value" id="mem-confmaps">~64 MB</span>
                            </div>
                            <div class="memory-item">
                                <span class="memory-item-label">Gradients</span>
                                <span class="memory-item-value" id="mem-gradients">~1.0 GB</span>
                            </div>
                        </div>
                        <div class="memory-status ok" id="memory-status">
                            Should fit on most GPUs (8GB+)
                        </div>
                    </div>
                </div>
            </div>

            <!-- Centered Instance config (for top-down) -->
            <div class="tab-content" id="tab-centered-instance">
                <div class="info-box">
                    Configure the <strong>Centered Instance</strong> model that detects keypoints in cropped regions around each detected centroid.
                    The anchor point is inherited from the Centroid model configuration.
                </div>

                <!-- Crop Configuration (collapsible) -->
                <div class="collapsible-header" onclick="toggleCollapsible('ci-crop-config')">
                    <h3>Crop Configuration</h3>
                    <span class="chevron" id="ci-crop-config-chevron">&#9660;</span>
                </div>
                <div class="collapsible-content expanded" id="ci-crop-config">
                <div class="grid-2">
                    <div class="form-group">
                        <label>
                            Crop Size (px)
                            <span class="tooltip">?
                                <span class="tooltip-text">Size of the square crop around each instance. Should be larger than the largest animal (~1.5Ã— max instance size). Automatically rounded to be divisible by max_stride. Leave empty for auto-calculation.</span>
                            </span>
                        </label>
                        <input type="number" id="crop-size" placeholder="Auto (from bbox)">
                        <div id="crop-size-suggestion" style="font-size: 0.75rem; color: #888; margin-top: 4px;"></div>
                    </div>
                    <div class="form-group">
                        <label>
                            Input Scale
                            <span class="tooltip">?
                                <span class="tooltip-text">Factor to resize cropped images. Unlike the centroid model, crops are typically small so scale=1.0 is common. Lower values reduce memory but lose detail.</span>
                            </span>
                        </label>
                        <input type="range" id="ci-scale" min="0.5" max="1" step="0.125" value="1">
                        <div class="range-labels">
                            <span>0.5</span>
                            <span id="ci-scale-value">1.0</span>
                            <span>1.0</span>
                        </div>
                    </div>
                </div>
                <div class="grid-2">
                    <div class="form-group">
                        <label>
                            Min Crop Size (px)
                            <span class="tooltip">?
                                <span class="tooltip-text">Minimum crop size to use if crop_size is auto-calculated. Ensures crops are never smaller than this value. Default: 100px.</span>
                            </span>
                        </label>
                        <input type="number" id="ci-min-crop-size" value="100" min="32" max="512" step="8">
                    </div>
                    <div class="form-group">
                        <label>
                            Crop Padding (px)
                            <span class="tooltip">?
                                <span class="tooltip-text">Extra padding around the instance bounding box when auto-calculating crop size. If empty, padding is auto-computed based on augmentation settings (rotation/scale expansion). Only used when crop_size is auto.</span>
                            </span>
                        </label>
                        <input type="number" id="ci-crop-padding" placeholder="Auto (from augmentation)">
                    </div>
                </div>

                <!-- Crop Preview -->
                <div class="card" style="padding: 15px; background: #222; margin: 15px 0;">
                    <div style="display: flex; gap: 20px; align-items: flex-start;">
                        <div>
                            <canvas id="ci-crop-preview" width="200" height="200" style="border: 1px solid #444; border-radius: 6px; background: #1a1a2e;"></canvas>
                            <div style="font-size: 0.75rem; color: #888; text-align: center; margin-top: 5px;">Crop region preview</div>
                        </div>
                        <div style="flex: 1; font-size: 0.85rem;">
                            <div style="margin-bottom: 10px;">
                                <strong style="color: #ccc;">Crop Info:</strong>
                                <div id="ci-crop-info" style="color: #888; margin-top: 5px;">
                                    Crop size: <span id="ci-crop-size-display">-</span><br>
                                    Model input: <span id="ci-input-size-display">-</span><br>
                                    Model output: <span id="ci-output-size-display">-</span>
                                </div>
                            </div>
                            <div class="info-box" style="margin: 0; padding: 10px; font-size: 0.8rem;">
                                <strong>Note:</strong> The orange box shows the crop region. Ensure it fully contains your animal in all poses. The anchor point (where crops are centered) is set in the Centroid tab.
                            </div>
                        </div>
                    </div>
                </div>

                <!-- CI Data Augmentation -->
                <div class="toggle-group" style="margin-top: 15px;">
                    <input type="checkbox" id="ci-use-augmentation">
                    <label for="ci-use-augmentation" style="display: inline; margin: 0;">
                        Enable Data Augmentation
                        <span class="tooltip">?
                            <span class="tooltip-text">Data augmentation for the Centered Instance model. Since crops are smaller and centered, you may want different augmentation settings than the Centroid model. Rotation and scale affect the required crop padding.</span>
                        </span>
                    </label>
                </div>
                <div id="ci-aug-preview-section" class="hidden">
                    <div class="aug-container">
                        <div class="aug-sliders">
                            <h4>Geometric</h4>
                            <div class="slider-group">
                                <div class="slider-header">
                                    <span class="slider-label">Rotation</span>
                                    <span class="slider-value" id="ci-rotation-value">Â±15Â°</span>
                                </div>
                                <input type="range" id="ci-aug-rotation-val" min="0" max="180" value="15" oninput="updateCIAugSliderValue('rotation')">
                            </div>
                            <div class="slider-group">
                                <div class="slider-header">
                                    <span class="slider-label">Scale</span>
                                    <span class="slider-value" id="ci-scale-aug-value">0.9 - 1.1</span>
                                </div>
                                <input type="range" id="ci-aug-scale-val" min="0" max="50" value="10" oninput="updateCIAugSliderValue('scale')">
                            </div>
                            <div class="slider-group">
                                <div class="slider-header">
                                    <span class="slider-label">Translate</span>
                                    <span class="slider-value" id="ci-translate-value">0%</span>
                                </div>
                                <input type="range" id="ci-aug-translate-val" min="0" max="30" value="0" oninput="updateCIAugSliderValue('translate')">
                            </div>
                            <h4>Intensity</h4>
                            <div class="slider-group">
                                <div class="slider-header">
                                    <span class="slider-label">Brightness</span>
                                    <span class="slider-value" id="ci-brightness-value">0%</span>
                                </div>
                                <input type="range" id="ci-aug-brightness-val" min="0" max="50" value="0" oninput="updateCIAugSliderValue('brightness')">
                            </div>
                            <div class="slider-group">
                                <div class="slider-header">
                                    <span class="slider-label">Contrast</span>
                                    <span class="slider-value" id="ci-contrast-value">0%</span>
                                </div>
                                <input type="range" id="ci-aug-contrast-val" min="0" max="50" value="0" oninput="updateCIAugSliderValue('contrast')">
                            </div>
                        </div>
                        <div class="aug-preview-container">
                            <div class="aug-preview-pair">
                                <div class="aug-preview-box">
                                    <canvas id="ci-aug-original" width="150" height="150"></canvas>
                                    <div class="label">Original Crop</div>
                                </div>
                                <div class="aug-preview-box">
                                    <canvas id="ci-aug-preview" width="150" height="150"></canvas>
                                    <div class="label">Augmented</div>
                                </div>
                            </div>
                            <button onclick="randomizeCIAugPreview()">Randomize</button>
                        </div>
                    </div>
                </div>
                </div>

                <!-- Model Configuration (collapsible) -->
                <div class="collapsible-header" onclick="toggleCollapsible('ci-model-config')">
                    <h3>Model Configuration</h3>
                    <span class="chevron" id="ci-model-config-chevron">&#9660;</span>
                </div>
                <div class="collapsible-content expanded" id="ci-model-config">
                <div class="grid-2">
                    <div class="form-group">
                        <label>
                            Backbone
                            <span class="tooltip">?
                                <span class="tooltip-text">UNet is recommended for most cases. Since crops are small, simpler architectures work well.</span>
                            </span>
                        </label>
                        <select id="ci-backbone">
                            <option value="unet">UNet (Default)</option>
                            <option value="unet_medium_rf">UNet Medium RF</option>
                            <option value="convnext_tiny">ConvNeXt Tiny (Pretrained, RGB)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>
                            Input Channels
                            <span class="tooltip">?
                                <span class="tooltip-text">Number of color channels. Should match the centroid model. Grayscale (1) is more efficient. RGB (3) required for pretrained backbones.</span>
                            </span>
                        </label>
                        <select id="ci-input-channels">
                            <option value="1" selected>Grayscale (1)</option>
                            <option value="3">RGB (3)</option>
                        </select>
                    </div>
                </div>
                <div class="grid-2">
                    <div class="form-group">
                        <label>
                            Max Stride
                            <span class="tooltip">?
                                <span class="tooltip-text">Controls receptive field and number of encoder blocks. For crops, max_stride=16 is typically sufficient since the crop size is already limited.</span>
                            </span>
                        </label>
                        <select id="ci-max-stride">
                            <option value="8">8 (RF: ~36px)</option>
                            <option value="16" selected>16 (RF: ~76px)</option>
                            <option value="32">32 (RF: ~156px)</option>
                        </select>
                    </div>
                </div>
                <div class="grid-2">
                    <div class="form-group">
                        <label>
                            Base Filters
                            <span class="tooltip">?
                                <span class="tooltip-text">Number of filters in the first encoder block. More filters = more capacity but slower training. For small crops, 24-32 is typically enough.</span>
                            </span>
                        </label>
                        <input type="number" id="ci-filters" value="32" min="8" max="128" step="8">
                    </div>
                    <div class="form-group">
                        <label>
                            Filters Rate
                            <span class="tooltip">?
                                <span class="tooltip-text">Multiplier for filters per encoder block. E.g., rate=1.5 with base=32: 32â†’48â†’72â†’108.</span>
                            </span>
                        </label>
                        <input type="number" id="ci-filters-rate" value="1.5" min="1" max="2" step="0.1">
                    </div>
                </div>

                <!-- Head Configuration -->
                <h4 style="margin: 20px 0 10px; color: #666; font-size: 0.85rem; border-top: 1px solid var(--border); padding-top: 15px;">Head Configuration</h4>
                <div class="grid-2">
                    <div class="form-group">
                        <label>
                            Sigma
                            <span class="tooltip">?
                                <span class="tooltip-text">Spread of confidence map Gaussian (in pixels at model input resolution). Larger sigma = easier to learn but less precise. For crops, 2.5-5.0 is typical.</span>
                            </span>
                        </label>
                        <input type="number" id="ci-sigma" value="2.5" min="1" max="15" step="0.5" oninput="updateCISigmaVisualization()">
                    </div>
                    <div class="form-group">
                        <label>
                            Output Stride
                            <span class="tooltip">?
                                <span class="tooltip-text">Stride of output confidence maps. Stride=1 gives full resolution, stride=2 gives half resolution (faster but less precise).</span>
                            </span>
                        </label>
                        <select id="ci-output-stride" onchange="updateCISigmaVisualization()">
                            <option value="1">1 (full resolution)</option>
                            <option value="2" selected>2 (half resolution)</option>
                        </select>
                    </div>
                </div>

                <!-- CI Sigma Visualization -->
                <div class="sigma-guide-card" style="background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 12px; margin: 10px 0 15px;">
                    <div style="display: flex; align-items: flex-start; gap: 12px;">
                        <div style="flex: 1;">
                            <div style="font-size: 0.8rem; color: var(--text-dim);">
                                <div>Gaussian spread: <strong id="ci-sigma-radius" style="color: var(--text);">5</strong>px (2Ïƒ covers 95%)</div>
                                <div style="margin-top: 4px;">Each keypoint has its own channel - no overlap concern</div>
                            </div>
                        </div>
                        <canvas id="ci-sigma-viz" width="60" height="60" style="border: 1px solid var(--border); border-radius: 6px; background: var(--bg);"></canvas>
                    </div>
                </div>

                <!-- CI Model Architecture -->
                <details style="margin: 15px 0;">
                    <summary style="cursor: pointer; font-size: 0.9rem; color: var(--accent); font-weight: 500;">View Model Architecture</summary>
                    <div style="margin-top: 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 15px;">
                        <div class="grid-3" style="gap: 15px; margin-bottom: 15px;">
                            <div style="text-align: center;">
                                <div style="font-size: 1.2rem; font-weight: 600; color: var(--text);" id="ci-total-params">~1.1M</div>
                                <div style="font-size: 0.75rem; color: var(--text-dim);">Parameters</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 1.2rem; font-weight: 600; color: var(--text);" id="ci-down-blocks">4</div>
                                <div style="font-size: 0.75rem; color: var(--text-dim);">Encoder Blocks</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 1.2rem; font-weight: 600; color: var(--text);" id="ci-up-blocks">4</div>
                                <div style="font-size: 0.75rem; color: var(--text-dim);">Decoder Blocks</div>
                            </div>
                        </div>
                        <div id="ci-unet-arch" style="margin-top: 8px;"></div>
                    </div>
                </details>

                <!-- CI Pretrained Checkpoints -->
                <div class="toggle-group" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border);">
                    <input type="checkbox" id="ci-load-pretrained-ckpts">
                    <label for="ci-load-pretrained-ckpts" style="display: inline; margin: 0;">
                        Load Pretrained Checkpoints
                        <span class="tooltip">?
                            <span class="tooltip-text">Load weights from previously trained models to fine-tune or resume training.<br><br><b>Backbone weights:</b> Load encoder/decoder weights from a prior model (useful for transfer learning).<br><br><b>Head weights:</b> Load the prediction head weights (useful when fine-tuning on similar data).</span>
                        </span>
                    </label>
                </div>
                <div id="ci-pretrained-ckpts-options" class="hidden" style="margin-left: 25px; padding: 15px; background: #333; border-radius: 6px; margin-top: 10px;">
                    <div class="form-group" style="margin: 0 0 10px;">
                        <label style="font-size: 0.85rem;">
                            Pretrained Backbone Weights
                            <span class="tooltip">?
                                <span class="tooltip-text">Path to a .ckpt file containing backbone (encoder/decoder) weights. The model architecture must match. Leave empty to train from scratch.</span>
                            </span>
                        </label>
                        <input type="text" id="ci-pretrained-backbone-path" placeholder="e.g., ./models/prev_run/best.ckpt">
                    </div>
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.85rem;">
                            Pretrained Head Weights
                            <span class="tooltip">?
                                <span class="tooltip-text">Path to a .ckpt file containing head (prediction layer) weights. Useful when fine-tuning on data with the same skeleton. Leave empty to initialize randomly.</span>
                            </span>
                        </label>
                        <input type="text" id="ci-pretrained-head-path" placeholder="e.g., ./models/prev_run/best.ckpt">
                    </div>
                </div>
                </div>

                <!-- Trainer Configuration (collapsible) -->
                <div class="collapsible-header" onclick="toggleCollapsible('ci-trainer-config')">
                    <h3>Trainer Configuration</h3>
                    <span class="chevron" id="ci-trainer-config-chevron">&#9660;</span>
                </div>
                <div class="collapsible-content expanded" id="ci-trainer-config">
                    <!-- CI Additional Parameters Toggle -->
                    <div class="toggle-group">
                        <input type="checkbox" id="ci-show-additional-params">
                        <label for="ci-show-additional-params" style="display: inline; margin: 0;">
                            Additional Parameters
                            <span class="tooltip">?
                                <span class="tooltip-text">Advanced training parameters. The defaults work well for most cases, but you can customize batch size, learning rate, optimizer, and other settings here.</span>
                            </span>
                        </label>
                    </div>
                    <div id="ci-additional-params-options" class="hidden" style="margin-left: 25px; padding: 15px; background: #333; border-radius: 6px; margin-top: 10px; margin-bottom: 15px;">
                <div class="grid-3">
                    <div class="form-group">
                        <label>
                            Batch Size
                            <span class="tooltip">?
                                <span class="tooltip-text">Number of crop samples per training batch. Since crops are smaller than full images, you can often use larger batch sizes. 4-8 is typical for 8GB GPUs.</span>
                            </span>
                        </label>
                        <select id="ci-batch-size">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="4" selected>4</option>
                            <option value="8">8</option>
                            <option value="16">16</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>
                            Max Epochs
                            <span class="tooltip">?
                                <span class="tooltip-text">Maximum training epochs for the centered instance model. 100-200 epochs is typical.</span>
                            </span>
                        </label>
                        <input type="number" id="ci-max-epochs" value="200" min="10" max="1000">
                    </div>
                    <div class="form-group">
                        <label>
                            Learning Rate
                            <span class="tooltip">?
                                <span class="tooltip-text">Initial learning rate. 1e-4 is a good default for most cases.</span>
                            </span>
                        </label>
                        <select id="ci-learning-rate">
                            <option value="0.0001" selected>1e-4 (Default)</option>
                            <option value="0.0005">5e-4</option>
                            <option value="0.001">1e-3</option>
                        </select>
                    </div>
                </div>
                <div class="grid-2">
                    <div class="form-group">
                        <label>
                            Optimizer
                            <span class="tooltip">?
                                <span class="tooltip-text">Adam is the standard choice. AdamW adds weight decay regularization.</span>
                            </span>
                        </label>
                        <select id="ci-optimizer">
                            <option value="Adam" selected>Adam</option>
                            <option value="AdamW">AdamW</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>
                            Accelerator
                            <span class="tooltip">?
                                <span class="tooltip-text">Hardware to use for training. "Auto" detects available hardware automatically.</span>
                            </span>
                        </label>
                        <select id="ci-accelerator">
                            <option value="auto" selected>Auto</option>
                            <option value="gpu">GPU</option>
                            <option value="mps">MPS (Apple Silicon)</option>
                            <option value="cpu">CPU</option>
                        </select>
                    </div>
                </div>
                <div class="toggle-group">
                    <input type="checkbox" id="ci-early-stopping" checked onchange="toggleCIEarlyStoppingOptions()">
                    <label for="ci-early-stopping" style="display: inline; margin: 0;">Enable Early Stopping
                        <span class="tooltip">?
                            <span class="tooltip-text">Stops training automatically when validation loss stops improving, preventing overfitting and wasted compute.</span>
                        </span>
                    </label>
                </div>
                <div id="ci-early-stopping-options" class="toggle-options" style="margin-left: 25px; padding: 10px; background: #333; border-radius: 6px; margin-top: 10px;">
                    <div class="grid-2">
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 0.8rem;">Patience
                                <span class="tooltip">?<span class="tooltip-text">Epochs to wait for improvement before stopping.</span></span>
                            </label>
                            <input type="number" id="ci-es-patience" value="5" min="1" max="50" style="padding: 6px;">
                        </div>
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 0.8rem;">Min Delta
                                <span class="tooltip">?<span class="tooltip-text">Minimum loss change to count as improvement.</span></span>
                            </label>
                            <input type="number" id="ci-es-min-delta" value="0.000001" min="0" max="0.1" step="0.000001" style="padding: 6px;">
                        </div>
                    </div>
                </div>

                    <div class="grid-2">
                        <div class="form-group">
                            <label>
                                Min Steps/Epoch
                                <span class="tooltip">?
                                    <span class="tooltip-text">Minimum training steps per epoch. Useful for small datasets.</span>
                                </span>
                            </label>
                            <input type="number" id="ci-min-steps" value="200" min="10" max="1000">
                        </div>
                        <div class="form-group">
                            <label>
                                Random Seed
                                <span class="tooltip">?
                                    <span class="tooltip-text">Seed for reproducibility. Leave empty for random initialization.</span>
                                </span>
                            </label>
                            <input type="number" id="ci-random-seed" placeholder="None (random)">
                        </div>
                    </div>

                    <h4 style="margin: 15px 0 10px; color: #888; font-size: 0.9rem;">Learning Rate Scheduler
                        <span class="tooltip">?
                            <span class="tooltip-text">Adjusts the learning rate during training to improve convergence.</span>
                        </span>
                    </h4>
                    <div class="grid-2">
                        <div class="form-group">
                            <label>
                                Scheduler Type
                                <span class="tooltip">?
                                    <span class="tooltip-text"><b>Reduce on Plateau:</b> Automatically reduces LR when loss stops improving.<br><br><b>Cosine Annealing + Warmup:</b> Linear warmup then cosine decay.<br><br><b>Linear Warmup + Decay:</b> Linear warmup then linear decay.<br><br><b>Step LR:</b> Reduces LR by a fixed factor every N epochs.<br><br><b>None:</b> Constant learning rate.</span>
                                </span>
                            </label>
                            <select id="ci-lr-scheduler" onchange="updateCISchedulerOptions()">
                                <option value="reduce_on_plateau" selected>Reduce on Plateau</option>
                                <option value="cosine_annealing_warmup">Cosine Annealing + Warmup</option>
                                <option value="linear_warmup_linear_decay">Linear Warmup + Decay</option>
                                <option value="step_lr">Step LR</option>
                                <option value="none">None (Constant)</option>
                            </select>
                        </div>
                        <div class="form-group" id="ci-lr-patience-group">
                            <label>
                                Patience
                                <span class="tooltip">?
                                    <span class="tooltip-text">Epochs without improvement before reducing LR.</span>
                                </span>
                            </label>
                            <input type="number" id="ci-lr-patience" value="5" min="1" max="50">
                        </div>
                    </div>
                    <!-- Step LR options -->
                    <div id="ci-step-lr-options" class="toggle-options" style="padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: none; margin-bottom: 10px;">
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Step Size (epochs)
                                    <span class="tooltip">?<span class="tooltip-text">LR is reduced every N epochs.</span></span>
                                </label>
                                <input type="number" id="ci-step-lr-step-size" value="10" min="1" max="100" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Gamma (decay factor)
                                    <span class="tooltip">?<span class="tooltip-text">Multiply LR by this factor. 0.1 = reduce to 10%.</span></span>
                                </label>
                                <input type="number" id="ci-step-lr-gamma" value="0.1" min="0.01" max="1" step="0.01" style="padding: 6px;">
                            </div>
                        </div>
                    </div>
                    <!-- Cosine Annealing + Warmup options -->
                    <div id="ci-cosine-warmup-options" class="toggle-options" style="padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: none; margin-bottom: 10px;">
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Warmup Epochs
                                    <span class="tooltip">?<span class="tooltip-text">Number of epochs for linear warmup phase. Default: 5</span></span>
                                </label>
                                <input type="number" id="ci-cosine-warmup-epochs" value="5" min="0" max="50" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Warmup Start LR
                                    <span class="tooltip">?<span class="tooltip-text">Learning rate at the start of warmup. Default: 0</span></span>
                                </label>
                                <input type="number" id="ci-cosine-warmup-start-lr" value="0" min="0" max="0.01" step="1e-6" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Min LR (eta_min)
                                    <span class="tooltip">?<span class="tooltip-text">Minimum LR at the end of cosine decay. Default: 0</span></span>
                                </label>
                                <input type="number" id="ci-cosine-eta-min" value="0" min="0" max="0.01" step="1e-6" style="padding: 6px;">
                            </div>
                        </div>
                    </div>
                    <!-- Linear Warmup + Decay options -->
                    <div id="ci-linear-warmup-decay-options" class="toggle-options" style="padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: none; margin-bottom: 10px;">
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Warmup Epochs
                                    <span class="tooltip">?<span class="tooltip-text">Number of epochs for linear warmup phase. Default: 5</span></span>
                                </label>
                                <input type="number" id="ci-linear-warmup-epochs" value="5" min="0" max="50" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Warmup Start LR
                                    <span class="tooltip">?<span class="tooltip-text">Learning rate at the start of warmup. Default: 0</span></span>
                                </label>
                                <input type="number" id="ci-linear-warmup-start-lr" value="0" min="0" max="0.01" step="1e-6" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">End LR
                                    <span class="tooltip">?<span class="tooltip-text">Learning rate at the end of training. Default: 0</span></span>
                                </label>
                                <input type="number" id="ci-linear-end-lr" value="0" min="0" max="0.01" step="1e-6" style="padding: 6px;">
                            </div>
                        </div>
                    </div>
                    <!-- Reduce on Plateau options -->
                    <div id="ci-reduce-lr-options" class="toggle-options" style="padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: block; margin-bottom: 10px;">
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Factor
                                    <span class="tooltip">?<span class="tooltip-text">Reduce LR by this factor when plateau detected.</span></span>
                                </label>
                                <input type="number" id="ci-reduce-lr-factor" value="0.5" min="0.01" max="1" step="0.1" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Min LR</label>
                                <input type="number" id="ci-reduce-lr-min" value="1e-8" min="0" max="0.01" step="1e-9" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Cooldown
                                    <span class="tooltip">?<span class="tooltip-text">Number of epochs to wait before resuming normal operation after LR has been reduced. Default: 3</span></span>
                                </label>
                                <input type="number" id="ci-reduce-lr-cooldown" value="3" min="0" max="20" step="1" style="padding: 6px;">
                            </div>
                        </div>
                    </div>
                    </div>
                <div class="toggle-group">
                    <input type="checkbox" id="ci-save-ckpt" checked onchange="toggleCISaveCkptOptions()">
                    <label for="ci-save-ckpt" style="display: inline; margin: 0;">Save Checkpoints</label>
                </div>
                <div id="ci-save-ckpt-options" class="toggle-options" style="margin-left: 25px; padding: 10px; background: #333; border-radius: 6px; font-size: 0.85rem;">
                    <div class="grid-2" style="gap: 10px;">
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 0.8rem;">Checkpoint Directory
                                <span class="tooltip">?<span class="tooltip-text">Directory where the run folder will be created. Default: ./models</span></span>
                            </label>
                            <input type="text" id="ci-ckpt-dir" value="./models" placeholder="./models" style="padding: 6px;">
                        </div>
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 0.8rem;">Run Name
                                <span class="tooltip">?<span class="tooltip-text">Name for this training run. Leave empty to auto-generate from timestamp + head type.</span></span>
                            </label>
                            <input type="text" id="ci-run-name" placeholder="Auto (timestamp_head)" style="padding: 6px;">
                        </div>
                    </div>
                    <div class="grid-2" style="gap: 10px; margin-top: 10px;">
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 0.8rem;">Save Top K
                                <span class="tooltip">?<span class="tooltip-text">Number of best checkpoints to save based on validation loss. Set to -1 to save all.</span></span>
                            </label>
                            <input type="number" id="ci-ckpt-save-top-k" value="1" min="-1" max="10" style="padding: 6px;">
                        </div>
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 0.8rem;">
                                <input type="checkbox" id="ci-ckpt-save-last" checked style="margin-right: 5px;">
                                Save Last Checkpoint
                            </label>
                        </div>
                    </div>
                    <div class="form-group" style="margin: 10px 0 0;">
                        <label style="font-size: 0.8rem;">Resume from Checkpoint
                            <span class="tooltip">?<span class="tooltip-text">Path to a checkpoint file (.ckpt) to resume training from. Leave empty to start fresh.</span></span>
                        </label>
                        <input type="text" id="ci-resume-ckpt-path" placeholder="None (start fresh)" style="padding: 6px; width: 100%;">
                    </div>
                </div>
                </div>

                <!-- Additional Settings -->
                <div id="ci-advanced-options" style="margin-top: 15px;">
                    <h4 style="margin: 0 0 15px; color: #666; font-size: 0.85rem; border-top: 1px solid var(--border); padding-top: 15px;">Additional Settings</h4>

                    <!-- CI Cache Memory Estimate Card -->
                    <div id="ci-cache-memory-card" class="card" style="padding: 12px; margin-bottom: 15px; background: #222; border: 1px solid var(--border); display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 600; color: #ccc;">ðŸ’¾ Image Cache Memory</span>
                            <span id="ci-cache-memory-status" class="badge" style="padding: 4px 10px; border-radius: 4px; font-size: 0.75rem;">-</span>
                        </div>
                        <div style="font-size: 0.85rem; color: #888;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                <div>Raw image data:</div>
                                <div id="ci-cache-raw-size" style="text-align: right; color: #ccc;">-</div>
                                <div>With overhead (1.2Ã—):</div>
                                <div id="ci-cache-total-size" style="text-align: right; color: #ccc;">-</div>
                                <div id="ci-cache-workers-row" style="display: none;">Per-worker replication:</div>
                                <div id="ci-cache-workers-size" style="text-align: right; color: #ccc; display: none;">-</div>
                            </div>
                            <div id="ci-cache-memory-note" style="margin-top: 8px; padding: 8px; background: rgba(234, 179, 8, 0.1); border-radius: 4px; font-size: 0.8rem; display: none;">
                                âš ï¸ With memory caching + num_workers > 0, each worker gets a copy of the cache.
                            </div>
                        </div>
                    </div>

                    <div class="info-box" style="background: rgba(16, 185, 129, 0.15); border-color: #10b981; margin-bottom: 10px;">
                        <strong>Speed Tip:</strong> To improve training speed, set <strong>Num Workers</strong> to 2+ and change <strong>Data Pipeline</strong> to "Cache to Memory" or "Cache to Disk".
                    </div>
                    <div class="grid-2">
                        <div class="form-group">
                            <label>
                                Num Workers
                                <span class="tooltip">?
                                    <span class="tooltip-text">Parallel processes for loading data.<br><br><b>0:</b> Required for torch_dataset (default).<br><b>>0:</b> Only with caching pipelines.</span>
                                </span>
                            </label>
                            <select id="ci-num-workers" onchange="updateCICacheMemoryEstimate()">
                                <option value="0" selected>0 (Default)</option>
                                <option value="2">2</option>
                                <option value="4">4</option>
                                <option value="8">8</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>
                                Data Pipeline
                                <span class="tooltip">?
                                    <span class="tooltip-text">How data is loaded. torch_dataset loads directly from video. Caching options preload images for faster training.</span>
                                </span>
                            </label>
                            <select id="ci-data-pipeline" onchange="updateCICacheMemoryEstimate()">
                                <option value="torch_dataset" selected>torch_dataset (Default)</option>
                                <option value="torch_dataset_cache_img_memory">Cache to Memory</option>
                                <option value="torch_dataset_cache_img_disk">Cache to Disk</option>
                            </select>
                        </div>
                    </div>

                    <h4 style="margin: 15px 0 10px; color: #888; font-size: 0.9rem;">Hard Keypoint Mining</h4>
                    <div class="toggle-group">
                        <input type="checkbox" id="ci-enable-ohkm" onchange="toggleCIOhkmOptions()">
                        <label for="ci-enable-ohkm" style="display: inline; margin: 0;">
                            Enable OHKM
                            <span class="tooltip">?
                                <span class="tooltip-text">Online Hard Keypoint Mining focuses training on difficult keypoints.</span>
                            </span>
                        </label>
                    </div>
                    <div id="ci-ohkm-options" class="toggle-options" style="margin-left: 25px; padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: none;">
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Hard-to-Easy Ratio</label>
                                <input type="number" id="ci-ohkm-ratio" value="2.0" min="1" max="10" step="0.1" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Loss Scale</label>
                                <input type="number" id="ci-ohkm-loss-scale" value="5.0" min="1" max="20" step="0.5" style="padding: 6px;">
                            </div>
                        </div>
                        <div class="grid-2" style="gap: 10px; margin-top: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Min Hard Keypoints</label>
                                <input type="number" id="ci-ohkm-min-hard" value="2" min="1" max="20" step="1" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Max Hard Keypoints</label>
                                <input type="number" id="ci-ohkm-max-hard" placeholder="None" min="1" max="100" step="1" style="padding: 6px;">
                            </div>
                        </div>
                    </div>

                    <h4 style="margin: 15px 0 10px; color: #888; font-size: 0.9rem;">Logging</h4>
                    <div class="toggle-group">
                        <input type="checkbox" id="ci-enable-wandb" onchange="toggleCIWandbOptions()">
                        <label for="ci-enable-wandb" style="display: inline; margin: 0;">
                            Enable Weights & Biases Logging
                            <span class="tooltip">?
                                <span class="tooltip-text">Log training metrics, visualizations, and model checkpoints to Weights & Biases (wandb.ai). Great for tracking experiments and comparing runs.</span>
                            </span>
                        </label>
                    </div>
                    <div id="ci-wandb-options" class="toggle-options" style="margin-left: 25px; padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: none;">
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Entity (optional)</label>
                                <input type="text" id="ci-wandb-entity" placeholder="your-username" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Project</label>
                                <input type="text" id="ci-wandb-project" placeholder="sleap-training" style="padding: 6px;">
                            </div>
                        </div>
                        <div class="grid-2" style="gap: 10px; margin-top: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Run Name (optional)</label>
                                <input type="text" id="ci-wandb-name" placeholder="Auto" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Mode</label>
                                <select id="ci-wandb-mode" style="padding: 6px;">
                                    <option value="" selected>Online (default)</option>
                                    <option value="offline">Offline</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-group" style="margin: 10px 0 0;">
                            <label style="font-size: 0.8rem;">API Key (optional)</label>
                            <input type="password" id="ci-wandb-api-key" placeholder="Leave empty to use env var" style="padding: 6px; width: 100%;">
                        </div>
                        <div style="margin-top: 10px;">
                            <label style="font-size: 0.8rem;">
                                <input type="checkbox" id="ci-wandb-viz-enabled" checked style="margin-right: 5px;">
                                Log prediction visualizations
                            </label>
                        </div>
                        <div style="margin-top: 5px;">
                            <label style="font-size: 0.8rem;">
                                <input type="checkbox" id="ci-wandb-save-viz" style="margin-right: 5px;">
                                Upload local viz images to WandB
                            </label>
                        </div>
                    </div>
                    <div class="toggle-group">
                        <input type="checkbox" id="ci-enable-viz" onchange="toggleCIVizOptions()">
                        <label for="ci-enable-viz" style="display: inline; margin: 0;">
                            Save Prediction Visualizations
                        </label>
                    </div>
                    <div id="ci-viz-options" class="toggle-options" style="margin-left: 25px; padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: none;">
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 0.8rem;">
                                <input type="checkbox" id="ci-viz-keep-folder" style="margin-right: 5px;">
                                Keep viz folder after training
                            </label>
                        </div>
                    </div>

                    <h4 style="margin: 15px 0 10px; color: #888; font-size: 0.9rem;">Evaluation</h4>
                    <div class="toggle-group">
                        <input type="checkbox" id="ci-enable-eval" onchange="toggleCIEvalOptions()">
                        <label for="ci-enable-eval" style="display: inline; margin: 0;">Enable OKS Evaluation
                            <span class="tooltip">?
                                <span class="tooltip-text">Run Object Keypoint Similarity (OKS) evaluation during training. OKS measures pose estimation accuracy accounting for keypoint scale. Adds compute overhead but provides useful metrics.</span>
                            </span>
                        </label>
                    </div>
                    <div id="ci-eval-options" class="toggle-options" style="margin-left: 25px; padding: 10px; background: #3a3a3a; border-radius: 6px; font-size: 0.85rem; display: none; margin-top: 10px;">
                        <div class="grid-2" style="gap: 10px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">Frequency (epochs)
                                    <span class="tooltip">?<span class="tooltip-text">Run evaluation every N epochs. Higher frequency = more metrics but slower training.</span></span>
                                </label>
                                <input type="number" id="ci-eval-frequency" value="1" min="1" max="50" style="padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 0.8rem;">OKS Stddev</label>
                                <input type="number" id="ci-eval-oks-stddev" value="0.025" min="0.001" max="0.5" step="0.005" style="padding: 6px;">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- GPU Memory Estimation for CI -->
                <div class="memory-card" id="ci-gpu-memory-card">
                    <div class="memory-header">
                        <div>
                            <span style="font-size: 0.85rem; color: #888;">Estimated GPU Memory</span>
                            <span class="tooltip">?
                                <span class="tooltip-text">Rough estimate based on batch size, crop dimensions, model architecture.</span>
                            </span>
                        </div>
                        <div class="memory-total" id="ci-memory-total">~1.0 GB</div>
                    </div>
                    <div class="memory-breakdown">
                        <div class="memory-item">
                            <span class="memory-item-label">Model Params</span>
                            <span class="memory-item-value" id="ci-mem-params">~1.1M</span>
                        </div>
                        <div class="memory-item">
                            <span class="memory-item-label">Weights</span>
                            <span class="memory-item-value" id="ci-mem-weights">~4 MB</span>
                        </div>
                        <div class="memory-item">
                            <span class="memory-item-label">Batch Crops</span>
                            <span class="memory-item-value" id="ci-mem-batch-img">~8 MB</span>
                        </div>
                        <div class="memory-item">
                            <span class="memory-item-label">Feature Maps</span>
                            <span class="memory-item-value" id="ci-mem-activations">~256 MB</span>
                        </div>
                        <div class="memory-item">
                            <span class="memory-item-label">Conf Maps</span>
                            <span class="memory-item-value" id="ci-mem-confmaps">~32 MB</span>
                        </div>
                        <div class="memory-item">
                            <span class="memory-item-label">Gradients</span>
                            <span class="memory-item-value" id="ci-mem-gradients">~0.5 GB</span>
                        </div>
                    </div>
                    <div class="memory-status ok" id="ci-memory-status">
                        Should fit on most GPUs (8GB+)
                    </div>
                </div>
            </div>

            <!-- Config Preview Tab -->
            <div class="tab-content" id="tab-config-preview">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0; color: #ccc;">Generated Configuration</h3>
                    <div>
                        <button class="small" onclick="refreshConfigPreview()">ðŸ”„ Refresh</button>
                    </div>
                </div>
                <p style="font-size: 0.85rem; color: #888; margin: 0 0 15px;">
                    This preview updates as you change parameters. Switch back to adjust settings.
                </p>

                <div class="tabs" id="preview-config-tabs">
                    <button class="tab active" data-preview-tab="config1" id="preview-tab-1">Configuration</button>
                    <button class="tab hidden" data-preview-tab="config2" id="preview-tab-2">Centered Instance</button>
                </div>

                <div class="tab-content active" id="preview-config1">
                    <div class="yaml-output" id="yaml-preview-1" style="max-height: 500px; overflow-y: auto;"></div>
                    <div class="yaml-actions" style="margin-top: 10px;">
                        <button class="success" onclick="copyYamlPreview(1)">Copy to Clipboard</button>
                        <button class="secondary" onclick="downloadYamlPreview(1)">Download YAML</button>
                    </div>
                </div>

                <div class="tab-content" id="preview-config2">
                    <div class="yaml-output" id="yaml-preview-2" style="max-height: 500px; overflow-y: auto;"></div>
                    <div class="yaml-actions" style="margin-top: 10px;">
                        <button class="success" onclick="copyYamlPreview(2)">Copy to Clipboard</button>
                        <button class="secondary" onclick="downloadYamlPreview(2)">Download YAML</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 4: Export -->
        <div id="export-section" class="card hidden">
            <div class="card-header">
                <h2 class="card-title">Step 4: Export Configuration</h2>
            </div>

            <div class="tabs" id="export-tabs">
                <button class="tab active" data-export-tab="config1" id="export-tab-1">Configuration</button>
                <button class="tab hidden" data-export-tab="config2" id="export-tab-2">Centered Instance Config</button>
            </div>

            <div class="tab-content active" id="export-config1">
                <div class="yaml-output" id="yaml-output-1"></div>
                <div class="yaml-actions">
                    <button class="success" onclick="copyYaml(1)">Copy to Clipboard</button>
                    <button class="secondary" onclick="downloadYaml(1)">Download YAML</button>
                </div>
            </div>

            <div class="tab-content" id="export-config2">
                <div class="yaml-output" id="yaml-output-2"></div>
                <div class="yaml-actions">
                    <button class="success" onclick="copyYaml(2)">Copy to Clipboard</button>
                    <button class="secondary" onclick="downloadYaml(2)">Download YAML</button>
                </div>
            </div>

            <div style="margin-top: 15px;">
                <button class="secondary hidden" onclick="downloadAllConfigs()" id="download-all-btn">Download All Configs</button>
            </div>

            <!-- CLI Commands Section -->
            <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid var(--border);">
                <h3 style="margin: 0 0 15px; color: var(--text);">
                    CLI Commands
                    <span class="tooltip">?
                        <span class="tooltip-text">Copy these commands to train your model using the sleap-nn command line interface. Make sure to update the paths to match your system.</span>
                    </span>
                </h3>

                <div style="background: #1a1a2e; border: 1px solid var(--border); border-radius: 8px; padding: 15px; font-family: monospace; font-size: 0.85rem;">
                    <div style="margin-bottom: 15px;">
                        <div style="color: #888; font-size: 0.75rem; margin-bottom: 5px;">Basic training command:</div>
                        <code id="cli-basic" style="color: #10b981; word-break: break-all;"></code>
                        <button onclick="copyCLI('cli-basic')" style="margin-left: 10px; padding: 2px 8px; font-size: 0.7rem;" class="small secondary">Copy</button>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <div style="color: #888; font-size: 0.75rem; margin-bottom: 5px;">With labels path override:</div>
                        <code id="cli-override" style="color: #f59e0b; word-break: break-all;"></code>
                        <button onclick="copyCLI('cli-override')" style="margin-left: 10px; padding: 2px 8px; font-size: 0.7rem;" class="small secondary">Copy</button>
                    </div>

                    <div id="cli-topdown-section" class="hidden" style="margin-bottom: 15px; padding-top: 15px; border-top: 1px solid #333;">
                        <div style="color: #888; font-size: 0.75rem; margin-bottom: 5px;">Train Centered Instance model (after centroid):</div>
                        <code id="cli-ci" style="color: #667eea; word-break: break-all;"></code>
                        <button onclick="copyCLI('cli-ci')" style="margin-left: 10px; padding: 2px 8px; font-size: 0.7rem;" class="small secondary">Copy</button>
                    </div>
                </div>

                <details style="margin-top: 15px;">
                    <summary style="cursor: pointer; font-size: 0.9rem; color: var(--accent); font-weight: 500;">Video Path Replacement Examples</summary>
                    <div style="margin-top: 10px; background: #1a1a2e; border: 1px solid var(--border); border-radius: 8px; padding: 15px; font-family: monospace; font-size: 0.8rem;">
                        <div style="color: #888; margin-bottom: 10px;">If your video files have moved, use these options:</div>

                        <div style="margin-bottom: 12px;">
                            <div style="color: #10b981; font-weight: 600; margin-bottom: 4px;"># Replace by order (if videos moved to new location):</div>
                            <code style="color: #ccc;">sleap-nn train config.yaml --video-paths /new/path/video1.mp4 --video-paths /new/path/video2.mp4</code>
                        </div>

                        <div style="margin-bottom: 12px;">
                            <div style="color: #f59e0b; font-weight: 600; margin-bottom: 4px;"># Map specific old path to new path:</div>
                            <code style="color: #ccc;">sleap-nn train config.yaml --video-path-map "/old/server/video.mp4" "/local/data/video.mp4"</code>
                        </div>

                        <div>
                            <div style="color: #667eea; font-weight: 600; margin-bottom: 4px;"># Map path prefix (useful when moving between machines):</div>
                            <code style="color: #ccc;">sleap-nn train config.yaml --prefix-map "/remote/server/data" "/local/data"</code>
                        </div>
                    </div>
                </details>
            </div>
        </div>

        <!-- Navigation -->
        <div style="display: flex; justify-content: space-between; margin-top: 20px;">
            <button class="secondary" id="prev-btn" onclick="prevStep()" disabled>Previous</button>
            <button id="next-btn" onclick="nextStep()" disabled>Next</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/h5wasm@0.8.8/dist/iife/h5wasm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>

    <script>
        // State
        let currentStep = 1;
        let slpData = null;
        let selectedModelType = null;
        let isTopDown = false;
        let firstFrame = null;
        let selectedAnchor = null;
        let selectedCIAnchor = null;
        let videoElement = null;
        let videoFrame = null;  // ImageBitmap for reliable drawing (from video or embedded frame)
        let instancesData = null;  // Store parsed instance data for visualization
        let anchorCanvasData = null;  // Store transform data for anchor canvas click detection
        let loadedCentroidConfig = null;  // Store loaded centroid YAML config
        let loadedCIConfig = null;  // Store loaded centered instance YAML config

        // Receptive field computation based on sleap-nn formula
        // From: sleap_nn/example_notebooks/receptive_field_guide.py
        // RF = 1 + sum((kernel[l] - 1) * prod(strides[:l])) for l in range(L)
        // where each down block has: 2 convs (stride=1, kernel=3) + 1 pool (stride=2, kernel=2)
        function computeReceptiveField(maxStride) {
            const downBlocks = Math.log2(maxStride);
            const convsPerBlock = 2;
            const kernelSize = 3;

            // Build strides and kernels arrays
            const blockStrides = Array(convsPerBlock).fill(1).concat([2]); // [1, 1, 2]
            const blockKernels = Array(convsPerBlock).fill(kernelSize).concat([2]); // [3, 3, 2]

            const strides = [];
            const kernels = [];
            for (let i = 0; i < downBlocks; i++) {
                strides.push(...blockStrides);
                kernels.push(...blockKernels);
            }

            let rf = 1;
            for (let l = 0; l < strides.length; l++) {
                const prodStrides = strides.slice(0, l).reduce((a, b) => a * b, 1);
                rf += (kernels[l] - 1) * prodStrides;
            }
            return rf;
        }

        // Pre-compute RF values for common max_stride values
        const RF_TABLE = {
            8: computeReceptiveField(8),   // 36
            16: computeReceptiveField(16), // 76
            32: computeReceptiveField(32), // 156
            64: computeReceptiveField(64), // 316
            128: computeReceptiveField(128) // 636
        };

        // Compute padding needed to accommodate augmentation transforms
        // Based on sleap_nn/data/instance_cropping.py:compute_augmentation_padding
        function computeAugmentationPadding(bboxSize, rotationMax = 0, scaleMax = 1.0) {
            if (rotationMax === 0 && scaleMax <= 1.0) return 0;

            // For a square bbox rotated by angle Î¸, worst case expansion at 45Â° is sqrt(2)
            let rotationFactor = 1.0;
            if (rotationMax > 0) {
                const rotationRad = Math.min(Math.abs(rotationMax), 90) * Math.PI / 180;
                rotationFactor = Math.abs(Math.cos(rotationRad)) + Math.abs(Math.sin(rotationRad));
                // Worst case for angles >= 45Â° is sqrt(2)
                if (Math.abs(rotationMax) >= 45) {
                    rotationFactor = Math.sqrt(2);
                }
            }

            // Combined expansion factor
            const expansionFactor = rotationFactor * Math.max(scaleMax, 1.0);
            const expandedSize = bboxSize * expansionFactor;
            return Math.ceil(expandedSize - bboxSize);
        }

        // Get current augmentation values from UI (forCI=true uses CI-specific augmentation sliders)
        function getAugmentationParams(forCI = false) {
            if (forCI) {
                const rotationMax = parseInt(document.getElementById('ci-aug-rotation-val')?.value) || 0;
                const scalePercent = parseInt(document.getElementById('ci-aug-scale-val')?.value) || 0;
                const scaleMax = 1.0 + (scalePercent / 100);
                return { rotationMax, scaleMax };
            } else {
                const rotationMax = parseInt(document.getElementById('aug-rotation-val')?.value) || 0;
                const scalePercent = parseInt(document.getElementById('aug-scale-val')?.value) || 0;
                const scaleMax = 1.0 + (scalePercent / 100);
                return { rotationMax, scaleMax };
            }
        }

        // Compute suggested crop size following sleap-nn logic
        // Based on sleap_nn/data/instance_cropping.py:find_instance_crop_size
        function computeSuggestedCropSize(maxBboxDim, maxStride, useAugmentation = false, userPadding = null) {
            let padding = 0;
            if (userPadding !== null && userPadding > 0) {
                // User specified padding overrides auto-computed padding
                padding = userPadding;
            } else if (useAugmentation) {
                // Use CI-specific augmentation values for crop size calculation
                const ciAugEnabled = document.getElementById('ci-use-augmentation')?.checked || false;
                const { rotationMax, scaleMax } = getAugmentationParams(ciAugEnabled);
                padding = computeAugmentationPadding(maxBboxDim, rotationMax, scaleMax);
            }
            const sizeWithPadding = maxBboxDim + padding;
            // Round up to be divisible by max_stride
            return Math.ceil(sizeWithPadding / maxStride) * maxStride;
        }

        // Model parameter estimates (approximate)
        function estimateParams(filters, maxStride, inChannels) {
            const downBlocks = Math.log2(maxStride);
            let totalParams = 0;
            let ch = inChannels;
            let f = filters;

            // Encoder blocks
            for (let i = 0; i < downBlocks; i++) {
                // 2 convs per block: (ch * f * 9 + f) * 2
                totalParams += (ch * f * 9 + f) * 2;
                ch = f;
                f = Math.floor(f * 1.5);
            }

            // Middle block
            totalParams += (ch * f * 9 + f) * 2;

            // Decoder blocks (similar to encoder)
            for (let i = 0; i < downBlocks; i++) {
                totalParams += (f * Math.floor(f / 1.5) * 9 + Math.floor(f / 1.5)) * 2;
                f = Math.floor(f / 1.5);
            }

            return totalParams;
        }

        // More accurate parameter estimation accounting for output_stride
        function estimateParamsAccurate(filters, maxStride, outputStride, inChannels, numKeypoints) {
            const downBlocks = Math.log2(maxStride);
            const upBlocks = Math.log2(maxStride / outputStride);
            let totalParams = 0;
            let ch = inChannels;
            let f = filters;
            const filtersRate = 1.5;

            // Encoder blocks
            for (let i = 0; i < downBlocks; i++) {
                // 2 convs per block: 3x3 kernel
                totalParams += ch * f * 9 + f; // First conv
                totalParams += f * f * 9 + f;  // Second conv
                ch = f;
                f = Math.floor(f * filtersRate);
            }

            // Middle block
            totalParams += ch * f * 9 + f;
            totalParams += f * f * 9 + f;
            const middleFilters = f;

            // Decoder blocks (number depends on output_stride)
            f = middleFilters;
            for (let i = 0; i < upBlocks; i++) {
                const nextF = Math.floor(f / filtersRate);
                // Skip connection doubles input channels
                const skipF = i < downBlocks ? Math.floor(filters * Math.pow(filtersRate, downBlocks - 1 - i)) : 0;
                const decoderInput = f + skipF;
                totalParams += decoderInput * nextF * 9 + nextF;
                totalParams += nextF * nextF * 9 + nextF;
                f = nextF;
            }

            // Head: 1x1 conv to keypoints
            totalParams += f * numKeypoints * 1 + numKeypoints;

            return totalParams;
        }

        function formatParams(num) {
            if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(0) + 'K';
            return num.toString();
        }

        // Model types with detailed info
        const MODEL_TYPES = [
            {
                id: 'single_instance',
                name: 'Single Instance',
                description: 'For videos with exactly one animal per frame',
                details: 'Best for: Single-animal experiments, isolated subjects',
                singleAnimal: true
            },
            {
                id: 'bottomup',
                name: 'Bottom-Up',
                description: 'Multi-animal detection using Part Affinity Fields (PAFs)',
                details: 'Best for crowded/overlapping animals; detects all parts, then groups into instances',
                singleAnimal: false
            },
            {
                id: 'topdown',
                name: 'Top-Down',
                description: 'Two-stage: Detect centroids first, then keypoints in crops',
                details: 'Best for multiple well-separated animals that are small relative to the frame',
                singleAnimal: false,
                twoStage: true
            },
            {
                id: 'multi_class_bottomup',
                name: 'Multi-Class Bottom-Up',
                description: 'Bottom-up with identity classification via class maps',
                details: '<strong>Use when:</strong> You need to track identity AND animals overlap frequently.<br><strong>Requires:</strong> Track annotations in your SLP file.',
                singleAnimal: false,
                requiresTracks: true
            },
            {
                id: 'multi_class_topdown',
                name: 'Multi-Class Top-Down',
                description: 'Top-down with identity classification',
                details: '<strong>Use when:</strong> You need identity tracking with well-separated animals.<br><strong>Requires:</strong> Track annotations in your SLP file.',
                singleAnimal: false,
                twoStage: true,
                requiresTracks: true
            }
        ];

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initUpload();
            initSliders();
            initTabs();
            initAugToggle();
            initCIAugToggle();
            initPretrainedCkptsToggle();
            initAdditionalParamsToggle();
            initAnchorCanvas();
            updateSteps();
        });

        function initAnchorCanvas() {
            const canvas = document.getElementById('anchor-preview-canvas');
            if (canvas) {
                canvas.addEventListener('click', handleAnchorCanvasClick);
                canvas.addEventListener('mousemove', handleAnchorCanvasHover);
                canvas.addEventListener('mouseleave', handleAnchorCanvasLeave);
            }
        }

        // File upload
        function initUpload() {
            const zone = document.getElementById('upload-zone');
            const input = document.getElementById('file-input');

            zone.addEventListener('click', () => input.click());
            zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.classList.add('dragover'); });
            zone.addEventListener('dragleave', () => zone.classList.remove('dragover'));
            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('dragover');
                if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
            });
            input.addEventListener('change', () => {
                if (input.files.length) handleFile(input.files[0]);
            });

            // Video upload
            const videoZone = document.getElementById('video-upload-zone');
            const videoInput = document.getElementById('video-input');

            videoZone.addEventListener('click', () => videoInput.click());
            videoZone.addEventListener('dragover', (e) => { e.preventDefault(); videoZone.classList.add('dragover'); });
            videoZone.addEventListener('dragleave', () => videoZone.classList.remove('dragover'));
            videoZone.addEventListener('drop', (e) => {
                e.preventDefault();
                videoZone.classList.remove('dragover');
                if (e.dataTransfer.files.length) handleVideoFile(e.dataTransfer.files[0]);
            });
            videoInput.addEventListener('change', () => {
                if (videoInput.files.length) handleVideoFile(videoInput.files[0]);
            });

            // Config file upload - centroid
            const centroidConfigInput = document.getElementById('centroid-config-input');
            centroidConfigInput.addEventListener('change', () => {
                if (centroidConfigInput.files.length) handleConfigFile(centroidConfigInput.files[0], 'centroid');
            });

            // Config file upload - centered instance
            const ciConfigInput = document.getElementById('ci-config-input');
            ciConfigInput.addEventListener('change', () => {
                if (ciConfigInput.files.length) handleConfigFile(ciConfigInput.files[0], 'ci');
            });
        }

        async function handleConfigFile(file, configType) {
            if (!file.name.endsWith('.yaml') && !file.name.endsWith('.yml')) {
                alert('Please upload a YAML file (.yaml or .yml)');
                return;
            }

            try {
                const text = await file.text();
                const config = jsyaml.load(text);
                console.log(`Loaded ${configType} config:`, config);

                // Detect config type from head_configs
                const heads = config.model_config?.head_configs || {};
                const detectedType = heads.centroid ? 'centroid' :
                                    heads.centered_instance ? 'centered_instance' :
                                    heads.single_instance ? 'single_instance' :
                                    heads.bottomup ? 'bottomup' :
                                    heads.multi_class_bottomup ? 'multi_class_bottomup' :
                                    heads.multi_class_topdown ? 'multi_class_topdown' : 'unknown';

                // Validate model type matches what user expects
                if (configType === 'centroid' && detectedType !== 'centroid') {
                    const proceed = confirm(`This config appears to be a "${detectedType}" model, not a centroid model. Load anyway?`);
                    if (!proceed) return;
                }
                if (configType === 'ci' && detectedType !== 'centered_instance') {
                    const proceed = confirm(`This config appears to be a "${detectedType}" model, not a centered_instance model. Load anyway?`);
                    if (!proceed) return;
                }

                // Store config in appropriate variable based on detected type
                const isCentroidConfig = detectedType === 'centroid';
                const isCIConfig = detectedType === 'centered_instance';

                if (configType === 'ci' || isCIConfig) {
                    loadedCIConfig = config;
                    document.getElementById('ci-config-badge').classList.remove('hidden');
                    document.getElementById('ci-config-name').textContent = file.name;
                    document.getElementById('clear-ci-config-btn').classList.remove('hidden');
                } else {
                    // Store as centroid/main config for centroid, single_instance, bottomup, etc.
                    loadedCentroidConfig = config;
                    document.getElementById('centroid-config-badge').classList.remove('hidden');
                    document.getElementById('centroid-config-name').textContent = file.name;
                    document.getElementById('clear-centroid-config-btn').classList.remove('hidden');
                }

                // Apply loaded config to form fields if SLP is already loaded
                if (slpData) {
                    applyLoadedConfig();
                }
            } catch (err) {
                console.error('Error parsing YAML:', err);
                alert('Error parsing YAML file: ' + err.message);
            }
        }

        function clearLoadedConfig(configType) {
            if (configType === 'centroid') {
                loadedCentroidConfig = null;
                document.getElementById('centroid-config-badge').classList.add('hidden');
                document.getElementById('centroid-config-name').textContent = '';
                document.getElementById('clear-centroid-config-btn').classList.add('hidden');
                document.getElementById('centroid-config-input').value = '';
            } else if (configType === 'ci') {
                loadedCIConfig = null;
                document.getElementById('ci-config-badge').classList.add('hidden');
                document.getElementById('ci-config-name').textContent = '';
                document.getElementById('clear-ci-config-btn').classList.add('hidden');
                document.getElementById('ci-config-input').value = '';
            } else {
                // Clear both
                clearLoadedConfig('centroid');
                clearLoadedConfig('ci');
            }
        }

        function applyLoadedConfig() {
            // Apply centroid config to centroid tab (main tab for non-topdown)
            if (loadedCentroidConfig) {
                applyConfigToTab(loadedCentroidConfig, 'centroid');
            }
            // Apply centered instance config to CI tab
            if (loadedCIConfig) {
                applyConfigToTab(loadedCIConfig, 'ci');
            }

            // Trigger UI updates
            if (typeof updateReceptiveFieldDisplay === 'function') updateReceptiveFieldDisplay();
            if (typeof updateModelInputSize === 'function') updateModelInputSize();

            console.log('Applied loaded configs to form fields');
        }

        function applyConfigToTab(config, tabType) {
            const dc = config.data_config || {};
            const mc = config.model_config || {};
            const tc = config.trainer_config || {};
            const prep = dc.preprocessing || {};
            const aug = dc.augmentation_config || {};

            // Determine prefix for element IDs ('' for centroid/main, 'ci-' for centered instance)
            const prefix = tabType === 'ci' ? 'ci-' : '';
            const isCITab = tabType === 'ci';

            // Apply preprocessing values
            if (prep.scale !== undefined) {
                const scaleInput = document.getElementById(prefix + 'input-scale');
                if (scaleInput) scaleInput.value = prep.scale;
            }

            if (prep.crop_size !== undefined && prep.crop_size !== null) {
                const cropInput = document.getElementById('crop-size');
                if (cropInput && isCITab) cropInput.value = prep.crop_size;
            }

            // Apply backbone config
            const bb = mc.backbone_config || {};
            const backboneSelect = document.getElementById(prefix + 'backbone');
            if (bb.unet && backboneSelect) {
                backboneSelect.value = 'unet';
            } else if (bb.convnext && backboneSelect) {
                backboneSelect.value = 'convnext_' + (bb.convnext.model_type || 'tiny');
            } else if (bb.swint && backboneSelect) {
                backboneSelect.value = 'swint_' + (bb.swint.model_type || 'tiny');
            }

            if (bb.unet) {
                const msSelect = document.getElementById(prefix + 'max-stride');
                if (msSelect && bb.unet.max_stride) msSelect.value = bb.unet.max_stride;

                const filtersInput = document.getElementById(prefix + 'filters');
                if (filtersInput && bb.unet.filters) filtersInput.value = bb.unet.filters;

                const osSelect = document.getElementById(prefix + 'output-stride');
                if (osSelect && bb.unet.output_stride) osSelect.value = bb.unet.output_stride;
            }

            // Apply head config (sigma, output_stride)
            const heads = mc.head_configs || {};
            const headConfig = heads.single_instance || heads.centroid || heads.centered_instance ||
                              heads.bottomup || heads.multi_class_bottomup || heads.multi_class_topdown;
            if (headConfig?.confmaps) {
                const sigmaInput = document.getElementById(prefix + 'sigma');
                if (sigmaInput && headConfig.confmaps.sigma) sigmaInput.value = headConfig.confmaps.sigma;

                const osSelect = document.getElementById(prefix + 'output-stride');
                if (osSelect && headConfig.confmaps.output_stride) osSelect.value = headConfig.confmaps.output_stride;

                if (headConfig.confmaps.anchor_part) {
                    // Store for later application after anchor list is populated
                    config._anchorPart = headConfig.confmaps.anchor_part;
                }
            }

            // Apply trainer config - handle both flat and nested structures
            const batchSize = tc.batch_size || tc.train_data_loader?.batch_size;
            const bsInput = document.getElementById(prefix + 'batch-size');
            if (bsInput && batchSize) bsInput.value = batchSize;

            const epochsInput = document.getElementById(prefix + 'max-epochs');
            if (epochsInput && tc.max_epochs) epochsInput.value = tc.max_epochs;

            const lrInput = document.getElementById(prefix + 'learning-rate');
            if (lrInput && tc.optimizer?.lr) lrInput.value = tc.optimizer.lr;

            // Handle optimizer_name (flat) or optimizer.name (nested)
            const optimizerName = tc.optimizer_name || tc.optimizer?.name;
            const optSelect = document.getElementById(prefix + 'optimizer');
            if (optSelect && optimizerName) optSelect.value = optimizerName;

            // Apply augmentation toggle
            const augToggle = document.getElementById(prefix + 'use-augmentation');
            if (augToggle && ((aug && (aug.intensity || aug.geometric)) || dc.use_augmentations_train)) {
                augToggle.checked = true;
            }

            // Apply num_workers
            const numWorkers = tc.train_data_loader?.num_workers;
            const nwSelect = document.getElementById(prefix + 'num-workers');
            if (nwSelect && numWorkers !== undefined) nwSelect.value = numWorkers;

            // Apply data pipeline
            const dataPipeline = dc.data_pipeline_fw;
            const dpSelect = document.getElementById(prefix + 'data-pipeline');
            if (dpSelect && dataPipeline) {
                if (dataPipeline.includes('cache_img_memory')) dpSelect.value = 'torch_dataset_cache_img_memory';
                else if (dataPipeline.includes('cache_img_disk')) dpSelect.value = 'torch_dataset_cache_img_disk';
                else dpSelect.value = 'torch_dataset';
            }

            // Apply checkpoint settings
            const ckptDirInput = document.getElementById(prefix + 'ckpt-dir');
            if (ckptDirInput && tc.ckpt_dir) ckptDirInput.value = tc.ckpt_dir;

            const runNameInput = document.getElementById(prefix + 'run-name');
            if (runNameInput && tc.run_name) runNameInput.value = tc.run_name;

            const saveTopKInput = document.getElementById(prefix + 'ckpt-save-top-k');
            if (saveTopKInput && tc.model_ckpt?.save_top_k) saveTopKInput.value = tc.model_ckpt.save_top_k;

            const saveLastCheckbox = document.getElementById(prefix + 'ckpt-save-last');
            if (saveLastCheckbox && tc.model_ckpt?.save_last !== undefined) saveLastCheckbox.checked = tc.model_ckpt.save_last;

            const saveCkptCheckbox = document.getElementById(prefix + 'save-ckpt');
            if (saveCkptCheckbox && tc.save_ckpt !== undefined) saveCkptCheckbox.checked = tc.save_ckpt;

            // Apply wandb settings
            const useWandbCheckbox = document.getElementById(prefix + 'enable-wandb');
            if (useWandbCheckbox && tc.use_wandb !== undefined) useWandbCheckbox.checked = tc.use_wandb;

            // Apply wandb project
            const wandbProjectInput = document.getElementById(prefix + 'wandb-project');
            if (wandbProjectInput && tc.wandb?.project) wandbProjectInput.value = tc.wandb.project;

            // Apply early stopping (no prefix for main tab)
            const earlyStopCheckbox = document.getElementById(isCITab ? 'ci-early-stopping' : 'early-stopping');
            if (earlyStopCheckbox && tc.early_stopping?.stop_training_on_plateau !== undefined) {
                earlyStopCheckbox.checked = tc.early_stopping.stop_training_on_plateau;
            }

            // Apply OHKM
            const ohkmCheckbox = document.getElementById(prefix + 'enable-ohkm');
            if (ohkmCheckbox && tc.online_hard_keypoint_mining?.online_mining !== undefined) {
                ohkmCheckbox.checked = tc.online_hard_keypoint_mining.online_mining;
            }

            // Apply min_crop_size for CI
            if (isCITab && prep.min_crop_size) {
                const minCropInput = document.getElementById('min-crop-size');
                if (minCropInput) minCropInput.value = prep.min_crop_size;
            }

            // Apply validation fraction
            if (dc.validation_fraction !== undefined) {
                const valFracSlider = document.getElementById(prefix + 'val-fraction');
                if (valFracSlider) valFracSlider.value = dc.validation_fraction;
            }

            console.log(`Applied ${tabType} config to form fields`);
        }

        async function handleVideoFile(file) {
            const url = URL.createObjectURL(file);
            videoElement = document.createElement('video');
            videoElement.src = url;
            videoElement.muted = true;

            videoElement.addEventListener('loadeddata', () => {
                // Seek to first frame
                videoElement.currentTime = 0;
            });

            videoElement.addEventListener('seeked', async () => {
                // Capture first frame
                const canvas = document.createElement('canvas');
                canvas.width = videoElement.videoWidth;
                canvas.height = videoElement.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(videoElement, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                firstFrame = {
                    data: new Uint8Array(imageData.data),
                    width: canvas.width,
                    height: canvas.height,
                    channels: 4  // RGBA from canvas
                };

                // Create ImageBitmap for reliable drawing in anchor visualization
                try {
                    videoFrame = await createImageBitmap(videoElement);
                } catch (e) {
                    console.warn('Could not create ImageBitmap from video:', e);
                    // Fallback: create from canvas
                    videoFrame = await createImageBitmap(canvas);
                }

                // Update image dimensions if they differ
                if (slpData && (slpData.imgWidth !== canvas.width || slpData.imgHeight !== canvas.height)) {
                    slpData.imgWidth = canvas.width;
                    slpData.imgHeight = canvas.height;
                }

                // Hide video upload section, redraw
                document.getElementById('video-upload-section').classList.add('hidden');
                drawFramePreview();
                updateRFVisualization();
                updateEffectiveSize();
                // Redraw anchor preview with new video frame
                if (selectedAnchor !== null || instancesData) {
                    drawAnchorPreview(selectedAnchor);
                }
            });

            videoElement.load();
        }

        async function handleFile(file) {
            if (!file.name.endsWith('.slp')) {
                alert('Please upload a .slp file');
                return;
            }

            document.getElementById('loading-status').classList.remove('hidden');
            document.getElementById('upload-zone').classList.add('hidden');

            try {
                await h5wasm.ready;
                const arrayBuffer = await file.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);

                h5wasm.FS.writeFile('temp.slp', uint8Array);
                const h5file = new h5wasm.File('temp.slp', 'r');

                slpData = parseSlpFile(h5file, file.name);

                // Try to load first frame
                await loadFirstFrame(h5file);

                h5file.close();
                h5wasm.FS.unlink('temp.slp');

                displayDataSummary();
                const recommendedModel = populateModelTypes();
                setDefaultParameters();
                // Auto-select recommended model AFTER setDefaultParameters to ensure scale is set correctly
                selectModelType(recommendedModel);
                // Apply loaded configs if any were loaded before SLP
                if (loadedCentroidConfig || loadedCIConfig) {
                    applyLoadedConfig();
                }
                document.getElementById('next-btn').disabled = false;
                document.getElementById('step1').classList.add('completed');

            } catch (err) {
                console.error('Error loading SLP:', err);
                alert('Error loading SLP file: ' + err.message);
                document.getElementById('upload-zone').classList.remove('hidden');
            } finally {
                document.getElementById('loading-status').classList.add('hidden');
            }
        }

        function parseSlpFile(h5file, filename) {
            // Parse metadata
            const metadataGroup = h5file.get('metadata');
            const jsonAttr = metadataGroup.attrs['json'];
            const jsonStr = typeof jsonAttr.value === 'string' ? jsonAttr.value : new TextDecoder().decode(jsonAttr.value);
            const metadata = JSON.parse(jsonStr);

            // Parse skeleton - use first skeleton only
            // firstSkeleton.nodes contains {id: N} references into metadata.nodes
            const firstSkeleton = metadata.skeletons?.[0];

            // Get only nodes belonging to first skeleton
            let nodes = [];
            let nodeIdToIndex = {}; // Map original node id to new index in filtered array

            if (firstSkeleton?.nodes && Array.isArray(firstSkeleton.nodes)) {
                for (let i = 0; i < firstSkeleton.nodes.length; i++) {
                    const nodeRef = firstSkeleton.nodes[i];
                    const nodeId = nodeRef.id ?? nodeRef; // Handle both {id: N} and plain N
                    const node = metadata.nodes[nodeId];
                    nodes.push(node?.name || `node${nodeId}`);
                    nodeIdToIndex[nodeId] = i;
                }
            } else {
                // Fallback: use all nodes
                nodes = metadata.nodes.map(n => n.name || n);
                metadata.nodes.forEach((_, i) => nodeIdToIndex[i] = i);
            }

            // Parse edges from first skeleton's links, remapping indices
            const edges = [];
            if (firstSkeleton?.links) {
                for (const link of firstSkeleton.links) {
                    const srcIdx = link.source;
                    const dstIdx = link.target;
                    if (typeof srcIdx === 'number' && typeof dstIdx === 'number') {
                        // Remap to filtered node indices
                        const newSrc = nodeIdToIndex[srcIdx];
                        const newDst = nodeIdToIndex[dstIdx];
                        if (newSrc !== undefined && newDst !== undefined) {
                            edges.push([newSrc, newDst]);
                        }
                    }
                }
            }

            // Parse videos
            let imgWidth = 640, imgHeight = 480, numChannels = 1;
            try {
                const videosDataset = h5file.get('videos_json');
                if (videosDataset && videosDataset.shape[0] > 0) {
                    const videoJson = JSON.parse(videosDataset.value[0]);
                    const backend = videoJson.backend || {};
                    if (backend.shape) {
                        [, imgHeight, imgWidth, numChannels] = backend.shape;
                    }
                }
            } catch (e) {
                console.warn('Could not parse video info:', e);
            }

            // Parse frames - build mapping of frame_id -> frame_idx
            const framesDataset = h5file.get('frames');
            const numFrames = framesDataset ? framesDataset.shape[0] : 0;

            // Build frame mapping: frame_id -> {videoIdx, frameIdx}
            const frameIdToFrameInfo = {};
            let firstLabeledFrameId = null;  // The frame_id for the first labeled frame (index 0)
            let firstLabeledVideoIdx = 0;    // Which video contains the first labeled frame
            let firstLabeledFrameIdx = 0;    // The frame_idx within that video

            if (framesDataset && framesDataset.shape[0] > 0) {
                const framesRaw = framesDataset.value;
                const isFramesArray = Array.isArray(framesRaw) && framesRaw.length > 0 && Array.isArray(framesRaw[0]);

                for (let i = 0; i < framesDataset.shape[0]; i++) {
                    let frameId, videoIdx, frameIdx;
                    try {
                        if (isFramesArray) {
                            // [frame_id, video, frame_idx, instance_id_start, instance_id_end]
                            frameId = framesRaw[i][0];
                            videoIdx = framesRaw[i][1];
                            frameIdx = framesRaw[i][2];
                        } else if (framesRaw.frame_id) {
                            frameId = framesRaw.frame_id[i];
                            videoIdx = framesRaw.video ? framesRaw.video[i] : 0;
                            frameIdx = framesRaw.frame_idx[i];
                        } else continue;

                        frameIdToFrameInfo[frameId] = { videoIdx, frameIdx };

                        // Track the first labeled frame (frame_id = 0 or first in list)
                        if (firstLabeledFrameId === null || frameId === 0) {
                            firstLabeledFrameId = frameId;
                            firstLabeledVideoIdx = videoIdx;
                            firstLabeledFrameIdx = frameIdx;
                        }
                    } catch (e) { continue; }
                }
            }

            // Parse instances and calculate keypoint visibility
            const instancesDataset = h5file.get('instances');
            const pointsDataset = h5file.get('points');

            let maxInstancesPerFrame = 1;
            let bboxSizes = [];
            let keypointVisibility = {};
            nodes.forEach(n => keypointVisibility[n] = { visible: 0, total: 0 });

            // Store sample instance for anchor visualization - prioritize first labeled frame
            let sampleInstance = null;
            let sampleInstanceFrameIdx = Infinity;  // Track which frame the sample is from

            // Track bboxes per frame for overlap calculation (defined outside if block)
            const frameBboxes = {};

            // Check for points in different locations (newer SLP formats may use pred_points)
            const predPointsDataset = h5file.get('pred_points') || h5file.get('predicted_points');

            // Try points first if it has data, otherwise fall back to pred_points
            const effectivePointsDataset = (pointsDataset && pointsDataset.shape[0] > 0) ? pointsDataset : predPointsDataset;

            if (instancesDataset && effectivePointsDataset) {
                const instancesRaw = instancesDataset.value;
                const pointsRaw = effectivePointsDataset.value;

                const isInstancesArray = Array.isArray(instancesRaw) && instancesRaw.length > 0 && Array.isArray(instancesRaw[0]);
                const isPointsArray = Array.isArray(pointsRaw) && pointsRaw.length > 0 && Array.isArray(pointsRaw[0]);

                const frameCounts = {};
                let numInstances = isInstancesArray ? instancesRaw.length : (instancesRaw.instance_id ? instancesRaw.instance_id.length : 0);

                for (let i = 0; i < numInstances; i++) {
                    let frameId, pointStart, pointEnd;
                    try {
                        if (isInstancesArray) {
                            frameId = instancesRaw[i][2];
                            pointStart = instancesRaw[i][7];
                            pointEnd = instancesRaw[i][8];
                        } else if (instancesRaw.frame_id) {
                            frameId = instancesRaw.frame_id[i];
                            pointStart = instancesRaw.point_id_start[i];
                            pointEnd = instancesRaw.point_id_end[i];
                        } else continue;
                    } catch (e) { continue; }

                    frameCounts[frameId] = (frameCounts[frameId] || 0) + 1;

                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;
                    let hasValidPoints = false;
                    let nodeIdx = 0;
                    let instancePoints = [];

                    for (let p = pointStart; p < pointEnd && nodeIdx < nodes.length; p++) {
                        let x, y, visible;
                        try {
                            if (isPointsArray) {
                                // Points stored as array of arrays: [x, y, visible, complete] or [x, y]
                                const pt = pointsRaw[p];
                                x = pt[0];
                                y = pt[1];
                                visible = pt.length > 2 ? pt[2] : true;
                            } else if (pointsRaw.x) {
                                // Points stored as structured object: {x: [...], y: [...], visible: [...]}
                                x = pointsRaw.x[p];
                                y = pointsRaw.y[p];
                                visible = pointsRaw.visible ? pointsRaw.visible[p] : true;
                            } else {
                                nodeIdx++;
                                continue;
                            }
                        } catch (e) { nodeIdx++; continue; }

                        // Track keypoint visibility - check if point has valid coordinates
                        const hasCoords = !isNaN(x) && !isNaN(y) && x !== null && y !== null && isFinite(x) && isFinite(y);
                        keypointVisibility[nodes[nodeIdx]].total++;

                        if (hasCoords) {
                            keypointVisibility[nodes[nodeIdx]].visible++;
                            minX = Math.min(minX, x);
                            maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y);
                            maxY = Math.max(maxY, y);
                            hasValidPoints = true;
                            instancePoints.push({ node: nodes[nodeIdx], x, y });
                        }
                        nodeIdx++;
                    }

                    if (hasValidPoints && minX !== Infinity) {
                        const bboxW = maxX - minX;
                        const bboxH = maxY - minY;
                        const bboxDiag = Math.sqrt(bboxW ** 2 + bboxH ** 2);
                        if (bboxDiag > 0 && bboxDiag < 10000) {
                            bboxSizes.push({ diag: bboxDiag, width: bboxW, height: bboxH });

                            // Store bbox per frame for overlap calculation
                            if (!frameBboxes[frameId]) frameBboxes[frameId] = [];
                            frameBboxes[frameId].push({ minX, minY, maxX, maxY });
                        }

                        // Store best instance for visualization - MUST match the frame we'll load
                        // Only use instances from firstLabeledFrameId to ensure skeleton aligns with video
                        if (instancePoints.length >= nodes.length * 0.5) {
                            const thisFrameInfo = frameIdToFrameInfo[frameId];
                            const thisVideoIdx = Number(thisFrameInfo?.videoIdx ?? -1);
                            const thisFrameIdx = Number(thisFrameInfo?.frameIdx ?? -1);

                            // Check if this instance is from the frame we'll load
                            const isFromLoadedFrame = (thisVideoIdx === firstLabeledVideoIdx &&
                                                       thisFrameIdx === Number(firstLabeledFrameIdx));

                            // Prefer instances from the frame we'll load; fall back to any frame if needed
                            const currentIsFromLoadedFrame = sampleInstance &&
                                (sampleInstance.videoIdx === firstLabeledVideoIdx &&
                                 sampleInstance.frameIdx === Number(firstLabeledFrameIdx));

                            // Update sample if:
                            // 1. We don't have one yet, OR
                            // 2. This is from the loaded frame and current isn't, OR
                            // 3. Both from same frame category, but this has more keypoints
                            const shouldUpdate = !sampleInstance ||
                                (isFromLoadedFrame && !currentIsFromLoadedFrame) ||
                                (isFromLoadedFrame === currentIsFromLoadedFrame && instancePoints.length > sampleInstance.points.length);

                            if (shouldUpdate) {
                                sampleInstance = {
                                    points: instancePoints,
                                    bbox: { minX, minY, maxX, maxY },
                                    frameIdx: thisFrameIdx,
                                    videoIdx: thisVideoIdx
                                };
                                sampleInstanceFrameIdx = thisFrameIdx;
                            }
                        }
                    }
                }

                const frameCountValues = Object.values(frameCounts);
                maxInstancesPerFrame = frameCountValues.length > 0 ? Math.max(...frameCountValues) : 1;
            }

            // Store sample instance globally
            instancesData = sampleInstance;

            // Parse tracks - follows slp-worker pattern
            let tracks = [];
            try {
                const tracksDataset = h5file.get('tracks_json');
                if (tracksDataset && tracksDataset.shape[0] > 0) {
                    tracks = Array.from(tracksDataset.value).map(t => {
                        let name = t;
                        if (typeof t === 'string') {
                            try {
                                const parsed = JSON.parse(t);
                                name = parsed.name || parsed.py_state?.values?.[0] || String(parsed);
                            } catch {
                                name = t;
                            }
                        }
                        // Convert to string and clean up
                        name = String(name);
                        // Remove leading parenthesis, number, comma pattern: "(0, " or "0," or "0.0,"
                        name = name.replace(/^\(?\s*\d+\.?\d*\s*,\s*/, '');
                        // Remove trailing parenthesis
                        name = name.replace(/\s*\)$/, '');
                        // Remove surrounding quotes
                        name = name.replace(/^['"]|['"]$/g, '');
                        return name;
                    });
                }
            } catch (e) {}

            // Calculate size statistics (bboxSizes is now array of {diag, width, height})
            // Use maxDim (max of width, height) like PR28 for instance size
            const maxDims = bboxSizes.map(b => Math.max(b.width, b.height));
            const diags = bboxSizes.map(b => b.diag);
            const widths = bboxSizes.map(b => b.width);
            const heights = bboxSizes.map(b => b.height);

            // Helper function to compute percentile (robust to outliers)
            function percentile(arr, p) {
                if (arr.length === 0) return 0;
                const sorted = [...arr].sort((a, b) => a - b);
                const idx = Math.ceil((p / 100) * sorted.length) - 1;
                return sorted[Math.max(0, idx)];
            }

            const avgMaxDim = maxDims.length > 0 ? maxDims.reduce((a, b) => a + b) / maxDims.length : 100;
            // Use 99th percentile instead of absolute max to handle extreme outliers
            // This filters out ~1% of extreme values (tracking errors, annotation mistakes)
            const maxMaxDim = maxDims.length > 0 ? percentile(maxDims, 99) : 150;
            const avgAnimalSize = diags.length > 0 ? diags.reduce((a, b) => a + b) / diags.length : 100;
            const maxAnimalSize = diags.length > 0 ? percentile(diags, 99) : 150;
            const avgWidth = widths.length > 0 ? widths.reduce((a, b) => a + b) / widths.length : 80;
            const avgHeight = heights.length > 0 ? heights.reduce((a, b) => a + b) / heights.length : 80;
            const maxWidth = widths.length > 0 ? percentile(widths, 99) : 100;
            const maxHeight = heights.length > 0 ? percentile(heights, 99) : 100;

            // Calculate overlap and centroid distance statistics
            function bboxIoU(a, b) {
                // Compute intersection
                const interMinX = Math.max(a.minX, b.minX);
                const interMinY = Math.max(a.minY, b.minY);
                const interMaxX = Math.min(a.maxX, b.maxX);
                const interMaxY = Math.min(a.maxY, b.maxY);

                const interW = Math.max(0, interMaxX - interMinX);
                const interH = Math.max(0, interMaxY - interMinY);
                const interArea = interW * interH;

                if (interArea === 0) return 0;

                // Compute union
                const areaA = (a.maxX - a.minX) * (a.maxY - a.minY);
                const areaB = (b.maxX - b.minX) * (b.maxY - b.minY);
                const unionArea = areaA + areaB - interArea;

                return unionArea > 0 ? interArea / unionArea : 0;
            }

            function bboxCentroid(bbox) {
                return {
                    x: (bbox.minX + bbox.maxX) / 2,
                    y: (bbox.minY + bbox.maxY) / 2
                };
            }

            function centroidDistance(a, b) {
                const ca = bboxCentroid(a);
                const cb = bboxCentroid(b);
                return Math.sqrt((ca.x - cb.x) ** 2 + (ca.y - cb.y) ** 2);
            }

            const IOU_THRESHOLD = 0.2;
            let framesWithSignificantOverlap = 0;
            let multiInstanceFrames = 0;
            let maxIoU = 0;
            const allCentroidDistances = [];
            for (const frameId in frameBboxes) {
                const boxes = frameBboxes[frameId];
                if (boxes.length > 1) {
                    multiInstanceFrames++;
                    // Check if any pair of boxes has IoU > threshold and compute centroid distances
                    let hasSignificantOverlap = false;
                    for (let i = 0; i < boxes.length; i++) {
                        for (let j = i + 1; j < boxes.length; j++) {
                            const iou = bboxIoU(boxes[i], boxes[j]);
                            if (iou > maxIoU) maxIoU = iou;
                            if (iou > IOU_THRESHOLD) {
                                hasSignificantOverlap = true;
                            }
                            // Compute centroid distance between each pair
                            const dist = centroidDistance(boxes[i], boxes[j]);
                            if (dist > 0) allCentroidDistances.push(dist);
                        }
                    }
                    if (hasSignificantOverlap) framesWithSignificantOverlap++;
                }
            }
            const overlapFrequency = multiInstanceFrames > 0 ? framesWithSignificantOverlap / multiInstanceFrames : 0;
            const minCentroidDist = allCentroidDistances.length > 0 ? Math.min(...allCentroidDistances) : null;
            const avgCentroidDist = allCentroidDistances.length > 0 ? allCentroidDistances.reduce((a, b) => a + b, 0) / allCentroidDistances.length : null;

            return {
                filename,
                skeleton: { nodes, edges, name: metadata.skeletons?.[0]?.graph?.name || 'Skeleton' },
                imgWidth,
                imgHeight,
                numChannels,
                numFrames,
                maxInstancesPerFrame,
                avgAnimalSize: Math.round(avgAnimalSize),
                maxAnimalSize: Math.round(maxAnimalSize),
                avgMaxDim: Math.round(avgMaxDim),
                maxMaxDim: Math.round(maxMaxDim),
                avgWidth: Math.round(avgWidth),
                avgHeight: Math.round(avgHeight),
                maxWidth: Math.round(maxWidth),
                maxHeight: Math.round(maxHeight),
                overlapFrequency,
                maxIoU,
                multiInstanceFrames,
                framesWithSignificantOverlap,
                minCentroidDist,
                avgCentroidDist,
                tracks,
                numTracks: tracks.length,
                keypointVisibility,
                totalInstances: bboxSizes.length,  // Total valid instances for CI training
                // For pkg.slp: which video and frame index to load
                firstLabeledVideoIdx,
                firstLabeledFrameIdx
            };
        }

        async function loadFirstFrame(h5file) {
            // Try to load embedded video frame
            // For pkg.slp files, frames are stored per-video and we need to find the right one
            try {
                // Determine which video to load from
                const videoIdx = slpData?.firstLabeledVideoIdx || 0;
                const targetFrameIdx = slpData?.firstLabeledFrameIdx || 0;
                const videoKey = `video${videoIdx}/video`;

                console.log(`Loading frame from video${videoIdx}, target frame_idx=${targetFrameIdx}`);

                let videoDataset = h5file.get(videoKey);
                // Fallback to video0 if the target video doesn't exist
                if (!videoDataset) {
                    console.log(`video${videoIdx} not found, falling back to video0`);
                    videoDataset = h5file.get('video0/video');
                }

                const video0 = videoDataset;
                if (video0 && video0.shape) {
                    // Check if this is a pkg.slp (PNG-encoded frames) or raw pixel data
                    // pkg.slp: shape is (numFrames,) with dtype=object (PNG bytes per frame)
                    // Regular embedded: shape is (numFrames, height, width, channels)

                    if (video0.shape.length === 1) {
                        // pkg.slp format: frames stored as PNG-encoded bytes (variable-length arrays)
                        console.log('Detected pkg.slp format (PNG-encoded frames)');
                        try {
                            // Find the correct frame index within this video
                            // video{N}/frame_numbers contains the original video frame indices
                            let frameIndexInVideo = 0;
                            const frameNumbersKey = `video${videoIdx}/frame_numbers`;
                            const frameNumbersDataset = h5file.get(frameNumbersKey);
                            if (frameNumbersDataset) {
                                const frameNumbers = frameNumbersDataset.value;
                                // Find the index where frame_numbers matches targetFrameIdx
                                // Use Number() to handle BigInt comparison
                                const targetNum = Number(targetFrameIdx);
                                for (let i = 0; i < frameNumbers.length; i++) {
                                    if (Number(frameNumbers[i]) === targetNum) {
                                        frameIndexInVideo = i;
                                        break;
                                    }
                                }
                                console.log(`Found frame_idx ${targetFrameIdx} at index ${frameIndexInVideo} in video${videoIdx} (frame_numbers: ${Array.from(frameNumbers).slice(0, 5).join(', ')}...)`);
                            }

                            // For variable-length datasets, read the whole dataset
                            // h5wasm returns an array of arrays for vlen data
                            const allFrames = video0.value;

                            if (allFrames && allFrames.length > 0) {
                                // Get the correct frame's PNG data
                                const pngData = allFrames[frameIndexInVideo] || allFrames[0];

                                if (pngData && pngData.length > 0) {
                                    // Convert int8 array to Uint8Array for Blob
                                    const uint8Data = new Uint8Array(pngData.length);
                                    for (let i = 0; i < pngData.length; i++) {
                                        uint8Data[i] = pngData[i] < 0 ? pngData[i] + 256 : pngData[i];
                                    }

                                    // Create blob and decode PNG
                                    const blob = new Blob([uint8Data], { type: 'image/png' });
                                    const bitmap = await createImageBitmap(blob);

                                    // Store frame info
                                    firstFrame = {
                                        data: null, // Will use bitmap directly
                                        width: bitmap.width,
                                        height: bitmap.height,
                                        channels: slpData?.numChannels || 1,
                                        bitmap: bitmap
                                    };
                                    videoFrame = bitmap;

                                    // Update slpData dimensions if they differ (pkg.slp may have incorrect metadata)
                                    if (slpData && (slpData.imgWidth !== bitmap.width || slpData.imgHeight !== bitmap.height)) {
                                        console.log(`Updating dimensions from ${slpData.imgWidth}x${slpData.imgHeight} to ${bitmap.width}x${bitmap.height}`);
                                        slpData.imgWidth = bitmap.width;
                                        slpData.imgHeight = bitmap.height;
                                    }

                                    console.log(`Loaded pkg.slp frame: ${bitmap.width}x${bitmap.height}`);
                                }
                            }
                        } catch (e) {
                            console.warn('Could not decode pkg.slp PNG frame:', e);
                        }
                    } else if (video0.shape.length === 4) {
                        // Regular embedded video: raw pixel data
                        const [numFrames, height, width, channels] = video0.shape;
                        // Read first frame
                        const frameData = video0.slice([[0, 1]]);
                        if (frameData) {
                            firstFrame = {
                                data: new Uint8Array(frameData),
                                width,
                                height,
                                channels
                            };

                            // Create ImageBitmap for reliable drawing
                            try {
                                const canvas = createFrameCanvas();
                                if (canvas) {
                                    videoFrame = await createImageBitmap(canvas);
                                }
                            } catch (e) {
                                console.warn('Could not create ImageBitmap from embedded frame:', e);
                            }
                        }
                    }
                }
            } catch (e) {
                console.warn('Could not load embedded video frame:', e);
            }
        }

        function displayDataSummary() {
            document.getElementById('data-summary').classList.remove('hidden');
            document.getElementById('file-name-badge').textContent = slpData.filename;

            // Build overlap display: "x% with 0.2 IoU (max: y)"
            let overlapDisplay = '-';
            let overlapClass = '';
            let overlapTitle = 'Percentage of multi-instance frames with IoU > 0.2';
            if (slpData.maxInstancesPerFrame > 1) {
                const overlapPct = Math.round(slpData.overlapFrequency * 100);
                const maxIoUDisplay = slpData.maxIoU.toFixed(2);
                overlapDisplay = `${overlapPct}%`;
                overlapTitle = `${overlapPct}% of frames have IoU > 0.2 overlap\nMax IoU observed: ${maxIoUDisplay}`;
                if (overlapPct > 40) overlapClass = 'style="color: #f59e0b;"'; // warning color for high overlap
            }

            const statsHtml = `
                <div class="stat-item">
                    <div class="stat-value">${slpData.numFrames}</div>
                    <div class="stat-label">Labeled Frames</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${slpData.totalInstances}</div>
                    <div class="stat-label">Total Instances</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${slpData.imgWidth}x${slpData.imgHeight}</div>
                    <div class="stat-label">Image Size</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${slpData.numChannels === 1 ? 'Gray' : 'RGB'}</div>
                    <div class="stat-label">Color Mode</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${slpData.maxInstancesPerFrame}</div>
                    <div class="stat-label">Max Animals</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" title="99th percentile bbox dimension (robust to outliers)&#10;P99: ~${slpData.maxMaxDim}px&#10;Avg: ~${slpData.avgMaxDim}px&#10;P99 WÃ—H: ~${slpData.maxWidth}Ã—${slpData.maxHeight}px">~${slpData.maxMaxDim}px</div>
                    <div class="stat-label">Max Instance Size</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" ${overlapClass} title="${overlapTitle}">${overlapDisplay}</div>
                    <div class="stat-label">Overlap (IoU&gt;0.2)${slpData.maxInstancesPerFrame > 1 ? '<br><small style="color: var(--text-dim);">max: ' + slpData.maxIoU.toFixed(2) + '</small>' : ''}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${slpData.skeleton.nodes.length}</div>
                    <div class="stat-label">Keypoints</div>
                </div>
            `;
            document.getElementById('stats-grid').innerHTML = statsHtml;

            // Format edges as node name pairs
            const edgeStrs = slpData.skeleton.edges.map(e => {
                const src = slpData.skeleton.nodes[e[0]] || `node${e[0]}`;
                const dst = slpData.skeleton.nodes[e[1]] || `node${e[1]}`;
                return `${src}â†’${dst}`;
            });

            const skeletonInfo = `
                <div style="background: #333; padding: 10px; border-radius: 6px; font-size: 0.85rem;">
                    <strong>Skeleton:</strong> ${slpData.skeleton.name}<br>
                    <strong>Nodes (${slpData.skeleton.nodes.length}):</strong> ${slpData.skeleton.nodes.join(', ')}<br>
                    <strong>Edges (${slpData.skeleton.edges.length}):</strong> ${edgeStrs.length > 0 ? edgeStrs.join(', ') : 'None'}<br>
                    ${slpData.numTracks > 0 ? `<strong>Tracks (${slpData.numTracks}):</strong> ${slpData.tracks.join(', ')}` : '<span style="color: #888;">No tracks (identity models disabled)</span>'}
                </div>
            `;
            document.getElementById('skeleton-info').innerHTML = skeletonInfo;

            // Show video upload section if no embedded video
            if (!firstFrame) {
                document.getElementById('video-upload-section').classList.remove('hidden');
            }

            // Always show config upload section
            document.getElementById('config-upload-section').classList.remove('hidden');

            // Draw frame if available
            drawFramePreview();
        }

        // Create a canvas from firstFrame data (for use as image source)
        function createFrameCanvas() {
            if (!firstFrame) return null;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = firstFrame.width;
            tempCanvas.height = firstFrame.height;
            const ctx = tempCanvas.getContext('2d');

            // If we have a bitmap (from pkg.slp), draw it directly
            if (firstFrame.bitmap) {
                ctx.drawImage(firstFrame.bitmap, 0, 0);
                return tempCanvas;
            }

            // Otherwise, create from raw pixel data
            if (!firstFrame.data) return null;

            const imageData = ctx.createImageData(firstFrame.width, firstFrame.height);
            const pixels = imageData.data;

            for (let i = 0; i < firstFrame.width * firstFrame.height; i++) {
                if (firstFrame.channels === 1) {
                    const val = firstFrame.data[i];
                    pixels[i * 4] = val;
                    pixels[i * 4 + 1] = val;
                    pixels[i * 4 + 2] = val;
                    pixels[i * 4 + 3] = 255;
                } else if (firstFrame.channels === 4) {
                    pixels[i * 4] = firstFrame.data[i * 4];
                    pixels[i * 4 + 1] = firstFrame.data[i * 4 + 1];
                    pixels[i * 4 + 2] = firstFrame.data[i * 4 + 2];
                    pixels[i * 4 + 3] = 255;
                } else {
                    pixels[i * 4] = firstFrame.data[i * firstFrame.channels];
                    pixels[i * 4 + 1] = firstFrame.data[i * firstFrame.channels + 1];
                    pixels[i * 4 + 2] = firstFrame.data[i * firstFrame.channels + 2];
                    pixels[i * 4 + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            return tempCanvas;
        }

        // Distance statistics for sigma guide
        let distanceStats = {
            minKeypointDist: null,
            avgKeypointDist: null,
            minCentroidDist: null,
            avgCentroidDist: null
        };

        // Compute inter-keypoint distances from skeleton edges and centroid distances
        function computeKeypointDistances() {
            if (!slpData || !instancesData) return;

            const edges = slpData.skeleton.edges || [];
            const points = instancesData.points;
            const allEdgeDists = [];

            // Compute distances for each edge in skeleton
            for (const [srcIdx, dstIdx] of edges) {
                const srcNode = slpData.skeleton.nodes[srcIdx];
                const dstNode = slpData.skeleton.nodes[dstIdx];
                const srcPt = points.find(p => p.node === srcNode);
                const dstPt = points.find(p => p.node === dstNode);

                if (srcPt && dstPt) {
                    const dx = srcPt.x - dstPt.x;
                    const dy = srcPt.y - dstPt.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) allEdgeDists.push(dist);
                }
            }

            if (allEdgeDists.length > 0) {
                distanceStats.minKeypointDist = Math.min(...allEdgeDists);
                distanceStats.avgKeypointDist = allEdgeDists.reduce((a, b) => a + b, 0) / allEdgeDists.length;
            }

            // Use centroid distances computed during SLP parsing (for multi-instance frames)
            if (slpData.minCentroidDist) {
                distanceStats.minCentroidDist = slpData.minCentroidDist;
                distanceStats.avgCentroidDist = slpData.avgCentroidDist;
            }
        }

        // Draw sigma Gaussian visualization on canvas
        function drawSigmaVisualization(canvasId, sigma, outputStride = 1) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;

            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            // Effective sigma in pixels (scaled for visualization)
            const effectiveSigma = sigma * outputStride;
            const scaleFactor = 2; // Scale up for visibility
            const vizSigma = effectiveSigma * scaleFactor;

            // Draw Gaussian as radial gradient
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, vizSigma * 2);
            gradient.addColorStop(0, 'rgba(102, 126, 234, 0.9)');     // Center: accent color
            gradient.addColorStop(0.5, 'rgba(102, 126, 234, 0.4)');   // At 1Ïƒ
            gradient.addColorStop(1, 'rgba(102, 126, 234, 0.05)');    // At 2Ïƒ

            ctx.beginPath();
            ctx.arc(centerX, centerY, vizSigma * 2, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Draw dashed circle at 2Ïƒ (95% coverage)
            ctx.beginPath();
            ctx.arc(centerX, centerY, vizSigma * 2, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(102, 126, 234, 0.6)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw crosshair
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();

            // Draw center dot
            ctx.beginPath();
            ctx.arc(centerX, centerY, 2, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
        }

        // Update main tab sigma visualization
        function updateSigmaVisualization() {
            const sigma = parseFloat(document.getElementById('sigma')?.value) || 5.0;
            const outputStride = parseInt(document.getElementById('output-stride')?.value) || 1;

            // Draw visualization
            drawSigmaVisualization('sigma-viz', sigma, outputStride);

            // Update info text
            const effectiveSigma = sigma * outputStride;
            const radius = Math.round(effectiveSigma * 2);
            document.getElementById('sigma-radius').textContent = radius;

            // Update distance-based suggestions based on model type
            const isCentroid = isTopDown; // Centroid model (main tab in top-down mode)
            const minKeypointDistInfo = document.getElementById('min-keypoint-dist-info');

            if (isCentroid && distanceStats.minCentroidDist) {
                // For centroid model: show centroid distance (relevant for avoiding overlap between animals)
                document.getElementById('sigma-centroid-info').style.display = 'inline';
                document.getElementById('sigma-keypoint-info').style.display = 'none';
                document.getElementById('min-centroid-dist').textContent = Math.round(distanceStats.minCentroidDist);
                document.getElementById('suggested-sigma').textContent = Math.round(distanceStats.minCentroidDist / 4);
                // Hide keypoint distance info for centroid (not relevant - only 1 output channel)
                if (minKeypointDistInfo) minKeypointDistInfo.style.display = 'none';
            } else {
                // For other models: show keypoint info
                document.getElementById('sigma-centroid-info').style.display = 'none';
                document.getElementById('sigma-keypoint-info').style.display = 'inline';
                // Show keypoint distance info
                if (minKeypointDistInfo) minKeypointDistInfo.style.display = 'block';
            }

            // Update min keypoint distance
            if (distanceStats.minKeypointDist) {
                document.getElementById('min-keypoint-dist').textContent = Math.round(distanceStats.minKeypointDist);
            }
        }

        // Update CI tab sigma visualization
        function updateCISigmaVisualization() {
            const sigma = parseFloat(document.getElementById('ci-sigma')?.value) || 2.5;
            const outputStride = parseInt(document.getElementById('ci-output-stride')?.value) || 1;

            // Draw visualization
            drawSigmaVisualization('ci-sigma-viz', sigma, outputStride);

            // Update info text
            const effectiveSigma = sigma * outputStride;
            const radius = Math.round(effectiveSigma * 2);
            const radiusEl = document.getElementById('ci-sigma-radius');
            if (radiusEl) radiusEl.textContent = radius;
        }

        // Update CI model architecture display
        function updateCIModelArchitecture() {
            if (!slpData) return;

            const filters = parseInt(document.getElementById('ci-filters')?.value) || 32;
            const maxStride = parseInt(document.getElementById('ci-max-stride')?.value) || 16;
            const outputStride = parseInt(document.getElementById('ci-output-stride')?.value) || 1;
            const inChannels = parseInt(document.getElementById('ci-input-channels')?.value) || 1;
            const numKeypoints = slpData.skeleton.nodes.length;

            // Calculate params
            const totalParams = estimateParamsAccurate(filters, maxStride, outputStride, inChannels, numKeypoints);
            const downBlocks = Math.log2(maxStride);
            const upBlocks = Math.log2(maxStride) - Math.log2(outputStride);

            // Update display
            document.getElementById('ci-total-params').textContent = `~${(totalParams / 1e6).toFixed(1)}M`;
            document.getElementById('ci-down-blocks').textContent = downBlocks;
            document.getElementById('ci-up-blocks').textContent = upBlocks;

            // Generate architecture diagram - CI is always centered_instance (or multi_class_topdown)
            const archEl = document.getElementById('ci-unet-arch');
            if (archEl) {
                const ciModelType = selectedModelType === 'multi_class_topdown' ? 'multi_class_topdown' : 'centered_instance';
                const numClasses = slpData?.numTracks || 0;
                archEl.innerHTML = generateUNetDiagram(filters, maxStride, outputStride, inChannels, numKeypoints, 1.5, ciModelType, 0, numClasses);
            }
        }

        // Generate UNet architecture diagram as visual HTML (PR28 style)
        // modelType: 'single_instance', 'centroid', 'centered_instance', 'bottomup', 'multi_class_bottomup', 'multi_class_topdown'
        function generateUNetDiagram(filters, maxStride, outputStride, inChannels, numKeypoints, filtersRate = 1.5, modelType = 'single_instance', numEdges = 0, numClasses = 0) {
            const downBlocks = Math.log2(maxStride);
            const upBlocks = Math.log2(maxStride / outputStride);

            // Build encoder layers: channels = filters * rate^block
            let encoderLayers = [];
            let prevCh = inChannels;
            for (let i = 0; i < downBlocks; i++) {
                const outCh = Math.floor(filters * Math.pow(filtersRate, i));
                const stride = Math.pow(2, i + 1);
                encoderLayers.push({ inCh: prevCh, outCh, stride });
                prevCh = outCh;
            }

            // Bottleneck channels
            const lastEncCh = encoderLayers[encoderLayers.length - 1].outCh;
            const bottleneckCh = Math.floor(lastEncCh * filtersRate);

            // Build decoder layers
            let decoderLayers = [];
            let xInCh = bottleneckCh;
            for (let i = 0; i < upBlocks; i++) {
                const decOutCh = Math.floor(filters * Math.pow(filtersRate, downBlocks - 1 - i));
                const skipCh = decOutCh;
                const fromStride = Math.pow(2, downBlocks - i);
                const toStride = Math.pow(2, downBlocks - i - 1);
                decoderLayers.push({ inCh: xInCh, skipCh, outCh: decOutCh, fromStride, toStride });
                xInCh = decOutCh;
            }

            // Build HTML
            let html = '<div class="unet-diagram">';
            html += '<div class="diagram-title">UNet Encoder-Decoder Architecture</div>';

            // Input
            html += `<div class="layer-box input">Input: ${inChannels} ch</div>`;
            html += '<div class="arrow">â†“</div>';

            // Encoder
            html += '<div class="section-label encoder">ENCODER</div>';
            encoderLayers.forEach((layer, i) => {
                const opacity = 0.6 + i * 0.1;
                html += `<div class="layer-box encoder" style="opacity: ${opacity};">`;
                html += `${layer.inCh} â†’ Conv â†’ ${layer.outCh} â†’ Pool â†“${layer.stride}`;
                html += '</div>';
                if (i < encoderLayers.length - 1) html += '<div class="arrow">â†“</div>';
            });

            // Bottleneck
            html += '<div class="arrow">â†“</div>';
            html += `<div class="layer-box bottleneck">Bottleneck: ${lastEncCh} â†’ ${bottleneckCh}</div>`;
            html += '<div class="arrow">â†“</div>';

            // Decoder
            html += '<div class="section-label decoder">DECODER</div>';
            decoderLayers.forEach((layer, i) => {
                const opacity = 0.9 - i * 0.1;
                html += `<div class="layer-box decoder" style="opacity: ${Math.max(0.5, opacity)};">`;
                html += `${layer.inCh} â†’ Up s${layer.fromStride}â†’s${layer.toStride} + Skip(${layer.skipCh}) â†’ ${layer.outCh}`;
                html += '</div>';
                if (i < decoderLayers.length - 1) html += '<div class="arrow">â†“</div>';
            });

            // Head(s) - output channels depend on model type
            const headInputCh = decoderLayers.length > 0 ? decoderLayers[decoderLayers.length - 1].outCh : bottleneckCh;
            html += '<div class="arrow">â†“</div>';

            // Build head output description based on model type
            // Multi-head models have SEPARATE output tensors, not combined
            if (modelType === 'centroid') {
                html += `<div class="layer-box head">Head: ${headInputCh} â†’ 1 (centroid confmap) @ stride ${outputStride}</div>`;
            } else if (modelType === 'bottomup') {
                // Bottom-up has TWO SEPARATE heads with their own output tensors
                const pafChannels = numEdges * 2;
                html += `<div style="display: flex; gap: 8px; flex-wrap: wrap;">`;
                html += `<div class="layer-box head" style="flex: 1; min-width: 120px;">Confmaps Head<br>${headInputCh} â†’ ${numKeypoints} ch</div>`;
                html += `<div class="layer-box head" style="flex: 1; min-width: 120px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">PAFs Head<br>${headInputCh} â†’ ${pafChannels} ch</div>`;
                html += `</div>`;
            } else if (modelType === 'multi_class_bottomup') {
                // Multi-class bottom-up has TWO SEPARATE heads
                html += `<div style="display: flex; gap: 8px; flex-wrap: wrap;">`;
                html += `<div class="layer-box head" style="flex: 1; min-width: 120px;">Confmaps Head<br>${headInputCh} â†’ ${numKeypoints} ch</div>`;
                html += `<div class="layer-box head" style="flex: 1; min-width: 120px; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);">Class Maps Head<br>${headInputCh} â†’ ${numClasses} ch</div>`;
                html += `</div>`;
            } else if (modelType === 'multi_class_topdown') {
                // Multi-class top-down has confmaps head + class vectors (FC layers)
                html += `<div style="display: flex; gap: 8px; flex-wrap: wrap;">`;
                html += `<div class="layer-box head" style="flex: 1; min-width: 120px;">Confmaps Head<br>${headInputCh} â†’ ${numKeypoints} ch</div>`;
                html += `<div class="layer-box head" style="flex: 1; min-width: 120px; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);">Class Vector Head<br>FC â†’ ${numClasses} classes</div>`;
                html += `</div>`;
            } else {
                // single_instance, centered_instance - single head
                html += `<div class="layer-box head">Head: ${headInputCh} â†’ ${numKeypoints} (confmaps) @ stride ${outputStride}</div>`;
            }

            html += '</div>';
            return html;
        }

        function drawFramePreview() {
            const canvas = document.getElementById('frame-canvas');
            const ctx = canvas.getContext('2d');

            if (firstFrame) {
                canvas.width = firstFrame.width;
                canvas.height = firstFrame.height;

                // If we have a bitmap (from pkg.slp), draw it directly
                if (firstFrame.bitmap) {
                    ctx.drawImage(firstFrame.bitmap, 0, 0);
                } else if (firstFrame.data) {
                    // Draw from raw pixel data
                    const imageData = ctx.createImageData(firstFrame.width, firstFrame.height);
                    const pixels = imageData.data;

                    for (let i = 0; i < firstFrame.width * firstFrame.height; i++) {
                        if (firstFrame.channels === 1) {
                            // Grayscale from embedded video
                            const val = firstFrame.data[i];
                            pixels[i * 4] = val;
                            pixels[i * 4 + 1] = val;
                            pixels[i * 4 + 2] = val;
                            pixels[i * 4 + 3] = 255;
                        } else if (firstFrame.channels === 4) {
                            // RGBA from video canvas capture
                            pixels[i * 4] = firstFrame.data[i * 4];
                            pixels[i * 4 + 1] = firstFrame.data[i * 4 + 1];
                            pixels[i * 4 + 2] = firstFrame.data[i * 4 + 2];
                            pixels[i * 4 + 3] = 255;
                        } else {
                            // RGB
                            pixels[i * 4] = firstFrame.data[i * firstFrame.channels];
                            pixels[i * 4 + 1] = firstFrame.data[i * firstFrame.channels + 1];
                            pixels[i * 4 + 2] = firstFrame.data[i * firstFrame.channels + 2];
                            pixels[i * 4 + 3] = 255;
                        }
                    }
                    ctx.putImageData(imageData, 0, 0);
                }

                // Draw skeleton overlay if we have instance data
                drawSkeletonOverlay(ctx);
            } else {
                // Draw placeholder
                canvas.width = slpData.imgWidth;
                canvas.height = slpData.imgHeight;
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '20px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText('Video not embedded in SLP', canvas.width / 2, canvas.height / 2);
                ctx.font = '14px system-ui';
                ctx.fillText('Upload video file above to preview', canvas.width / 2, canvas.height / 2 + 25);
            }

            document.getElementById('frame-info').textContent = `Frame 1 / ${slpData.numFrames}`;
        }

        // Draw skeleton overlay on frame preview
        function drawSkeletonOverlay(ctx) {
            if (!instancesData || !slpData) return;

            const points = instancesData.points;
            if (!points || points.length === 0) return;

            // Create point lookup by node name
            const pointMap = {};
            for (const p of points) {
                pointMap[p.node] = p;
            }

            // Draw edges first (behind nodes)
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            for (const [srcIdx, dstIdx] of slpData.skeleton.edges) {
                const srcName = slpData.skeleton.nodes[srcIdx];
                const dstName = slpData.skeleton.nodes[dstIdx];
                const srcPt = pointMap[srcName];
                const dstPt = pointMap[dstName];

                if (srcPt && dstPt) {
                    ctx.beginPath();
                    ctx.moveTo(srcPt.x, srcPt.y);
                    ctx.lineTo(dstPt.x, dstPt.y);
                    ctx.stroke();
                }
            }

            // Draw keypoint nodes
            ctx.fillStyle = '#10b981';
            for (const p of points) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw keypoint labels
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px system-ui';
            ctx.textAlign = 'left';
            for (const p of points) {
                ctx.fillText(p.node, p.x + 6, p.y + 3);
            }
        }

        // Draw crop visualization for centered instance models
        function drawCropVisualization(ctx) {
            if (!instancesData || !slpData) return;
            if (!isTopDown) return; // Only show for top-down models

            const bbox = instancesData.bbox;
            if (!bbox) return;

            // Get crop size from input or use default
            const cropSizeInput = document.getElementById('crop-size');
            const cropSize = parseInt(cropSizeInput.value) || Math.round(slpData.maxAnimalSize * 1.5);

            // Calculate crop center (center of bbox)
            const centerX = (bbox.minX + bbox.maxX) / 2;
            const centerY = (bbox.minY + bbox.maxY) / 2;

            // Draw crop region
            const halfCrop = cropSize / 2;
            const cropX = centerX - halfCrop;
            const cropY = centerY - halfCrop;

            // Draw semi-transparent overlay outside crop region
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            // Top
            ctx.fillRect(0, 0, ctx.canvas.width, Math.max(0, cropY));
            // Bottom
            ctx.fillRect(0, cropY + cropSize, ctx.canvas.width, ctx.canvas.height - cropY - cropSize);
            // Left
            ctx.fillRect(0, cropY, Math.max(0, cropX), cropSize);
            // Right
            ctx.fillRect(cropX + cropSize, cropY, ctx.canvas.width - cropX - cropSize, cropSize);

            // Draw crop border
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(cropX, cropY, cropSize, cropSize);
            ctx.setLineDash([]);

            // Label
            ctx.fillStyle = '#f59e0b';
            ctx.font = '12px system-ui';
            ctx.textAlign = 'left';
            ctx.fillText(`Crop: ${cropSize}Ã—${cropSize}px`, cropX, cropY - 5);
        }

        function populateModelTypes() {
            const container = document.getElementById('model-type-grid');
            const isSingleAnimal = slpData.maxInstancesPerFrame === 1;
            const hasTracks = slpData.numTracks > 0;

            // Calculate animal size relative to frame
            const frameSize = Math.max(slpData.imgWidth, slpData.imgHeight);
            const animalRatio = slpData.avgAnimalSize / frameSize;
            const isSmallAnimal = animalRatio < 0.20;  // Animals are < 20% of frame size
            const hasHighOverlap = slpData.overlapFrequency > 0.10;  // >10% of frames have IoU > 0.2

            // Recommend model type based on data characteristics
            let recommendedId;
            let recommendationReason = '';

            if (isSingleAnimal) {
                recommendedId = 'single_instance';
                recommendationReason = `${slpData.maxInstancesPerFrame} animal per frame`;
            } else if (isSmallAnimal) {
                // Recommend top-down for small animals relative to frame (non-ID by default)
                recommendedId = 'topdown';
                recommendationReason = `animals are small relative to frame (~${Math.round(animalRatio * 100)}% of frame size)`;
            } else if (hasHighOverlap) {
                // Recommend bottom-up for larger animals with significant overlap
                recommendedId = 'bottomup';
                recommendationReason = `larger animals (~${Math.round(animalRatio * 100)}% of frame) with frequent overlap (${Math.round(slpData.overlapFrequency * 100)}% of frames)`;
            } else {
                // Larger animals with low overlap - top-down works well
                recommendedId = 'topdown';
                recommendationReason = `larger animals (~${Math.round(animalRatio * 100)}% of frame) with minimal overlap`;
            }

            // Build recommendation hint based on decision factors
            let recommendationHint = '';
            if (isSmallAnimal && !isSingleAnimal) {
                recommendationHint = '<br><span style="font-size: 0.85rem; color: #667eea;">Top-down works well when animals are small in the frame - cropping improves resolution.</span>';
            } else if (hasHighOverlap && !isSingleAnimal) {
                recommendationHint = '<br><span style="font-size: 0.85rem; color: #667eea;">Bottom-up handles overlapping animals better using Part Affinity Fields.</span>';
            } else if (!isSmallAnimal && !hasHighOverlap && !isSingleAnimal) {
                recommendationHint = '<br><span style="font-size: 0.85rem; color: #667eea;">With minimal overlap, top-down can efficiently crop each animal.</span>';
            }

            document.getElementById('model-recommendation').innerHTML = `
                <strong>Recommendation:</strong> Based on your data (${recommendationReason}),
                we recommend <strong>${MODEL_TYPES.find(m => m.id === recommendedId).name}</strong>.
                ${recommendationHint}
                ${hasTracks ? '<br><span style="font-size: 0.85rem; color: #888;">Your SLP has track annotations. Identity models (Multi-Class) are also available if you need to track individuals.</span>' : '<br><span style="font-size: 0.85rem; color: #888;">Identity models (Multi-Class) require track annotations in your SLP file.</span>'}
            `;

            let html = '';
            for (const model of MODEL_TYPES) {
                const isDisabled = (model.singleAnimal && !isSingleAnimal) ||
                                   (!model.singleAnimal && isSingleAnimal) ||
                                   (model.requiresTracks && !hasTracks);
                const isRecommended = model.id === recommendedId;

                html += `
                    <div class="model-type-card ${isRecommended ? 'recommended' : ''} ${isDisabled ? 'disabled' : ''}"
                         data-model="${model.id}"
                         onclick="${isDisabled ? '' : `selectModelType('${model.id}')`}">
                        <div class="model-type-name">
                            ${model.name}
                            ${isRecommended ? '<span class="badge success" style="margin-left: 8px;">Recommended</span>' : ''}
                            ${model.twoStage ? '<span class="badge warning" style="margin-left: 8px;">2-Stage</span>' : ''}
                        </div>
                        <div class="model-type-desc">${model.description}</div>
                        <div class="model-type-details">${model.details}</div>
                        ${isDisabled && model.requiresTracks ? '<div style="color: #ef4444; font-size: 0.8rem; margin-top: 5px;">Requires track annotations</div>' : ''}
                    </div>
                `;
            }
            container.innerHTML = html;

            // Return recommended model ID for auto-selection after setDefaultParameters
            return recommendedId;
        }

        function selectModelType(modelId) {
            selectedModelType = modelId;
            isTopDown = modelId === 'topdown' || modelId === 'multi_class_topdown';
            const isBottomUp = modelId === 'bottomup' || modelId === 'multi_class_bottomup';

            document.querySelectorAll('.model-type-card').forEach(card => {
                card.classList.toggle('selected', card.dataset.model === modelId);
            });

            document.getElementById('topdown-info').classList.toggle('hidden', !isTopDown);
            document.getElementById('next-btn').disabled = false;

            // Check for edges if bottomup is selected
            let warningEl = document.getElementById('bottomup-warning');
            if (!warningEl) {
                warningEl = document.createElement('div');
                warningEl.id = 'bottomup-warning';
                warningEl.className = 'info-box warning';
                warningEl.style.marginTop = '15px';
                document.getElementById('topdown-info').parentNode.insertBefore(warningEl, document.getElementById('topdown-info').nextSibling);
            }

            if (isBottomUp && slpData && (!slpData.skeleton.edges || slpData.skeleton.edges.length === 0)) {
                warningEl.innerHTML = '<strong>Warning:</strong> Bottom-Up models require skeleton edges to group keypoints using Part Affinity Fields (PAFs). Your skeleton has no edges defined. Consider using Single Instance or Top-Down instead, or add edges to your skeleton in SLEAP.';
                warningEl.classList.remove('hidden');
            } else {
                warningEl.classList.add('hidden');
            }

            // Show PAF section for bottom-up models
            const pafSigmaSection = document.getElementById('paf-sigma-section');
            if (pafSigmaSection) {
                pafSigmaSection.classList.toggle('hidden', !isBottomUp);
            }

            // Show multi-class section for identity models
            const isMultiClass = modelId === 'multi_class_bottomup' || modelId === 'multi_class_topdown';
            const multiClassSection = document.getElementById('multi-class-section');
            if (multiClassSection) {
                multiClassSection.classList.toggle('hidden', !isMultiClass);
            }

            // Show class vectors config for multi_class_topdown (uses FC layers)
            const classVectorsConfig = document.getElementById('class-vectors-config');
            if (classVectorsConfig) {
                classVectorsConfig.classList.toggle('hidden', modelId !== 'multi_class_topdown');
            }

            // Set scale to 0.5 for centroid model only - don't need high resolution for single keypoint
            // All other models (including centered_instance) should use 1.0
            if (isTopDown) {
                document.getElementById('scale').value = 0.5;
                document.getElementById('scale-value').textContent = '0.500';
            } else {
                document.getElementById('scale').value = 1.0;
                document.getElementById('scale-value').textContent = '1.000';
            }

            // Update tab visibility for top-down vs other models
            const ciTab = document.querySelector('.tab[data-tab="centered-instance"]');
            const mainTab = document.querySelector('.tab[data-tab="centroid"]');
            if (ciTab) ciTab.classList.toggle('hidden', !isTopDown);
            if (mainTab) mainTab.textContent = isTopDown ? 'Centroid Model' : 'Parameters';

            // Update anchor selector visibility
            const anchorSelector = document.getElementById('anchor-selector');
            if (anchorSelector) {
                const showAnchor = isTopDown;
                anchorSelector.classList.toggle('hidden', !showAnchor);
            }

            // If on step 3, also switch to main tab to avoid showing CI content for non-topdown
            if (!isTopDown && currentStep === 3) {
                // Switch to main tab
                document.querySelectorAll('#model-tabs .tab').forEach(t => t.classList.remove('active'));
                document.querySelector('.tab[data-tab="centroid"]').classList.add('active');
                document.querySelectorAll('.tab-content').forEach(c => {
                    if (c.id.startsWith('tab-')) c.classList.remove('active');
                });
                document.getElementById('tab-main').classList.add('active');
            }
        }

        function setDefaultParameters() {
            // Set input channels based on detected color mode
            document.getElementById('input-channels').value = slpData.numChannels === 3 ? '3' : '1';
            // Sync CI input channels
            document.getElementById('ci-input-channels').value = slpData.numChannels === 3 ? '3' : '1';

            // Scale defaults to 1.0 for all models (centroid will override to 0.5 in selectModelType)
            let scale = 1.0;
            document.getElementById('scale').value = scale;
            document.getElementById('scale-value').textContent = scale.toFixed(3);

            // Max stride
            const effectiveSize = slpData.avgAnimalSize * scale;
            let maxStride = 16;
            if (effectiveSize < 40) maxStride = 8;
            else if (effectiveSize > 100) maxStride = 32;
            document.getElementById('max-stride').value = maxStride;

            // Epochs - always default to 200
            let epochs = 200;
            document.getElementById('max-epochs').value = epochs;
            document.getElementById('ci-max-epochs').value = epochs;

            // Enable augmentation by default for all model types (recommended for most training scenarios)
            const useAug = true;
            document.getElementById('use-augmentation').checked = useAug;
            document.getElementById('aug-preview-section').classList.toggle('hidden', !useAug);
            updateAugPreview();

            // Enable CI augmentation by default as well
            document.getElementById('ci-use-augmentation').checked = useAug;
            document.getElementById('ci-aug-preview-section').classList.toggle('hidden', !useAug);
            updateCIAugPreview();

            // Crop size for centered instance - use CI max stride (not main model max stride)
            const ciMaxStride = parseInt(document.getElementById('ci-max-stride').value) || 16;
            const suggestedCrop = computeSuggestedCropSize(slpData.maxMaxDim, ciMaxStride, useAug);
            document.getElementById('crop-size').placeholder = `Auto (~${suggestedCrop}px)`;

            // Update displays
            updateEffectiveSize();
            updateModelInfo();
            updateRFVisualization();

            // Compute keypoint distances and update sigma visualizations
            computeKeypointDistances();
            updateSigmaVisualization();
            updateCISigmaVisualization();
            updateCIModelArchitecture();

            // Initialize cache memory display (hidden by default until caching is enabled)
            updateCacheMemoryEstimate();
            updateCICacheMemoryEstimate();
        }

        // Slider handling
        function initSliders() {
            document.getElementById('scale').addEventListener('input', (e) => {
                document.getElementById('scale-value').textContent = parseFloat(e.target.value).toFixed(3);
                updateEffectiveSize();
                updateRFVisualization();
            });

            document.getElementById('val-fraction').addEventListener('input', (e) => {
                document.getElementById('val-fraction-value').textContent = Math.round(e.target.value * 100) + '%';
            });

            document.getElementById('max-stride').addEventListener('change', () => {
                updateRFVisualization();
                updateModelInfo();
            });

            document.getElementById('filters').addEventListener('change', updateModelInfo);
            document.getElementById('output-stride').addEventListener('change', () => {
                updateEffectiveSize();
                updateModelInfo(); // Decoder blocks depend on output_stride
            });

            document.getElementById('backbone').addEventListener('change', (e) => {
                const backbone = e.target.value;
                const maxStrideSelect = document.getElementById('max-stride');
                const inputChannelsSelect = document.getElementById('input-channels');
                const pretrainedSection = document.getElementById('pretrained-weights-section');

                if (backbone.startsWith('convnext') || backbone.startsWith('swint')) {
                    maxStrideSelect.value = '32';
                    maxStrideSelect.disabled = true;
                    // Pretrained models require RGB
                    inputChannelsSelect.value = '3';
                    // Show pretrained weights option
                    pretrainedSection.classList.remove('hidden');
                } else {
                    maxStrideSelect.disabled = false;
                    pretrainedSection.classList.add('hidden');
                }
                updateRFVisualization();
                updateModelInfo();
            });

            document.getElementById('input-channels').addEventListener('change', (e) => {
                // Sync CI input channels with main tab
                document.getElementById('ci-input-channels').value = e.target.value;
                updateModelInfo();
                updateEffectiveSize();
                updateCIModelArchitecture();
            });

            // CI input channels listener
            document.getElementById('ci-input-channels').addEventListener('change', () => {
                updateCIModelArchitecture();
                updateCICropPreview();
            });

            // Batch size affects GPU memory
            document.getElementById('batch-size').addEventListener('change', () => {
                updateGPUMemory();
            });

            // Crop size affects centered instance visualization
            document.getElementById('crop-size').addEventListener('input', () => {
                drawFramePreview();
                updateGPUMemory();
            });

            // Scale affects GPU memory
            document.getElementById('scale').addEventListener('change', () => {
                updateGPUMemory();
            });

            // Max height/width affect model input size and GPU memory
            document.getElementById('max-height').addEventListener('input', () => {
                updateEffectiveSize();
                updateGPUMemory();
            });
            document.getElementById('max-width').addEventListener('input', () => {
                updateEffectiveSize();
                updateGPUMemory();
            });

            // Centered Instance controls
            document.getElementById('ci-scale').addEventListener('input', (e) => {
                document.getElementById('ci-scale-value').textContent = parseFloat(e.target.value).toFixed(3);
                updateCICropPreview();
                updateCIMemoryDisplay();
            });
            document.getElementById('crop-size').addEventListener('input', () => {
                updateCICropPreview();
                drawFramePreview();
                updateGPUMemory();
                updateCIMemoryDisplay();
            });
            document.getElementById('ci-max-stride').addEventListener('change', () => {
                updateCICropPreview();
                updateCIMemoryDisplay();
                updateCIModelArchitecture();
            });
            document.getElementById('ci-output-stride').addEventListener('change', () => {
                updateCICropPreview();
                updateCIMemoryDisplay();
                updateCISigmaVisualization();
                updateCIModelArchitecture();
            });
            document.getElementById('ci-batch-size').addEventListener('change', updateCIMemoryDisplay);
            document.getElementById('ci-filters').addEventListener('input', () => {
                updateCIMemoryDisplay();
                updateCIModelArchitecture();
            });
            // Crop padding updates the suggested crop size
            document.getElementById('ci-crop-padding').addEventListener('input', () => {
                updateCICropPreview();
            });
            // Min crop size doesn't affect suggestion but is used in YAML generation
            document.getElementById('ci-min-crop-size').addEventListener('input', () => {
                // No visual update needed, value is used during YAML generation
            });
        }

        function updateEffectiveSize() {
            if (!slpData) return;
            const scale = parseFloat(document.getElementById('scale').value);
            const outputStride = parseInt(document.getElementById('output-stride').value);

            // Get max_height/max_width from inputs (if specified)
            const maxHeightInput = document.getElementById('max-height')?.value;
            const maxWidthInput = document.getElementById('max-width')?.value;
            const userMaxH = maxHeightInput ? parseInt(maxHeightInput) : null;
            const userMaxW = maxWidthInput ? parseInt(maxWidthInput) : null;

            // Base dimensions: use max_height/max_width if specified, otherwise original
            const baseH = userMaxH || slpData.imgHeight;
            const baseW = userMaxW || slpData.imgWidth;

            const effWidth = Math.round(baseW * scale);
            const effHeight = Math.round(baseH * scale);
            const outWidth = Math.round(effWidth / outputStride);
            const outHeight = Math.round(effHeight / outputStride);

            // Update original size display to show if max_h/max_w are being used
            if (userMaxH || userMaxW) {
                document.getElementById('original-size').textContent = `${baseW}x${baseH}`;
                document.getElementById('original-size-detail').textContent = `(max_height=${userMaxH || 'auto'}, max_width=${userMaxW || 'auto'})`;
            } else {
                document.getElementById('original-size').textContent = `${slpData.imgWidth}x${slpData.imgHeight}`;
                document.getElementById('original-size-detail').textContent = '(original image)';
            }

            // Get channel info
            const inChannels = parseInt(document.getElementById('input-channels')?.value) || slpData.numChannels;
            const numKeypoints = slpData.skeleton.nodes.length;

            // Output channels depends on model type
            let outChannels = numKeypoints;
            if (isTopDown) {
                // Centroid model outputs 1 channel (anchor point)
                outChannels = 1;
            } else if (selectedModelType === 'bottomup') {
                // Bottom-up: keypoints + PAF edges (2 channels per edge for x,y vectors)
                const numEdges = slpData.skeleton.edges?.length || 0;
                outChannels = numKeypoints + (numEdges * 2);
            } else if (selectedModelType === 'multi_class_bottomup') {
                // Multi-class bottom-up: keypoints + class maps
                const numClasses = slpData.numTracks || 2;
                outChannels = numKeypoints + numClasses;
            }

            document.getElementById('effective-size').textContent = `${effWidth}Ã—${effHeight}Ã—${inChannels}`;
            document.getElementById('effective-size-detail').textContent = `(HÃ—WÃ—C after scale)`;

            // Update output display based on model type
            // Multi-head models have SEPARATE output tensors
            let outSizeText = '';
            let outDetail = '';
            if (isTopDown) {
                outSizeText = `${outWidth}Ã—${outHeight}Ã—1`;
                outDetail = '(centroid confmap)';
            } else if (selectedModelType === 'bottomup') {
                // Two separate outputs: confmaps and PAFs
                const numEdges = slpData.skeleton.edges?.length || 0;
                const pafChannels = numEdges * 2;
                outSizeText = `${outWidth}Ã—${outHeight}`;
                outDetail = `Confmaps: Ã—${numKeypoints} | PAFs: Ã—${pafChannels}`;
            } else if (selectedModelType === 'multi_class_bottomup') {
                // Two separate outputs: confmaps and class maps
                const numClasses = slpData.numTracks || 2;
                outSizeText = `${outWidth}Ã—${outHeight}`;
                outDetail = `Confmaps: Ã—${numKeypoints} | Classes: Ã—${numClasses}`;
            } else if (selectedModelType === 'multi_class_topdown') {
                // Two outputs: confmaps (spatial) and class vectors (not spatial)
                const numClasses = slpData.numTracks || 2;
                outSizeText = `${outWidth}Ã—${outHeight}Ã—${numKeypoints}`;
                outDetail = `+ class vector (${numClasses})`;
            } else {
                // single_instance, centered_instance
                outSizeText = `${outWidth}Ã—${outHeight}Ã—${numKeypoints}`;
                outDetail = '(confmaps)';
            }
            document.getElementById('output-size').textContent = outSizeText;
            document.getElementById('output-size-detail').textContent = outDetail;
        }

        // Update cache memory estimate
        function updateCacheMemoryEstimate() {
            if (!slpData) return;

            const dataPipeline = document.getElementById('data-pipeline')?.value || 'torch_dataset';
            const numWorkers = parseInt(document.getElementById('num-workers')?.value) || 0;
            const card = document.getElementById('cache-memory-card');

            if (!card) return;

            // Show card only when caching is enabled
            if (dataPipeline === 'torch_dataset') {
                card.style.display = 'none';
                return;
            }

            card.style.display = 'block';

            // Calculate raw cache size: height * width * channels * num_frames
            const bytesPerFrame = slpData.imgHeight * slpData.imgWidth * slpData.numChannels;
            const rawCacheMB = (bytesPerFrame * slpData.numFrames) / 1e6;
            const cacheMBWithOverhead = rawCacheMB * 1.2; // 20% overhead factor from sleap-nn

            // Display raw and overhead sizes
            document.getElementById('cache-raw-size').textContent = `${rawCacheMB.toFixed(1)} MB`;
            document.getElementById('cache-total-size').textContent = `${cacheMBWithOverhead.toFixed(1)} MB`;

            // Handle worker replication for memory caching
            const workersRow = document.getElementById('cache-workers-row');
            const workersSize = document.getElementById('cache-workers-size');
            const workerNote = document.getElementById('cache-memory-note');
            const statusBadge = document.getElementById('cache-memory-status');

            let totalCacheMB = cacheMBWithOverhead;

            if (dataPipeline === 'torch_dataset_cache_img_memory' && numWorkers > 0) {
                // Each worker gets a copy of the cache in memory
                totalCacheMB = cacheMBWithOverhead * (1 + numWorkers);
                workersRow.style.display = 'block';
                workersSize.style.display = 'block';
                workersSize.textContent = `${totalCacheMB.toFixed(1)} MB (Ã—${1 + numWorkers})`;
                workerNote.style.display = 'block';
            } else {
                workersRow.style.display = 'none';
                workersSize.style.display = 'none';
                workerNote.style.display = 'none';
            }

            // Update status badge
            const totalGB = totalCacheMB / 1024;
            if (dataPipeline === 'torch_dataset_cache_img_disk') {
                statusBadge.textContent = `${totalCacheMB.toFixed(0)} MB disk`;
                statusBadge.style.background = 'rgba(74, 222, 128, 0.2)';
                statusBadge.style.color = '#4ade80';
            } else if (totalGB < 4) {
                statusBadge.textContent = `~${totalGB.toFixed(1)} GB RAM`;
                statusBadge.style.background = 'rgba(74, 222, 128, 0.2)';
                statusBadge.style.color = '#4ade80';
            } else if (totalGB < 8) {
                statusBadge.textContent = `~${totalGB.toFixed(1)} GB RAM`;
                statusBadge.style.background = 'rgba(234, 179, 8, 0.2)';
                statusBadge.style.color = '#eab308';
            } else {
                statusBadge.textContent = `~${totalGB.toFixed(1)} GB RAM`;
                statusBadge.style.background = 'rgba(239, 68, 68, 0.2)';
                statusBadge.style.color = '#ef4444';
            }
        }

        // Update CI cache memory estimate (same data but separate UI)
        function updateCICacheMemoryEstimate() {
            if (!slpData) return;

            const dataPipeline = document.getElementById('ci-data-pipeline')?.value || 'torch_dataset';
            const numWorkers = parseInt(document.getElementById('ci-num-workers')?.value) || 0;
            const card = document.getElementById('ci-cache-memory-card');

            if (!card) return;

            // Show card only when caching is enabled
            if (dataPipeline === 'torch_dataset') {
                card.style.display = 'none';
                return;
            }

            card.style.display = 'block';

            // Calculate raw cache size: height * width * channels * num_frames
            // Note: CI model caches the same full-frame images as centroid
            const bytesPerFrame = slpData.imgHeight * slpData.imgWidth * slpData.numChannels;
            const rawCacheMB = (bytesPerFrame * slpData.numFrames) / 1e6;
            const cacheMBWithOverhead = rawCacheMB * 1.2;

            document.getElementById('ci-cache-raw-size').textContent = `${rawCacheMB.toFixed(1)} MB`;
            document.getElementById('ci-cache-total-size').textContent = `${cacheMBWithOverhead.toFixed(1)} MB`;

            const workersRow = document.getElementById('ci-cache-workers-row');
            const workersSize = document.getElementById('ci-cache-workers-size');
            const workerNote = document.getElementById('ci-cache-memory-note');
            const statusBadge = document.getElementById('ci-cache-memory-status');

            let totalCacheMB = cacheMBWithOverhead;

            if (dataPipeline === 'torch_dataset_cache_img_memory' && numWorkers > 0) {
                totalCacheMB = cacheMBWithOverhead * (1 + numWorkers);
                workersRow.style.display = 'block';
                workersSize.style.display = 'block';
                workersSize.textContent = `${totalCacheMB.toFixed(1)} MB (Ã—${1 + numWorkers})`;
                workerNote.style.display = 'block';
            } else {
                workersRow.style.display = 'none';
                workersSize.style.display = 'none';
                workerNote.style.display = 'none';
            }

            const totalGB = totalCacheMB / 1024;
            if (dataPipeline === 'torch_dataset_cache_img_disk') {
                statusBadge.textContent = `${totalCacheMB.toFixed(0)} MB disk`;
                statusBadge.style.background = 'rgba(74, 222, 128, 0.2)';
                statusBadge.style.color = '#4ade80';
            } else if (totalGB < 4) {
                statusBadge.textContent = `~${totalGB.toFixed(1)} GB RAM`;
                statusBadge.style.background = 'rgba(74, 222, 128, 0.2)';
                statusBadge.style.color = '#4ade80';
            } else if (totalGB < 8) {
                statusBadge.textContent = `~${totalGB.toFixed(1)} GB RAM`;
                statusBadge.style.background = 'rgba(234, 179, 8, 0.2)';
                statusBadge.style.color = '#eab308';
            } else {
                statusBadge.textContent = `~${totalGB.toFixed(1)} GB RAM`;
                statusBadge.style.background = 'rgba(239, 68, 68, 0.2)';
                statusBadge.style.color = '#ef4444';
            }
        }

        // Update Centered Instance crop preview
        function updateCICropPreview() {
            if (!slpData) return;

            const canvas = document.getElementById('ci-crop-preview');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            // Get suggested crop size following sleap-nn logic:
            // crop_size = ceil((max_bbox_dim + padding) / max_stride) * max_stride
            const ciMaxStride = parseInt(document.getElementById('ci-max-stride').value) || 16;
            // Check if CI-specific augmentation is enabled, otherwise fall back to main augmentation
            const ciAugEnabled = document.getElementById('ci-use-augmentation')?.checked || false;
            const mainAugEnabled = document.getElementById('use-augmentation')?.checked || false;
            const useAug = ciAugEnabled || mainAugEnabled;
            const userCropPadding = document.getElementById('ci-crop-padding')?.value ? parseInt(document.getElementById('ci-crop-padding').value) : null;
            const suggestedCrop = computeSuggestedCropSize(slpData.maxMaxDim, ciMaxStride, useAug, userCropPadding);

            // Calculate effective padding for display
            let effectivePadding = 0;
            let paddingSource = '';
            if (userCropPadding !== null && userCropPadding > 0) {
                effectivePadding = userCropPadding;
                paddingSource = 'user';
            } else if (useAug) {
                // Use CI augmentation values if CI aug is enabled, otherwise use main aug values
                const { rotationMax, scaleMax } = getAugmentationParams(ciAugEnabled);
                effectivePadding = computeAugmentationPadding(slpData.maxMaxDim, rotationMax, scaleMax);
                paddingSource = 'aug';
            }

            // Update suggestion text and placeholder to match
            const suggestionEl = document.getElementById('crop-size-suggestion');
            if (suggestionEl) {
                let suggestionText = `Suggested: ${suggestedCrop}px (max instance ${slpData.maxMaxDim}px`;
                if (effectivePadding > 0) {
                    suggestionText += ` + ${effectivePadding}px ${paddingSource === 'user' ? 'padding' : 'aug padding'}`;
                }
                suggestionText += `, rounded to stride ${ciMaxStride})`;
                suggestionEl.textContent = suggestionText;
            }
            // Keep placeholder in sync with suggested value
            const cropSizeEl = document.getElementById('crop-size');
            if (cropSizeEl) {
                cropSizeEl.placeholder = `Auto (~${suggestedCrop}px)`;
            }

            // Get actual crop size
            const cropSizeInput = document.getElementById('crop-size');
            const cropSize = cropSizeInput?.value ? parseInt(cropSizeInput.value) : suggestedCrop;

            // Get scale and output stride
            const ciScale = parseFloat(document.getElementById('ci-scale')?.value) || 1.0;
            const ciOutputStride = parseInt(document.getElementById('ci-output-stride')?.value) || 1;

            // Calculate model input size:
            // If user provides crop_size + crop_padding, add them and round up to max_stride
            let baseSize = cropSize;
            if (cropSizeInput?.value && userCropPadding !== null && userCropPadding > 0) {
                // User provided both crop_size and padding - add padding to crop size
                baseSize = cropSize + userCropPadding;
            }
            // Round up to be divisible by max_stride (model requirement)
            const inputSizeBeforeScale = Math.ceil(baseSize / ciMaxStride) * ciMaxStride;
            const inputSize = Math.round(inputSizeBeforeScale * ciScale);
            const outputSize = Math.round(inputSize / ciOutputStride);

            // Get channel info (use CI-specific input channels)
            const inChannels = parseInt(document.getElementById('ci-input-channels')?.value) || slpData.numChannels;
            const numKeypoints = slpData.skeleton.nodes.length;
            // Centered instance outputs one channel per keypoint
            // Multi-class top-down also outputs class vectors but those go through FC layers, not spatial
            const outChannels = numKeypoints;
            const isMultiClass = selectedModelType === 'multi_class_topdown';
            const numClasses = slpData.numTracks || 0;

            // Update info display
            const cropDisplay = document.getElementById('ci-crop-size-display');
            const inputDisplay = document.getElementById('ci-input-size-display');
            const outputDisplay = document.getElementById('ci-output-size-display');
            if (cropDisplay) cropDisplay.textContent = `${cropSize}Ã—${cropSize}px`;

            // Show model input size with explanation if padding was applied
            let inputSizeText = `${inputSize}Ã—${inputSize}Ã—${inChannels} (HÃ—WÃ—C)`;
            if (cropSizeInput?.value && userCropPadding !== null && userCropPadding > 0) {
                // Show calculation: crop + padding â†’ rounded
                if (inputSizeBeforeScale !== (cropSize + userCropPadding)) {
                    inputSizeText = `${inputSize}Ã—${inputSize}Ã—${inChannels} (${cropSize}+${userCropPadding}â†’${inputSizeBeforeScale})`;
                } else {
                    inputSizeText = `${inputSize}Ã—${inputSize}Ã—${inChannels} (${cropSize}+${userCropPadding}px pad)`;
                }
            }
            if (inputDisplay) inputDisplay.textContent = inputSizeText;

            const outDetail = isMultiClass ? `(${numKeypoints} confmaps + ${numClasses} class logits)` : '(HÃ—WÃ—keypoints)';
            if (outputDisplay) outputDisplay.textContent = `${outputSize}Ã—${outputSize}Ã—${outChannels} ${outDetail}`;

            // Draw visualization
            if (instancesData && instancesData.points.length > 0) {
                const points = instancesData.points;
                const bbox = instancesData.bbox;
                const hasVideo = !!videoFrame;

                // Get anchor position (from centroid tab selection)
                const anchorNode = selectedAnchor;
                let anchorX, anchorY;
                if (anchorNode) {
                    const anchorPt = points.find(p => p.node === anchorNode);
                    if (anchorPt) {
                        anchorX = anchorPt.x;
                        anchorY = anchorPt.y;
                    } else {
                        anchorX = (bbox.minX + bbox.maxX) / 2;
                        anchorY = (bbox.minY + bbox.maxY) / 2;
                    }
                } else {
                    anchorX = (bbox.minX + bbox.maxX) / 2;
                    anchorY = (bbox.minY + bbox.maxY) / 2;
                }

                // Calculate crop region in source coordinates
                const cropHalf = cropSize / 2;
                const cropMinX = anchorX - cropHalf;
                const cropMinY = anchorY - cropHalf;
                const cropMaxX = anchorX + cropHalf;
                const cropMaxY = anchorY + cropHalf;

                // Calculate scale to fit crop in canvas with padding
                const padding = 10;
                const scale = (Math.min(width, height) - padding * 2) / cropSize;

                // Transform function: maps world coords to canvas coords (crop-relative)
                const transform = (x, y) => ({
                    x: (x - cropMinX) * scale + padding,
                    y: (y - cropMinY) * scale + padding
                });

                // Draw video frame crop as background if available
                if (hasVideo) {
                    try {
                        // Calculate source region (clamped to image bounds)
                        const srcX = Math.max(0, Math.floor(cropMinX));
                        const srcY = Math.max(0, Math.floor(cropMinY));
                        const srcW = Math.min(cropSize, videoFrame.width - srcX);
                        const srcH = Math.min(cropSize, videoFrame.height - srcY);

                        console.log('CI Crop Preview:', {
                            videoFrame: { w: videoFrame.width, h: videoFrame.height },
                            anchor: { x: anchorX, y: anchorY },
                            crop: { minX: cropMinX, minY: cropMinY, size: cropSize },
                            src: { x: srcX, y: srcY, w: srcW, h: srcH },
                            scale, padding
                        });

                        if (srcW > 0 && srcH > 0) {
                            // Calculate destination position (accounting for clamping offset)
                            const destX = (srcX - cropMinX) * scale + padding;
                            const destY = (srcY - cropMinY) * scale + padding;

                            ctx.drawImage(
                                videoFrame,
                                srcX, srcY, srcW, srcH,
                                destX, destY, srcW * scale, srcH * scale
                            );
                            // Slight darkening overlay for better skeleton visibility
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                            ctx.fillRect(destX, destY, srcW * scale, srcH * scale);
                        }
                    } catch (e) {
                        console.warn('Error drawing video crop:', e);
                    }
                }

                // Draw crop box
                const cropTL = transform(cropMinX, cropMinY);
                const cropBR = transform(cropMaxX, cropMaxY);
                ctx.strokeStyle = '#f97316';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.strokeRect(cropTL.x, cropTL.y, cropBR.x - cropTL.x, cropBR.y - cropTL.y);
                ctx.setLineDash([]);

                // Draw skeleton edges
                ctx.strokeStyle = hasVideo ? 'rgba(255, 200, 50, 0.9)' : 'rgba(100, 180, 255, 0.6)';
                ctx.lineWidth = 2;
                for (const edge of slpData.skeleton.edges) {
                    const srcName = slpData.skeleton.nodes[edge[0]];
                    const dstName = slpData.skeleton.nodes[edge[1]];
                    const srcPt = points.find(p => p.node === srcName);
                    const dstPt = points.find(p => p.node === dstName);
                    if (srcPt && dstPt) {
                        const p1 = transform(srcPt.x, srcPt.y);
                        const p2 = transform(dstPt.x, dstPt.y);
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }

                // Draw keypoints
                for (const pt of points) {
                    const tpt = transform(pt.x, pt.y);
                    const isAnchor = pt.node === anchorNode;
                    ctx.beginPath();
                    ctx.arc(tpt.x, tpt.y, isAnchor ? 6 : 4, 0, Math.PI * 2);
                    ctx.fillStyle = isAnchor ? '#ff3366' : (hasVideo ? 'rgba(255, 200, 50, 0.9)' : 'rgba(100, 180, 255, 0.8)');
                    ctx.fill();
                    if (isAnchor) {
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                    }
                }

                // Label
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '10px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`Anchor: ${anchorNode || 'bbox center'}`, width / 2, height - 5);
            } else {
                ctx.fillStyle = '#666';
                ctx.font = '12px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText('Load SLP with labeled frames', width / 2, height / 2);
            }
        }

        function updateModelInfo() {
            const filters = parseInt(document.getElementById('filters').value);
            const maxStride = parseInt(document.getElementById('max-stride').value);
            const outputStride = parseInt(document.getElementById('output-stride').value) || 1;
            const inChannels = slpData ? parseInt(document.getElementById('input-channels').value) : 1;
            const numKeypoints = slpData ? slpData.skeleton.nodes.length : 13;

            // Calculate blocks per sleap-nn architecture:
            // down_blocks = log2(max_stride)
            // up_blocks = log2(max_stride / output_stride)
            const downBlocks = Math.log2(maxStride);
            const upBlocks = Math.log2(maxStride / outputStride);

            const params = estimateParamsAccurate(filters, maxStride, outputStride, inChannels, numKeypoints);

            document.getElementById('total-params').textContent = '~' + formatParams(params);
            document.getElementById('down-blocks').textContent = downBlocks;
            document.getElementById('up-blocks').textContent = upBlocks;

            // Generate PR28-style visual architecture diagram
            // Determine current model type and get edge/class counts
            let currentModelType = selectedModelType || 'single_instance';
            if (isTopDown) currentModelType = 'centroid';  // Main tab for top-down shows centroid model
            const numEdges = slpData?.skeleton?.edges?.length || 0;
            const numClasses = slpData?.numTracks || 0;
            document.getElementById('arch-diagram').innerHTML = generateUNetDiagram(filters, maxStride, outputStride, inChannels, numKeypoints, 1.5, currentModelType, numEdges, numClasses);

            // Update GPU memory estimation
            updateGPUMemory();
        }

        // GPU Memory Estimation
        // Compute padding to make dimensions divisible by max_stride
        // This is required because UNet encoder/decoder need dimensions divisible by 2^num_blocks
        function computePadToStride(height, width, maxStride) {
            const padHeight = (maxStride - (height % maxStride)) % maxStride;
            const padWidth = (maxStride - (width % maxStride)) % maxStride;
            return {
                padHeight,
                padWidth,
                paddedHeight: height + padHeight,
                paddedWidth: width + padWidth
            };
        }

        function estimateGPUMemory() {
            if (!slpData) return null;

            const batchSize = parseInt(document.getElementById('batch-size').value) || 4;
            const scale = parseFloat(document.getElementById('scale').value) || 1.0;
            const filters = parseInt(document.getElementById('filters').value) || 32;
            const maxStride = parseInt(document.getElementById('max-stride').value) || 16;
            const outputStride = parseInt(document.getElementById('output-stride').value) || 1;
            const numKeypoints = slpData.skeleton.nodes.length;

            // Get max_height/max_width from inputs (if specified)
            const maxHeightInput = document.getElementById('max-height')?.value;
            const maxWidthInput = document.getElementById('max-width')?.value;
            const userMaxH = maxHeightInput ? parseInt(maxHeightInput) : null;
            const userMaxW = maxWidthInput ? parseInt(maxWidthInput) : null;

            // Get image dimensions based on pipeline/model type
            // sleap-nn pipeline: apply_sizematcher(max_h, max_w) â†’ apply_resizer(scale) â†’ pad_to_stride
            let scaledH, scaledW;
            let baseH, baseW;
            if (isTopDown && document.querySelector('.tab[data-tab="centered-instance"]')?.classList.contains('active')) {
                // Centered Instance: uses crop_size (max_height/max_width don't apply to crops)
                const cropSize = parseInt(document.getElementById('crop-size').value) || Math.round(slpData.maxAnimalSize * 1.5);
                baseH = baseW = cropSize;
                scaledH = scaledW = Math.round(cropSize * scale);
            } else {
                // Other pipelines: sizematcher resizes to fit within max_h Ã— max_w, then pads
                // If max_height/max_width specified, image is resized to fit and padded to those dims
                if (userMaxH && userMaxW) {
                    baseH = userMaxH;
                    baseW = userMaxW;
                } else {
                    baseH = slpData.imgHeight;
                    baseW = slpData.imgWidth;
                }
                scaledH = Math.round(baseH * scale);
                scaledW = Math.round(baseW * scale);
            }

            // Apply pad_to_stride - images must be divisible by max_stride for UNet
            const padding = computePadToStride(scaledH, scaledW, maxStride);
            const imgH = padding.paddedHeight;
            const imgW = padding.paddedWidth;

            // Use consistent parameter estimation
            const inChannels = parseInt(document.getElementById('input-channels').value) || 1;
            const totalParams = estimateParamsAccurate(filters, maxStride, outputStride, inChannels, numKeypoints);
            const downBlocks = Math.log2(maxStride);
            const upBlocks = Math.log2(maxStride / outputStride);

            // Memory estimates (in bytes, fp32 = 4 bytes)
            const weightsBytes = totalParams * 4;
            const batchImgBytes = batchSize * imgH * imgW * 4; // Single channel float
            const confMapH = Math.ceil(imgH / outputStride);
            const confMapW = Math.ceil(imgW / outputStride);
            const batchConfBytes = batchSize * confMapH * confMapW * numKeypoints * 4;

            // Activations (rough: proportional to feature map sizes across layers)
            let actBytes = 0;
            let h = imgH, w = imgW;
            f = filters;
            for (let i = 0; i <= downBlocks; i++) {
                actBytes += batchSize * h * w * f * 4;
                h = Math.ceil(h / 2);
                w = Math.ceil(w / 2);
                f = Math.floor(f * 1.5);
            }
            actBytes *= 2; // Encoder + decoder

            // Gradients are roughly same as activations for backprop
            const gradientBytes = actBytes;

            const totalBytes = weightsBytes + batchImgBytes + batchConfBytes + actBytes + gradientBytes;
            const totalGB = totalBytes / (1024 ** 3);

            return {
                totalGB,
                totalBytes,
                paramsM: totalParams / 1e6,
                weightsBytes,
                batchImgBytes,
                batchConfBytes,
                actBytes,
                gradientBytes,
                // Input size info
                scaledH,
                scaledW,
                paddedH: imgH,
                paddedW: imgW,
                padH: padding.padHeight,
                padW: padding.padWidth
            };
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 ** 2) return (bytes / 1024).toFixed(1) + ' KB';
            if (bytes < 1024 ** 3) return (bytes / (1024 ** 2)).toFixed(1) + ' MB';
            return (bytes / (1024 ** 3)).toFixed(2) + ' GB';
        }

        // GPU memory estimation for Centered Instance model
        function estimateCIGPUMemory() {
            if (!slpData) return null;

            const batchSize = parseInt(document.getElementById('ci-batch-size').value) || 4;
            const scale = parseFloat(document.getElementById('ci-scale').value) || 1.0;
            const filters = parseInt(document.getElementById('ci-filters').value) || 32;
            const maxStride = parseInt(document.getElementById('ci-max-stride').value) || 16;
            const outputStride = parseInt(document.getElementById('ci-output-stride').value) || 1;
            const numKeypoints = slpData.skeleton.nodes.length;
            const inChannels = parseInt(document.getElementById('input-channels').value) || 1;

            // Centered Instance uses crop_size
            const cropSize = parseInt(document.getElementById('crop-size').value) || Math.round(slpData.maxAnimalSize * 1.5);
            const scaledSize = Math.round(cropSize * scale);

            // Apply pad_to_stride
            const padding = computePadToStride(scaledSize, scaledSize, maxStride);
            const imgH = padding.paddedHeight;
            const imgW = padding.paddedWidth;

            const totalParams = estimateParamsAccurate(filters, maxStride, outputStride, inChannels, numKeypoints);
            const downBlocks = Math.log2(maxStride);

            // Memory estimates (in bytes, fp32 = 4 bytes)
            const weightsBytes = totalParams * 4;
            const batchImgBytes = batchSize * imgH * imgW * 4;
            const confMapH = Math.ceil(imgH / outputStride);
            const confMapW = Math.ceil(imgW / outputStride);
            const batchConfBytes = batchSize * confMapH * confMapW * numKeypoints * 4;

            // Activations
            let actBytes = 0;
            let h = imgH, w = imgW, f = filters;
            for (let i = 0; i <= downBlocks; i++) {
                actBytes += batchSize * h * w * f * 4;
                h = Math.ceil(h / 2);
                w = Math.ceil(w / 2);
                f = Math.floor(f * 1.5);
            }
            actBytes *= 2;

            const gradientBytes = actBytes;
            const totalBytes = weightsBytes + batchImgBytes + batchConfBytes + actBytes + gradientBytes;
            const totalGB = totalBytes / (1024 ** 3);

            return {
                totalGB,
                totalBytes,
                paramsM: totalParams / 1e6,
                weightsBytes,
                batchImgBytes,
                batchConfBytes,
                actBytes,
                gradientBytes
            };
        }

        // Update CI GPU memory display
        function updateCIMemoryDisplay() {
            const mem = estimateCIGPUMemory();
            if (!mem) return;

            document.getElementById('ci-memory-total').textContent = `~${mem.totalGB.toFixed(1)} GB`;
            document.getElementById('ci-mem-params').textContent = `~${mem.paramsM.toFixed(1)}M`;
            document.getElementById('ci-mem-weights').textContent = formatBytes(mem.weightsBytes);
            document.getElementById('ci-mem-batch-img').textContent = formatBytes(mem.batchImgBytes);
            document.getElementById('ci-mem-activations').textContent = formatBytes(mem.actBytes);
            document.getElementById('ci-mem-confmaps').textContent = formatBytes(mem.batchConfBytes);
            document.getElementById('ci-mem-gradients').textContent = formatBytes(mem.gradientBytes);

            const statusEl = document.getElementById('ci-memory-status');
            if (mem.totalGB < 4) {
                statusEl.className = 'memory-status ok';
                statusEl.textContent = 'Should fit on most GPUs (8GB+)';
            } else if (mem.totalGB < 8) {
                statusEl.className = 'memory-status warning';
                statusEl.textContent = 'May require 12GB+ GPU';
            } else {
                statusEl.className = 'memory-status danger';
                statusEl.textContent = 'Consider reducing batch size or crop size';
            }
        }

        function updateGPUMemory() {
            const mem = estimateGPUMemory();
            if (!mem) return;

            // Update model type display
            const modelNames = {
                'single_instance': 'Single Instance',
                'topdown': 'Top-Down (Centroid)',
                'centered_instance': 'Centered Instance',
                'bottomup': 'Bottom-Up',
                'multi_class_bottomup': 'Multi-Class Bottom-Up',
                'multi_class_topdown': 'Multi-Class Top-Down'
            };
            const currentType = isTopDown ? 'topdown' : (selectedModelType || 'single_instance');
            document.getElementById('mem-model-type').textContent = modelNames[currentType] || currentType;

            // Update output label based on model type
            const outputLabelEl = document.getElementById('mem-output-label');
            if (currentType === 'bottomup') {
                outputLabelEl.textContent = 'Conf+PAF Maps';
            } else if (currentType === 'multi_class_bottomup') {
                outputLabelEl.textContent = 'Conf+Class Maps';
            } else if (currentType === 'multi_class_topdown') {
                outputLabelEl.textContent = 'Conf+Class';
            } else {
                outputLabelEl.textContent = 'Conf Maps';
            }

            // Update display
            const totalEl = document.getElementById('memory-total');
            totalEl.textContent = `~${mem.totalGB.toFixed(1)} GB`;
            totalEl.classList.remove('warning', 'danger');
            if (mem.totalGB > 16) totalEl.classList.add('danger');
            else if (mem.totalGB > 8) totalEl.classList.add('warning');

            document.getElementById('mem-params').textContent = `~${mem.paramsM.toFixed(1)}M`;
            document.getElementById('mem-weights').textContent = formatBytes(mem.weightsBytes);
            document.getElementById('mem-batch-img').textContent = formatBytes(mem.batchImgBytes);
            document.getElementById('mem-activations').textContent = formatBytes(mem.actBytes);
            document.getElementById('mem-confmaps').textContent = formatBytes(mem.batchConfBytes);
            document.getElementById('mem-gradients').textContent = formatBytes(mem.gradientBytes);

            // Update model input size display
            document.getElementById('input-size-scaled').textContent = `${mem.scaledW}Ã—${mem.scaledH}`;
            const paddedEl = document.getElementById('input-size-padded');
            if (mem.padH > 0 || mem.padW > 0) {
                paddedEl.textContent = `${mem.paddedW}Ã—${mem.paddedH}`;
                paddedEl.style.color = '#f59e0b'; // Highlight when padding is applied
            } else {
                paddedEl.textContent = `${mem.paddedW}Ã—${mem.paddedH}`;
                paddedEl.style.color = '#10b981'; // Green when no padding needed
            }

            // Update status message
            const statusEl = document.getElementById('memory-status');
            statusEl.classList.remove('ok', 'warning', 'danger');
            if (mem.totalGB < 6) {
                statusEl.classList.add('ok');
                statusEl.textContent = 'Should fit on most GPUs (6GB+)';
            } else if (mem.totalGB < 12) {
                statusEl.classList.add('ok');
                statusEl.textContent = 'Suitable for mid-range GPUs (8-12GB)';
            } else if (mem.totalGB < 20) {
                statusEl.classList.add('warning');
                statusEl.textContent = 'Requires high-end GPU (16-24GB). Consider reducing batch size or scale.';
            } else {
                statusEl.classList.add('danger');
                statusEl.textContent = 'May exceed GPU memory. Reduce batch size, scale, or image size.';
            }
        }

        // Augmentation slider values (computed from slider positions)
        function getAugValues() {
            const rotation = parseInt(document.getElementById('aug-rotation-val')?.value) || 0;
            const scaleRange = parseInt(document.getElementById('aug-scale-val')?.value) || 0;
            const translate = parseInt(document.getElementById('aug-translate-val')?.value) || 0;
            const brightness = parseInt(document.getElementById('aug-brightness-val')?.value) || 0;
            const contrast = parseInt(document.getElementById('aug-contrast-val')?.value) || 0;

            return {
                rotation,
                scaleMin: 1 - scaleRange / 100,
                scaleMax: 1 + scaleRange / 100,
                translate: translate / 100,
                brightnessMin: 1 - brightness / 100,
                brightnessMax: 1 + brightness / 100,
                contrastMin: 1 - contrast / 100,
                contrastMax: 1 + contrast / 100
            };
        }

        // Check if any augmentation is enabled (slider > 0)
        function getAugmentationState() {
            const v = getAugValues();
            return {
                rotation: v.rotation > 0,
                scale: v.scaleMin < 1 || v.scaleMax > 1,
                translate: v.translate > 0,
                brightness: v.brightnessMin < 1 || v.brightnessMax > 1,
                contrast: v.contrastMin < 1 || v.contrastMax > 1
            };
        }

        // Alias for backward compatibility
        const augmentationState = { rotation: true, scale: true, translate: false, contrast: false, brightness: false };
        function updateAugmentationStateFromSliders() {
            const state = getAugmentationState();
            augmentationState.rotation = state.rotation;
            augmentationState.scale = state.scale;
            augmentationState.translate = state.translate;
            augmentationState.contrast = state.contrast;
            augmentationState.brightness = state.brightness;
        }

        function updateAugSliderValue(type) {
            const v = getAugValues();
            if (type === 'rotation') {
                document.getElementById('rotation-value').textContent = v.rotation > 0 ? `Â±${v.rotation}Â°` : 'Off';
            } else if (type === 'scale') {
                const range = parseInt(document.getElementById('aug-scale-val')?.value) || 0;
                document.getElementById('scale-aug-value').textContent = range > 0 ? `${v.scaleMin.toFixed(2)} - ${v.scaleMax.toFixed(2)}` : 'Off';
            } else if (type === 'translate') {
                const pct = parseInt(document.getElementById('aug-translate-val')?.value) || 0;
                document.getElementById('translate-value').textContent = pct > 0 ? `Â±${pct}%` : 'Off';
            } else if (type === 'brightness') {
                const pct = parseInt(document.getElementById('aug-brightness-val')?.value) || 0;
                document.getElementById('brightness-value').textContent = pct > 0 ? `Â±${pct}%` : 'Off';
            } else if (type === 'contrast') {
                const pct = parseInt(document.getElementById('aug-contrast-val')?.value) || 0;
                document.getElementById('contrast-value').textContent = pct > 0 ? `Â±${pct}%` : 'Off';
            }
            updateAugmentationStateFromSliders();
            updateAugPreview();
            // Update crop size suggestion when rotation or scale changes (affects padding)
            if (type === 'rotation' || type === 'scale') {
                updateCICropPreview();
            }
        }

        function updateRFVisualization() {
            if (!slpData) return;

            const scale = parseFloat(document.getElementById('scale').value);
            const maxStride = parseInt(document.getElementById('max-stride').value);
            const rf = RF_TABLE[maxStride] || 63;
            const effectiveRF = Math.round(rf / scale);

            document.getElementById('rf-value').textContent = rf;
            document.getElementById('rf-effective').textContent = effectiveRF;

            const canvas = document.getElementById('rf-canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            const containerWidth = canvas.parentElement.clientWidth;
            const aspectRatio = slpData.imgWidth / slpData.imgHeight;
            canvas.width = containerWidth;
            canvas.height = Math.min(350, containerWidth / aspectRatio);

            // Draw image or placeholder
            const displayScale = Math.min(canvas.width / slpData.imgWidth, canvas.height / slpData.imgHeight);
            const imgDisplayWidth = slpData.imgWidth * displayScale;
            const imgDisplayHeight = slpData.imgHeight * displayScale;
            const offsetX = (canvas.width - imgDisplayWidth) / 2;
            const offsetY = (canvas.height - imgDisplayHeight) / 2;

            // Try to get frame canvas (handles both raw pixels and pkg.slp bitmaps)
            const tempCanvas = createFrameCanvas();

            if (tempCanvas) {
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(tempCanvas, offsetX, offsetY, imgDisplayWidth, imgDisplayHeight);
            } else {
                // Draw placeholder grid
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#333';
                ctx.fillRect(offsetX, offsetY, imgDisplayWidth, imgDisplayHeight);

                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                const gridSize = 50 * displayScale;
                for (let x = offsetX; x < offsetX + imgDisplayWidth; x += gridSize) {
                    ctx.beginPath(); ctx.moveTo(x, offsetY); ctx.lineTo(x, offsetY + imgDisplayHeight); ctx.stroke();
                }
                for (let y = offsetY; y < offsetY + imgDisplayHeight; y += gridSize) {
                    ctx.beginPath(); ctx.moveTo(offsetX, y); ctx.lineTo(offsetX + imgDisplayWidth, y); ctx.stroke();
                }
            }

            // Draw receptive field box
            const rfDisplaySize = effectiveRF * displayScale;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.strokeStyle = '#f43f5e';
            ctx.lineWidth = 3;
            ctx.strokeRect(centerX - rfDisplaySize / 2, centerY - rfDisplaySize / 2, rfDisplaySize, rfDisplaySize);

            // Draw animal size indicator
            const animalDisplaySize = slpData.avgAnimalSize * displayScale;
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(centerX - animalDisplaySize / 2, centerY - animalDisplaySize / 2, animalDisplaySize, animalDisplaySize);
            ctx.setLineDash([]);
        }

        // Augmentation toggle
        function initAugToggle() {
            document.getElementById('use-augmentation').addEventListener('change', (e) => {
                document.getElementById('aug-preview-section').classList.toggle('hidden', !e.target.checked);
                if (e.target.checked) updateAugPreview();
                // Update crop size suggestion when augmentation is toggled
                updateCICropPreview();
            });
        }

        // Current random augmentation values for preview
        let currentAugRandom = { rotation: 0, scale: 1, translateX: 0, translateY: 0, brightness: 1, contrast: 1 };

        function randomizeAugPreview() {
            const v = getAugValues();
            // Generate random values within the slider ranges
            currentAugRandom = {
                rotation: v.rotation > 0 ? (Math.random() * 2 - 1) * v.rotation : 0,
                scale: v.scaleMin < 1 || v.scaleMax > 1 ? v.scaleMin + Math.random() * (v.scaleMax - v.scaleMin) : 1,
                translateX: v.translate > 0 ? (Math.random() * 2 - 1) * v.translate : 0,
                translateY: v.translate > 0 ? (Math.random() * 2 - 1) * v.translate : 0,
                brightness: v.brightnessMin < 1 || v.brightnessMax > 1 ? v.brightnessMin + Math.random() * (v.brightnessMax - v.brightnessMin) : 1,
                contrast: v.contrastMin < 1 || v.contrastMax > 1 ? v.contrastMin + Math.random() * (v.contrastMax - v.contrastMin) : 1
            };
            updateAugPreview();
        }

        function updateAugPreview() {
            if (!slpData) return;

            // Create source canvas from frame data (handles both raw pixels and pkg.slp bitmaps)
            const sourceCanvas = createFrameCanvas();

            const CANVAS_W = 150, CANVAS_H = 150;

            // Draw original
            const origCanvas = document.getElementById('aug-original');
            if (origCanvas) {
                const ctx = origCanvas.getContext('2d');
                origCanvas.width = CANVAS_W;
                origCanvas.height = CANVAS_H;
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

                if (sourceCanvas) {
                    const scale = Math.min((CANVAS_W - 10) / sourceCanvas.width, (CANVAS_H - 10) / sourceCanvas.height);
                    const w = sourceCanvas.width * scale;
                    const h = sourceCanvas.height * scale;
                    ctx.drawImage(sourceCanvas, (CANVAS_W - w) / 2, (CANVAS_H - h) / 2, w, h);
                } else {
                    ctx.fillStyle = '#666';
                    ctx.font = '11px system-ui';
                    ctx.textAlign = 'center';
                    ctx.fillText('Load SLP', CANVAS_W / 2, CANVAS_H / 2);
                }
            }

            // Draw augmented preview with current random values
            const augCanvas = document.getElementById('aug-preview');
            if (augCanvas) {
                const ctx = augCanvas.getContext('2d');
                augCanvas.width = CANVAS_W;
                augCanvas.height = CANVAS_H;
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

                if (sourceCanvas) {
                    const scale = Math.min((CANVAS_W - 10) / sourceCanvas.width, (CANVAS_H - 10) / sourceCanvas.height);
                    const w = sourceCanvas.width * scale;
                    const h = sourceCanvas.height * scale;

                    ctx.save();
                    // Apply transforms
                    ctx.translate(CANVAS_W / 2, CANVAS_H / 2);
                    ctx.rotate(currentAugRandom.rotation * Math.PI / 180);
                    ctx.scale(currentAugRandom.scale, currentAugRandom.scale);
                    ctx.translate(currentAugRandom.translateX * w, currentAugRandom.translateY * h);
                    // Apply filters
                    ctx.filter = `brightness(${currentAugRandom.brightness}) contrast(${currentAugRandom.contrast})`;
                    ctx.drawImage(sourceCanvas, -w / 2, -h / 2, w, h);
                    ctx.restore();
                } else {
                    ctx.fillStyle = '#666';
                    ctx.font = '11px system-ui';
                    ctx.textAlign = 'center';
                    ctx.fillText('Load SLP', CANVAS_W / 2, CANVAS_H / 2);
                }
            }
        }

        // CI Augmentation toggle and functions
        function initCIAugToggle() {
            document.getElementById('ci-use-augmentation').addEventListener('change', (e) => {
                document.getElementById('ci-aug-preview-section').classList.toggle('hidden', !e.target.checked);
                if (e.target.checked) updateCIAugPreview();
                // Update crop size suggestion when CI augmentation is toggled
                updateCICropPreview();
            });
        }

        // Pretrained checkpoints toggle
        function initPretrainedCkptsToggle() {
            // Main/Centroid model
            document.getElementById('load-pretrained-ckpts')?.addEventListener('change', (e) => {
                document.getElementById('pretrained-ckpts-options').classList.toggle('hidden', !e.target.checked);
            });
            // Centered Instance model
            document.getElementById('ci-load-pretrained-ckpts')?.addEventListener('change', (e) => {
                document.getElementById('ci-pretrained-ckpts-options').classList.toggle('hidden', !e.target.checked);
            });
        }

        // Additional training params toggle
        function initAdditionalParamsToggle() {
            // Main/Centroid model
            document.getElementById('show-additional-params')?.addEventListener('change', (e) => {
                document.getElementById('additional-params-options').classList.toggle('hidden', !e.target.checked);
            });
            // Centered Instance model
            document.getElementById('ci-show-additional-params')?.addEventListener('change', (e) => {
                document.getElementById('ci-additional-params-options').classList.toggle('hidden', !e.target.checked);
            });
        }

        // Get CI augmentation values from sliders
        function getCIAugValues() {
            const rotation = parseInt(document.getElementById('ci-aug-rotation-val')?.value) || 0;
            const scaleRange = parseInt(document.getElementById('ci-aug-scale-val')?.value) || 0;
            const translate = parseInt(document.getElementById('ci-aug-translate-val')?.value) || 0;
            const brightness = parseInt(document.getElementById('ci-aug-brightness-val')?.value) || 0;
            const contrast = parseInt(document.getElementById('ci-aug-contrast-val')?.value) || 0;
            return {
                rotation,
                scaleMin: 1.0 - scaleRange / 100,
                scaleMax: 1.0 + scaleRange / 100,
                translate,
                brightnessMin: 1.0 - brightness / 100,
                brightnessMax: 1.0 + brightness / 100,
                contrastMin: 1.0 - contrast / 100,
                contrastMax: 1.0 + contrast / 100
            };
        }

        function updateCIAugSliderValue(type) {
            const v = getCIAugValues();
            if (type === 'rotation') {
                document.getElementById('ci-rotation-value').textContent = v.rotation > 0 ? `Â±${v.rotation}Â°` : 'Off';
            } else if (type === 'scale') {
                const range = parseInt(document.getElementById('ci-aug-scale-val')?.value) || 0;
                document.getElementById('ci-scale-aug-value').textContent = range > 0 ? `${v.scaleMin.toFixed(2)} - ${v.scaleMax.toFixed(2)}` : 'Off';
            } else if (type === 'translate') {
                const pct = parseInt(document.getElementById('ci-aug-translate-val')?.value) || 0;
                document.getElementById('ci-translate-value').textContent = pct > 0 ? `Â±${pct}%` : 'Off';
            } else if (type === 'brightness') {
                const pct = parseInt(document.getElementById('ci-aug-brightness-val')?.value) || 0;
                document.getElementById('ci-brightness-value').textContent = pct > 0 ? `Â±${pct}%` : 'Off';
            } else if (type === 'contrast') {
                const pct = parseInt(document.getElementById('ci-aug-contrast-val')?.value) || 0;
                document.getElementById('ci-contrast-value').textContent = pct > 0 ? `Â±${pct}%` : 'Off';
            }
            updateCIAugPreview();
            // Update crop size when rotation/scale changes (affects padding)
            if (type === 'rotation' || type === 'scale') {
                updateCICropPreview();
            }
        }

        let currentCIAugRandom = { rotation: 0, scale: 1, translateX: 0, translateY: 0, brightness: 1, contrast: 1 };

        function randomizeCIAugPreview() {
            const v = getCIAugValues();
            currentCIAugRandom = {
                rotation: v.rotation > 0 ? (Math.random() * 2 - 1) * v.rotation : 0,
                scale: v.scaleMin < 1 || v.scaleMax > 1 ? v.scaleMin + Math.random() * (v.scaleMax - v.scaleMin) : 1,
                translateX: v.translate > 0 ? (Math.random() * 2 - 1) * v.translate : 0,
                translateY: v.translate > 0 ? (Math.random() * 2 - 1) * v.translate : 0,
                brightness: v.brightnessMin < 1 || v.brightnessMax > 1 ? v.brightnessMin + Math.random() * (v.brightnessMax - v.brightnessMin) : 1,
                contrast: v.contrastMin < 1 || v.contrastMax > 1 ? v.contrastMin + Math.random() * (v.contrastMax - v.contrastMin) : 1
            };
            updateCIAugPreview();
        }

        function updateCIAugPreview() {
            if (!slpData || !instancesData) return;

            const CANVAS_W = 150, CANVAS_H = 150;
            const bbox = instancesData.bbox;
            const points = instancesData.points;
            if (!bbox) return;

            const origCanvas = document.getElementById('ci-aug-original');
            const augCanvas = document.getElementById('ci-aug-preview');
            if (!origCanvas || !augCanvas) return;

            // Get crop size from UI or use suggested
            const ciMaxStride = parseInt(document.getElementById('ci-max-stride')?.value) || 16;
            const cropSizeInput = document.getElementById('crop-size');
            const suggestedCrop = computeSuggestedCropSize(slpData.maxMaxDim, ciMaxStride, true);
            const cropSize = cropSizeInput?.value ? parseInt(cropSizeInput.value) : suggestedCrop;

            // Get anchor position
            const anchorNode = selectedAnchor;
            let anchorX, anchorY;
            if (anchorNode) {
                const anchorPt = points.find(p => p.node === anchorNode);
                if (anchorPt) {
                    anchorX = anchorPt.x;
                    anchorY = anchorPt.y;
                } else {
                    anchorX = (bbox.minX + bbox.maxX) / 2;
                    anchorY = (bbox.minY + bbox.maxY) / 2;
                }
            } else {
                anchorX = (bbox.minX + bbox.maxX) / 2;
                anchorY = (bbox.minY + bbox.maxY) / 2;
            }

            // Calculate crop region in source coordinates
            const cropHalf = cropSize / 2;
            const cropMinX = anchorX - cropHalf;
            const cropMinY = anchorY - cropHalf;

            // Scale to fit canvas
            const scale = (CANVAS_W - 10) / cropSize;

            // Helper to draw crop content (used for both original and augmented)
            function drawCropContent(ctx, applyAug = false) {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

                if (applyAug) {
                    ctx.save();
                    ctx.translate(CANVAS_W / 2, CANVAS_H / 2);
                    ctx.rotate(currentCIAugRandom.rotation * Math.PI / 180);
                    ctx.scale(currentCIAugRandom.scale, currentCIAugRandom.scale);
                    ctx.translate(currentCIAugRandom.translateX * CANVAS_W / 100, currentCIAugRandom.translateY * CANVAS_H / 100);
                    ctx.translate(-CANVAS_W / 2, -CANVAS_H / 2);
                    ctx.filter = `brightness(${currentCIAugRandom.brightness}) contrast(${currentCIAugRandom.contrast})`;
                }

                // Draw video frame crop if available
                if (videoFrame) {
                    try {
                        const srcX = Math.max(0, cropMinX);
                        const srcY = Math.max(0, cropMinY);
                        const srcW = Math.min(cropSize, videoFrame.width - srcX);
                        const srcH = Math.min(cropSize, videoFrame.height - srcY);
                        const destX = (srcX - cropMinX) * scale + 5;
                        const destY = (srcY - cropMinY) * scale + 5;
                        ctx.drawImage(
                            videoFrame,
                            srcX, srcY, srcW, srcH,
                            destX, destY, srcW * scale, srcH * scale
                        );
                    } catch (e) {}
                }

                // Reset filter before drawing skeleton
                if (applyAug) ctx.filter = 'none';

                // Draw skeleton edges
                ctx.strokeStyle = videoFrame ? 'rgba(255, 200, 50, 0.9)' : 'rgba(100, 180, 255, 0.6)';
                ctx.lineWidth = 1.5;
                for (const edge of slpData.skeleton.edges) {
                    const srcName = slpData.skeleton.nodes[edge[0]];
                    const dstName = slpData.skeleton.nodes[edge[1]];
                    const srcPt = points.find(p => p.node === srcName);
                    const dstPt = points.find(p => p.node === dstName);
                    if (srcPt && dstPt) {
                        const x1 = (srcPt.x - cropMinX) * scale + 5;
                        const y1 = (srcPt.y - cropMinY) * scale + 5;
                        const x2 = (dstPt.x - cropMinX) * scale + 5;
                        const y2 = (dstPt.y - cropMinY) * scale + 5;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }

                // Draw keypoints
                for (const pt of points) {
                    const x = (pt.x - cropMinX) * scale + 5;
                    const y = (pt.y - cropMinY) * scale + 5;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = videoFrame ? 'rgba(255, 200, 50, 0.9)' : 'rgba(100, 180, 255, 0.8)';
                    ctx.fill();
                }

                if (applyAug) ctx.restore();
            }

            // Draw original
            const ctx = origCanvas.getContext('2d');
            origCanvas.width = CANVAS_W;
            origCanvas.height = CANVAS_H;
            drawCropContent(ctx, false);

            // Draw augmented version
            const augCtx = augCanvas.getContext('2d');
            augCanvas.width = CANVAS_W;
            augCanvas.height = CANVAS_H;
            drawCropContent(augCtx, true);
        }

        // Anchor point population
        function populateAnchorList(containerId) {
            const container = document.getElementById(containerId);
            if (!slpData) return;

            let html = `<div class="anchor-item ${!selectedAnchor ? 'selected' : ''}" data-anchor="" onclick="selectAnchor('${containerId}', '')">
                <span>None (bbox center)</span>
            </div>`;

            for (const node of slpData.skeleton.nodes) {
                const vis = slpData.keypointVisibility[node];
                const pct = vis.total > 0 ? Math.round((vis.visible / vis.total) * 100) : 0;
                const visClass = pct > 80 ? 'high' : (pct > 50 ? 'medium' : 'low');

                html += `
                    <div class="anchor-item" data-anchor="${node}" onclick="selectAnchor('${containerId}', '${node}')">
                        <span>${node}</span>
                        <span class="anchor-visibility ${visClass}">${pct}%</span>
                    </div>
                `;
            }
            container.innerHTML = html;

            // Draw anchor preview if we have instance data
            if (containerId === 'anchor-list') {
                drawAnchorPreview(selectedAnchor);
            }
        }

        function selectAnchor(containerId, anchor) {
            if (containerId === 'anchor-list') {
                selectedAnchor = anchor || null;
                drawAnchorPreview(selectedAnchor);
                // Also update CI crop preview since anchor is shared
                updateCICropPreview();
            }

            document.querySelectorAll(`#${containerId} .anchor-item`).forEach(item => {
                item.classList.toggle('selected', item.dataset.anchor === anchor);
            });
        }

        function drawAnchorPreview(anchorNode) {
            const canvas = document.getElementById('anchor-preview-canvas');
            if (!canvas || !slpData) return;

            const ctx = canvas.getContext('2d');
            const width = 280;
            const height = 240;
            canvas.width = width;
            canvas.height = height;

            // Clear canvas with dark background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            // If we have sample instance data, draw it
            if (instancesData && instancesData.points.length > 0) {
                const points = instancesData.points;
                const bbox = instancesData.bbox;
                const hasVideo = !!videoFrame;

                // Calculate crop region with 20% margin around bbox
                const bboxW = bbox.maxX - bbox.minX || 1;
                const bboxH = bbox.maxY - bbox.minY || 1;
                const margin = Math.max(bboxW, bboxH) * 0.2;
                const bboxCenterX = (bbox.minX + bbox.maxX) / 2;
                const bboxCenterY = (bbox.minY + bbox.maxY) / 2;

                // Crop region in source coordinates
                let cropMinX = bbox.minX - margin;
                let cropMinY = bbox.minY - margin;
                let cropMaxX = bbox.maxX + margin;
                let cropMaxY = bbox.maxY + margin;

                // Clamp to image bounds if we have video
                if (hasVideo) {
                    cropMinX = Math.max(0, cropMinX);
                    cropMinY = Math.max(0, cropMinY);
                    cropMaxX = Math.min(videoFrame.width, cropMaxX);
                    cropMaxY = Math.min(videoFrame.height, cropMaxY);
                }
                const cropW = cropMaxX - cropMinX;
                const cropH = cropMaxY - cropMinY;

                // Calculate transform to map source crop to canvas
                const scale = Math.min(width / cropW, height / cropH);
                const offsetX = (width - cropW * scale) / 2 - cropMinX * scale;
                const offsetY = (height - cropH * scale) / 2 - cropMinY * scale;

                const transform = (pt) => pt ? {
                    x: pt.x * scale + offsetX,
                    y: pt.y * scale + offsetY
                } : null;

                // Draw video frame crop as background if available
                if (hasVideo) {
                    try {
                        ctx.drawImage(
                            videoFrame,
                            cropMinX, cropMinY, cropW, cropH,  // Source rect
                            (width - cropW * scale) / 2, (height - cropH * scale) / 2, cropW * scale, cropH * scale  // Dest rect
                        );
                        // Slight darkening overlay for better skeleton visibility
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        ctx.fillRect(0, 0, width, height);
                    } catch (e) {
                        // Fall back to dark background
                    }
                }

                // Store transform data for click detection
                const canvasPoints = [];
                const bboxCenterCanvas = transform({ x: bboxCenterX, y: bboxCenterY });
                bboxCenterCanvas.node = null;  // null means bbox center

                // Get crop size from input (for Centered Instance, defaults to ~animal size)
                const cropSizeInput = document.getElementById('crop-size');
                const cropSize = cropSizeInput?.value ? parseInt(cropSizeInput.value) : Math.round(slpData.maxAnimalSize * 1.5);
                const cropSizeCanvas = cropSize * scale;

                // Determine anchor position for crop box
                let anchorPos = bboxCenterCanvas;
                if (anchorNode) {
                    const anchorPt = points.find(p => p.node === anchorNode);
                    if (anchorPt) {
                        anchorPos = transform({ x: anchorPt.x, y: anchorPt.y });
                    }
                }

                // Draw crop box around anchor (orange dashed)
                ctx.strokeStyle = '#f97316';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                const cropHalf = cropSizeCanvas / 2;
                ctx.strokeRect(
                    anchorPos.x - cropHalf,
                    anchorPos.y - cropHalf,
                    cropSizeCanvas,
                    cropSizeCanvas
                );
                ctx.setLineDash([]);

                // Draw edges (skeleton bones) - use yellow/orange when video present
                ctx.strokeStyle = hasVideo ? 'rgba(255, 200, 50, 0.9)' : 'rgba(100, 180, 255, 0.6)';
                ctx.lineWidth = 2;
                for (const edge of slpData.skeleton.edges) {
                    const srcName = slpData.skeleton.nodes[edge[0]];
                    const dstName = slpData.skeleton.nodes[edge[1]];
                    const srcPt = points.find(p => p.node === srcName);
                    const dstPt = points.find(p => p.node === dstName);
                    if (srcPt && dstPt) {
                        const p1 = transform({ x: srcPt.x, y: srcPt.y });
                        const p2 = transform({ x: dstPt.x, y: dstPt.y });
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }

                // Find selected node index
                const selectedIdx = anchorNode ? slpData.skeleton.nodes.indexOf(anchorNode) : -1;

                // Draw all nodes (small) - skip the selected one, draw it separately
                for (const pt of points) {
                    if (pt.node === anchorNode) continue; // Skip selected, draw it separately
                    const tpt = transform({ x: pt.x, y: pt.y });
                    if (!tpt) continue;

                    canvasPoints.push({ x: tpt.x, y: tpt.y, node: pt.node, radius: 5 });

                    ctx.beginPath();
                    ctx.arc(tpt.x, tpt.y, 5, 0, Math.PI * 2);
                    ctx.fillStyle = hasVideo ? 'rgba(255, 200, 50, 0.9)' : 'rgba(100, 180, 255, 0.8)';
                    ctx.fill();
                }

                // Highlight selected anchor with glow ring (magenta/red)
                if (anchorNode && selectedIdx >= 0) {
                    const anchorPt = points.find(p => p.node === anchorNode);
                    if (anchorPt) {
                        const tpt = transform({ x: anchorPt.x, y: anchorPt.y });
                        canvasPoints.push({ x: tpt.x, y: tpt.y, node: anchorNode, radius: 12 });

                        // Draw outer glow ring
                        ctx.beginPath();
                        ctx.arc(tpt.x, tpt.y, 12, 0, Math.PI * 2);
                        ctx.strokeStyle = '#ff3366';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        // Draw filled center - bright magenta/pink
                        ctx.beginPath();
                        ctx.arc(tpt.x, tpt.y, 6, 0, Math.PI * 2);
                        ctx.fillStyle = '#ff3366';
                        ctx.fill();
                        // White inner dot for contrast
                        ctx.beginPath();
                        ctx.arc(tpt.x, tpt.y, 2, 0, Math.PI * 2);
                        ctx.fillStyle = '#ffffff';
                        ctx.fill();
                    }
                } else {
                    // No anchor - highlight bbox center with crosshair
                    ctx.strokeStyle = '#ff3366';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(bboxCenterCanvas.x - 10, bboxCenterCanvas.y);
                    ctx.lineTo(bboxCenterCanvas.x + 10, bboxCenterCanvas.y);
                    ctx.moveTo(bboxCenterCanvas.x, bboxCenterCanvas.y - 10);
                    ctx.lineTo(bboxCenterCanvas.x, bboxCenterCanvas.y + 10);
                    ctx.stroke();
                    // Center dot
                    ctx.beginPath();
                    ctx.arc(bboxCenterCanvas.x, bboxCenterCanvas.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff3366';
                    ctx.fill();
                }

                // Add bbox center to clickable points
                canvasPoints.push({ x: bboxCenterCanvas.x, y: bboxCenterCanvas.y, node: null, radius: 10 });

                // Store canvas data for click detection
                anchorCanvasData = {
                    points: canvasPoints,
                    bboxCenter: bboxCenterCanvas,
                    scale, offsetX, offsetY
                };

                // Label at bottom
                ctx.fillStyle = '#aaa';
                ctx.font = '12px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`Anchor: ${anchorNode || 'Bbox Center'}`, width / 2, height - 10);

                // Instructions at top
                ctx.fillStyle = '#666';
                ctx.font = '10px system-ui';
                ctx.fillText('Click a keypoint to select', width / 2, 14);
            } else {
                // No instance data - show placeholder
                ctx.fillStyle = '#666';
                ctx.font = '12px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText('No instance data available', width / 2, height / 2 - 10);
                ctx.fillText('(Load SLP with labeled frames)', width / 2, height / 2 + 10);
                anchorCanvasData = null;
            }
        }

        // Handle anchor canvas click
        function handleAnchorCanvasClick(event) {
            if (!anchorCanvasData) return;

            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Check if clicked on bbox center first
            const bc = anchorCanvasData.bboxCenter;
            const bcDist = Math.sqrt((x - bc.x) ** 2 + (y - bc.y) ** 2);
            if (bcDist < 12) {
                selectAnchor('anchor-list', '');
                return;
            }

            // Check if clicked on any keypoint
            for (const pt of anchorCanvasData.points) {
                const dist = Math.sqrt((x - pt.x) ** 2 + (y - pt.y) ** 2);
                if (dist < pt.radius + 4) {  // Add some tolerance
                    selectAnchor('anchor-list', pt.node);
                    return;
                }
            }
        }

        // Handle anchor canvas hover for tooltips
        function handleAnchorCanvasHover(event) {
            const tooltip = document.getElementById('anchor-canvas-tooltip');
            if (!anchorCanvasData || !tooltip) return;

            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            let hoverNode = null;

            // Check bbox center
            const bc = anchorCanvasData.bboxCenter;
            const bcDist = Math.sqrt((x - bc.x) ** 2 + (y - bc.y) ** 2);
            if (bcDist < 12) {
                hoverNode = 'Bbox Center';
            }

            // Check keypoints
            if (!hoverNode) {
                for (const pt of anchorCanvasData.points) {
                    const dist = Math.sqrt((x - pt.x) ** 2 + (y - pt.y) ** 2);
                    if (dist < pt.radius + 4) {
                        hoverNode = pt.node;
                        break;
                    }
                }
            }

            if (hoverNode) {
                tooltip.textContent = hoverNode;
                tooltip.style.display = 'block';
                tooltip.style.left = (event.clientX - rect.left + 10) + 'px';
                tooltip.style.top = (event.clientY - rect.top - 25) + 'px';
                canvas.style.cursor = 'pointer';
            } else {
                tooltip.style.display = 'none';
                canvas.style.cursor = 'default';
            }
        }

        function handleAnchorCanvasLeave() {
            const tooltip = document.getElementById('anchor-canvas-tooltip');
            if (tooltip) tooltip.style.display = 'none';
        }

        // Tab handling
        function initTabs() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabGroup = tab.parentElement;
                    const tabAttr = tab.dataset.tab || tab.dataset.exportTab || tab.dataset.previewTab;

                    tabGroup.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    if (tab.dataset.tab) {
                        document.querySelectorAll('.tab-content').forEach(c => {
                            if (c.id.startsWith('tab-')) c.classList.remove('active');
                        });
                        document.getElementById(`tab-${tabAttr === 'centroid' ? 'main' : tabAttr}`).classList.add('active');

                        // Refresh config preview when switching to that tab
                        if (tabAttr === 'config-preview') {
                            refreshConfigPreview();
                        }
                    } else if (tab.dataset.previewTab) {
                        // Handle preview config sub-tabs
                        document.querySelectorAll('.tab-content').forEach(c => {
                            if (c.id.startsWith('preview-config')) c.classList.remove('active');
                        });
                        document.getElementById(`preview-${tabAttr}`).classList.add('active');
                    } else {
                        document.querySelectorAll('.tab-content').forEach(c => {
                            if (c.id.startsWith('export-')) c.classList.remove('active');
                        });
                        document.getElementById(`export-${tabAttr}`).classList.add('active');
                    }
                });
            });
        }

        // Get advanced options from UI
        function getAdvancedOptions() {
            return {
                // Data
                numWorkers: parseInt(document.getElementById('num-workers')?.value) || 0,
                dataPipeline: document.getElementById('data-pipeline')?.value || 'torch_dataset',
                maxHeight: document.getElementById('max-height')?.value ? parseInt(document.getElementById('max-height').value) : null,
                maxWidth: document.getElementById('max-width')?.value ? parseInt(document.getElementById('max-width').value) : null,
                // Model pretrained weights
                useImageNetPretrained: document.getElementById('use-imagenet-pretrained')?.checked ?? true,
                pretrainedBackboneWeights: document.getElementById('pretrained-backbone-path')?.value || null,
                pretrainedHeadWeights: document.getElementById('pretrained-head-path')?.value || null,
                // PAF settings (bottom-up)
                pafOutputStride: parseInt(document.getElementById('paf-output-stride')?.value) || 2,
                confmapsLossWeight: parseFloat(document.getElementById('confmaps-loss-weight')?.value) || 1.0,
                pafLossWeight: parseFloat(document.getElementById('paf-loss-weight')?.value) || 1.0,
                // Multi-class settings
                mcConfmapsLossWeight: parseFloat(document.getElementById('mc-confmaps-loss-weight')?.value) || 1.0,
                classLossWeight: parseFloat(document.getElementById('class-loss-weight')?.value) || 1.0,
                classFcLayers: parseInt(document.getElementById('class-fc-layers')?.value) || 1,
                classFcUnits: parseInt(document.getElementById('class-fc-units')?.value) || 64,
                // Trainer
                minSteps: parseInt(document.getElementById('min-steps')?.value) || 200,
                seed: document.getElementById('random-seed')?.value ? parseInt(document.getElementById('random-seed').value) : null,
                resumeCkptPath: document.getElementById('resume-ckpt-path')?.value || null,
                // LR Scheduler
                lrScheduler: document.getElementById('lr-scheduler')?.value || 'none',
                // Step LR params
                stepLrStepSize: parseInt(document.getElementById('step-lr-step-size')?.value) || 10,
                stepLrGamma: parseFloat(document.getElementById('step-lr-gamma')?.value) || 0.1,
                // Reduce on Plateau params
                lrPatience: parseInt(document.getElementById('lr-patience')?.value) || 5,
                reduceLrFactor: parseFloat(document.getElementById('reduce-lr-factor')?.value) || 0.5,
                reduceLrMin: parseFloat(document.getElementById('reduce-lr-min')?.value) || 1e-8,
                reduceLrCooldown: parseInt(document.getElementById('reduce-lr-cooldown')?.value) || 3,
                // Cosine Annealing + Warmup params
                cosineWarmupEpochs: parseInt(document.getElementById('cosine-warmup-epochs')?.value) || 5,
                cosineWarmupStartLr: parseFloat(document.getElementById('cosine-warmup-start-lr')?.value) || 0,
                cosineEtaMin: parseFloat(document.getElementById('cosine-eta-min')?.value) || 0,
                // Linear Warmup + Decay params
                linearWarmupEpochs: parseInt(document.getElementById('linear-warmup-epochs')?.value) || 5,
                linearWarmupStartLr: parseFloat(document.getElementById('linear-warmup-start-lr')?.value) || 0,
                linearEndLr: parseFloat(document.getElementById('linear-end-lr')?.value) || 0,
                // Augmentation values (from sliders)
                augRotation: parseInt(document.getElementById('aug-rotation-val')?.value) || 15,
                augScaleRange: parseInt(document.getElementById('aug-scale-val')?.value) || 10,
                augTranslate: parseInt(document.getElementById('aug-translate-val')?.value) / 100 || 0,
                augBrightness: parseInt(document.getElementById('aug-brightness-val')?.value) || 0,
                augContrast: parseInt(document.getElementById('aug-contrast-val')?.value) || 0,
                // OHKM
                enableOhkm: document.getElementById('enable-ohkm')?.checked || false,
                ohkmRatio: parseFloat(document.getElementById('ohkm-ratio')?.value) || 2.0,
                ohkmLossScale: parseFloat(document.getElementById('ohkm-loss-scale')?.value) || 5.0,
                ohkmMinHard: parseInt(document.getElementById('ohkm-min-hard')?.value) || 2,
                ohkmMaxHard: document.getElementById('ohkm-max-hard')?.value ? parseInt(document.getElementById('ohkm-max-hard').value) : null,
                // Checkpoints
                ckptDir: document.getElementById('ckpt-dir')?.value || './models',
                runName: document.getElementById('run-name')?.value || null,
                ckptSaveTopK: parseInt(document.getElementById('ckpt-save-top-k')?.value) || 1,
                ckptSaveLast: document.getElementById('ckpt-save-last')?.checked ?? true,
                // WandB
                enableWandb: document.getElementById('enable-wandb')?.checked || false,
                wandbEntity: document.getElementById('wandb-entity')?.value || null,
                wandbProject: document.getElementById('wandb-project')?.value || 'sleap-training',
                wandbName: document.getElementById('wandb-name')?.value || null,
                wandbMode: document.getElementById('wandb-mode')?.value || null,
                wandbApiKey: document.getElementById('wandb-api-key')?.value || null,
                wandbVizEnabled: document.getElementById('wandb-viz-enabled')?.checked ?? true,
                wandbSaveViz: document.getElementById('wandb-save-viz')?.checked || false,
                // Visualization
                enableViz: document.getElementById('enable-viz')?.checked || false,
                vizKeepFolder: document.getElementById('viz-keep-folder')?.checked || false,
                // Early stopping
                esPatience: parseInt(document.getElementById('es-patience')?.value) || 10,
                esMinDelta: parseFloat(document.getElementById('es-min-delta')?.value) || 1e-8,
                // Evaluation (OKS)
                enableEval: document.getElementById('enable-eval')?.checked || false,
                evalFrequency: parseInt(document.getElementById('eval-frequency')?.value) || 1,
                evalOksStddev: parseFloat(document.getElementById('eval-oks-stddev')?.value) || 0.025
            };
        }

        // Get CI-specific advanced options from UI
        function getCIAdvancedOptions() {
            return {
                // Data
                numWorkers: parseInt(document.getElementById('ci-num-workers')?.value) || 0,
                dataPipeline: document.getElementById('ci-data-pipeline')?.value || 'torch_dataset',
                maxHeight: null,  // CI uses crop_size, not max_height/max_width
                maxWidth: null,
                // Crop settings
                minCropSize: parseInt(document.getElementById('ci-min-crop-size')?.value) || 100,
                cropPadding: document.getElementById('ci-crop-padding')?.value ? parseInt(document.getElementById('ci-crop-padding').value) : null,
                // Model pretrained weights
                useImageNetPretrained: document.getElementById('use-imagenet-pretrained')?.checked ?? true,
                pretrainedBackboneWeights: document.getElementById('ci-pretrained-backbone-path')?.value || null,
                pretrainedHeadWeights: document.getElementById('ci-pretrained-head-path')?.value || null,
                // Trainer
                minSteps: parseInt(document.getElementById('ci-min-steps')?.value) || 200,
                seed: document.getElementById('ci-random-seed')?.value ? parseInt(document.getElementById('ci-random-seed').value) : null,
                // LR Scheduler
                lrScheduler: document.getElementById('ci-lr-scheduler')?.value || 'reduce_on_plateau',
                // Step LR params
                stepLrStepSize: parseInt(document.getElementById('ci-step-lr-step-size')?.value) || 10,
                stepLrGamma: parseFloat(document.getElementById('ci-step-lr-gamma')?.value) || 0.1,
                // Reduce on Plateau params
                lrPatience: parseInt(document.getElementById('ci-lr-patience')?.value) || 5,
                reduceLrFactor: parseFloat(document.getElementById('ci-reduce-lr-factor')?.value) || 0.5,
                reduceLrMin: parseFloat(document.getElementById('ci-reduce-lr-min')?.value) || 1e-8,
                reduceLrCooldown: parseInt(document.getElementById('ci-reduce-lr-cooldown')?.value) || 3,
                // Cosine Annealing + Warmup params
                cosineWarmupEpochs: parseInt(document.getElementById('ci-cosine-warmup-epochs')?.value) || 5,
                cosineWarmupStartLr: parseFloat(document.getElementById('ci-cosine-warmup-start-lr')?.value) || 0,
                cosineEtaMin: parseFloat(document.getElementById('ci-cosine-eta-min')?.value) || 0,
                // Linear Warmup + Decay params
                linearWarmupEpochs: parseInt(document.getElementById('ci-linear-warmup-epochs')?.value) || 5,
                linearWarmupStartLr: parseFloat(document.getElementById('ci-linear-warmup-start-lr')?.value) || 0,
                linearEndLr: parseFloat(document.getElementById('ci-linear-end-lr')?.value) || 0,
                // OHKM
                enableOhkm: document.getElementById('ci-enable-ohkm')?.checked || false,
                ohkmRatio: parseFloat(document.getElementById('ci-ohkm-ratio')?.value) || 2.0,
                ohkmLossScale: parseFloat(document.getElementById('ci-ohkm-loss-scale')?.value) || 5.0,
                ohkmMinHard: parseInt(document.getElementById('ci-ohkm-min-hard')?.value) || 2,
                ohkmMaxHard: document.getElementById('ci-ohkm-max-hard')?.value ? parseInt(document.getElementById('ci-ohkm-max-hard').value) : null,
                // Checkpoints
                ckptDir: document.getElementById('ci-ckpt-dir')?.value || './models',
                runName: document.getElementById('ci-run-name')?.value || null,
                ckptSaveTopK: parseInt(document.getElementById('ci-ckpt-save-top-k')?.value) || 1,
                ckptSaveLast: document.getElementById('ci-ckpt-save-last')?.checked ?? true,
                resumeCkptPath: document.getElementById('ci-resume-ckpt-path')?.value || null,
                // WandB
                enableWandb: document.getElementById('ci-enable-wandb')?.checked || false,
                wandbEntity: document.getElementById('ci-wandb-entity')?.value || null,
                wandbProject: document.getElementById('ci-wandb-project')?.value || 'sleap-training',
                wandbName: document.getElementById('ci-wandb-name')?.value || null,
                wandbMode: document.getElementById('ci-wandb-mode')?.value || null,
                wandbApiKey: document.getElementById('ci-wandb-api-key')?.value || null,
                wandbVizEnabled: document.getElementById('ci-wandb-viz-enabled')?.checked ?? true,
                wandbSaveViz: document.getElementById('ci-wandb-save-viz')?.checked || false,
                // Visualization
                enableViz: document.getElementById('ci-enable-viz')?.checked || false,
                vizKeepFolder: document.getElementById('ci-viz-keep-folder')?.checked || false,
                // Early stopping
                esPatience: parseInt(document.getElementById('ci-es-patience')?.value) || 5,
                esMinDelta: parseFloat(document.getElementById('ci-es-min-delta')?.value) || 1e-6,
                // Evaluation
                enableEval: document.getElementById('ci-enable-eval')?.checked || false,
                evalFrequency: parseInt(document.getElementById('ci-eval-frequency')?.value) || 1,
                evalOksStddev: parseFloat(document.getElementById('ci-eval-oks-stddev')?.value) || 0.025,
                // CI-specific augmentation values
                augRotation: parseInt(document.getElementById('ci-aug-rotation-val')?.value) || 0,
                augScaleRange: parseInt(document.getElementById('ci-aug-scale-val')?.value) || 0,
                augTranslate: parseInt(document.getElementById('ci-aug-translate-val')?.value) || 0,
                augBrightness: parseInt(document.getElementById('ci-aug-brightness-val')?.value) || 0,
                augContrast: parseInt(document.getElementById('ci-aug-contrast-val')?.value) || 0
            };
        }

        // Refresh config preview
        function refreshConfigPreview() {
            if (!slpData) return;

            // Get all current parameter values and generate config
            const headType = isTopDown ? 'centroid' : selectedModelType;
            const scale = parseFloat(document.getElementById('scale').value) || 1.0;
            const valFraction = parseFloat(document.getElementById('val-fraction').value) || 0.1;
            const useAug = document.getElementById('use-augmentation')?.checked || false;
            const backbone = document.getElementById('backbone').value;
            const maxStride = parseInt(document.getElementById('max-stride').value) || 16;
            const filters = parseInt(document.getElementById('filters').value) || 32;
            const sigma = parseFloat(document.getElementById('sigma').value) || 5.0;
            const outputStride = parseInt(document.getElementById('output-stride').value) || 1;
            const batchSize = parseInt(document.getElementById('batch-size').value) || 4;
            const maxEpochs = parseInt(document.getElementById('max-epochs').value) || 200;
            const learningRate = document.getElementById('learning-rate').value;
            const optimizer = document.getElementById('optimizer').value;
            const accelerator = document.getElementById('accelerator')?.value || 'gpu';
            const earlyStopping = document.getElementById('early-stopping')?.checked || false;
            const saveCkpt = document.getElementById('save-ckpt')?.checked || true;
            const inputChannels = parseInt(document.getElementById('input-channels').value) || 1;
            const advancedOptions = getAdvancedOptions();

            const config1 = generateConfigYaml({
                headType, scale, valFraction, useAug, backbone, maxStride, filters, sigma, outputStride,
                batchSize, maxEpochs, learningRate, optimizer, accelerator, earlyStopping, saveCkpt,
                anchorPart: selectedAnchor, inputChannels, advancedOptions
            });
            document.getElementById('yaml-preview-1').textContent = config1;

            // Update UI for top-down
            if (isTopDown) {
                document.getElementById('preview-tab-2').classList.remove('hidden');
                document.getElementById('preview-tab-1').textContent = 'Centroid Config';

                // Get CI-specific parameters (model + training)
                const ciMaxStride = parseInt(document.getElementById('ci-max-stride').value) || 16;
                const cropSize = parseInt(document.getElementById('crop-size').value) || Math.ceil(slpData.maxAnimalSize * 1.5 / ciMaxStride) * ciMaxStride;
                const ciHeadType = selectedModelType === 'multi_class_topdown' ? 'multi_class_topdown' : 'centered_instance';
                const ciScale = parseFloat(document.getElementById('ci-scale').value) || 1.0;
                const ciBackbone = document.getElementById('ci-backbone')?.value || 'unet';
                const ciFilters = parseInt(document.getElementById('ci-filters')?.value) || 32;
                const ciFiltersRate = parseFloat(document.getElementById('ci-filters-rate')?.value) || 1.5;
                const ciSigma = parseFloat(document.getElementById('ci-sigma').value) || 2.5;
                const ciOutputStride = parseInt(document.getElementById('ci-output-stride').value) || 1;
                // CI-specific training parameters
                const ciBatchSize = parseInt(document.getElementById('ci-batch-size')?.value) || 4;
                const ciMaxEpochs = parseInt(document.getElementById('ci-max-epochs')?.value) || 200;
                const ciLearningRate = document.getElementById('ci-learning-rate')?.value || '0.0001';
                const ciOptimizer = document.getElementById('ci-optimizer')?.value || 'Adam';
                const ciAccelerator = document.getElementById('ci-accelerator')?.value || 'auto';
                const ciEarlyStopping = document.getElementById('ci-early-stopping')?.checked ?? true;
                const ciSaveCkpt = document.getElementById('ci-save-ckpt')?.checked ?? true;
                const ciUseAug = document.getElementById('ci-use-augmentation')?.checked || false;
                const ciAdvancedOptions = getCIAdvancedOptions();

                const config2 = generateConfigYaml({
                    headType: ciHeadType, scale: ciScale, valFraction, cropSize, useAug: ciUseAug,
                    backbone: ciBackbone, maxStride: ciMaxStride, filters: ciFilters, filtersRate: ciFiltersRate,
                    sigma: ciSigma, outputStride: ciOutputStride,
                    batchSize: ciBatchSize, maxEpochs: ciMaxEpochs, learningRate: ciLearningRate,
                    optimizer: ciOptimizer, accelerator: ciAccelerator, earlyStopping: ciEarlyStopping, saveCkpt: ciSaveCkpt,
                    isCenteredInstance: true, anchorPart: selectedAnchor, inputChannels, advancedOptions: ciAdvancedOptions
                });
                document.getElementById('yaml-preview-2').textContent = config2;
            } else {
                document.getElementById('preview-tab-2').classList.add('hidden');
                document.getElementById('preview-tab-1').textContent = 'Configuration';
            }
        }

        function copyYamlPreview(configNum) {
            const yaml = document.getElementById(`yaml-preview-${configNum}`).textContent;
            navigator.clipboard.writeText(yaml)
                .then(() => alert('Copied to clipboard!'))
                .catch(() => {
                    const ta = document.createElement('textarea');
                    ta.value = yaml;
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    alert('Copied to clipboard!');
                });
        }

        function downloadYamlPreview(configNum) {
            const yaml = document.getElementById(`yaml-preview-${configNum}`).textContent;
            let filename = 'training_config.yaml';
            if (isTopDown) filename = configNum === 1 ? 'centroid_config.yaml' : 'centered_instance_config.yaml';

            const blob = new Blob([yaml], { type: 'text/yaml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function toggleCollapsible(id) {
            document.getElementById(id).classList.toggle('expanded');
            document.getElementById(id + '-chevron').classList.toggle('rotated');
        }

        function toggleAdvancedOptions() {
            const show = document.getElementById('show-advanced').checked;
            document.getElementById('advanced-options').classList.toggle('hidden', !show);
        }

        function toggleEarlyStoppingOptions() {
            const show = document.getElementById('early-stopping').checked;
            document.getElementById('early-stopping-options').style.display = show ? 'block' : 'none';
        }

        function toggleOhkmOptions() {
            const show = document.getElementById('enable-ohkm').checked;
            document.getElementById('ohkm-options').style.display = show ? 'block' : 'none';
        }

        function toggleSaveCkptOptions() {
            const show = document.getElementById('save-ckpt').checked;
            document.getElementById('save-ckpt-options').style.display = show ? 'block' : 'none';
        }

        function toggleWandbOptions() {
            const show = document.getElementById('enable-wandb').checked;
            document.getElementById('wandb-options').style.display = show ? 'block' : 'none';
        }

        function toggleVizOptions() {
            const show = document.getElementById('enable-viz').checked;
            document.getElementById('viz-options').style.display = show ? 'block' : 'none';
        }

        function toggleEvalOptions() {
            const show = document.getElementById('enable-eval').checked;
            document.getElementById('eval-options').style.display = show ? 'block' : 'none';
        }

        function updateSchedulerOptions() {
            const scheduler = document.getElementById('lr-scheduler').value;
            const patienceGroup = document.getElementById('lr-patience-group');
            const stepLrOptions = document.getElementById('step-lr-options');
            const reduceLrOptions = document.getElementById('reduce-lr-options');
            const cosineWarmupOptions = document.getElementById('cosine-warmup-options');
            const linearWarmupDecayOptions = document.getElementById('linear-warmup-decay-options');

            // Show patience for reduce_on_plateau only
            patienceGroup.style.display = scheduler === 'reduce_on_plateau' ? 'block' : 'none';
            // Show step LR options when step_lr is selected
            stepLrOptions.style.display = scheduler === 'step_lr' ? 'block' : 'none';
            // Show reduce on plateau options when reduce_on_plateau is selected
            reduceLrOptions.style.display = scheduler === 'reduce_on_plateau' ? 'block' : 'none';
            // Show cosine annealing warmup options
            cosineWarmupOptions.style.display = scheduler === 'cosine_annealing_warmup' ? 'block' : 'none';
            // Show linear warmup + decay options
            linearWarmupDecayOptions.style.display = scheduler === 'linear_warmup_linear_decay' ? 'block' : 'none';
        }

        // CI (Centered Instance) tab toggle functions
        function toggleCIAdvancedOptions() {
            const show = document.getElementById('ci-show-advanced').checked;
            document.getElementById('ci-advanced-options').classList.toggle('hidden', !show);
        }

        function toggleCIEarlyStoppingOptions() {
            const show = document.getElementById('ci-early-stopping').checked;
            document.getElementById('ci-early-stopping-options').style.display = show ? 'block' : 'none';
        }

        function toggleCISaveCkptOptions() {
            const show = document.getElementById('ci-save-ckpt').checked;
            document.getElementById('ci-save-ckpt-options').style.display = show ? 'block' : 'none';
        }

        function toggleCIOhkmOptions() {
            const show = document.getElementById('ci-enable-ohkm').checked;
            document.getElementById('ci-ohkm-options').style.display = show ? 'block' : 'none';
        }

        function toggleCIWandbOptions() {
            const show = document.getElementById('ci-enable-wandb').checked;
            document.getElementById('ci-wandb-options').style.display = show ? 'block' : 'none';
        }

        function toggleCIVizOptions() {
            const show = document.getElementById('ci-enable-viz').checked;
            document.getElementById('ci-viz-options').style.display = show ? 'block' : 'none';
        }

        function toggleCIEvalOptions() {
            const show = document.getElementById('ci-enable-eval').checked;
            document.getElementById('ci-eval-options').style.display = show ? 'block' : 'none';
        }

        function updateCISchedulerOptions() {
            const scheduler = document.getElementById('ci-lr-scheduler').value;
            const patienceGroup = document.getElementById('ci-lr-patience-group');
            const stepLrOptions = document.getElementById('ci-step-lr-options');
            const reduceLrOptions = document.getElementById('ci-reduce-lr-options');
            const cosineWarmupOptions = document.getElementById('ci-cosine-warmup-options');
            const linearWarmupDecayOptions = document.getElementById('ci-linear-warmup-decay-options');

            patienceGroup.style.display = scheduler === 'reduce_on_plateau' ? 'block' : 'none';
            stepLrOptions.style.display = scheduler === 'step_lr' ? 'block' : 'none';
            reduceLrOptions.style.display = scheduler === 'reduce_on_plateau' ? 'block' : 'none';
            cosineWarmupOptions.style.display = scheduler === 'cosine_annealing_warmup' ? 'block' : 'none';
            linearWarmupDecayOptions.style.display = scheduler === 'linear_warmup_linear_decay' ? 'block' : 'none';
        }

        // Navigation
        function updateSteps() {
            for (let i = 1; i <= 4; i++) {
                document.getElementById(`step${i}`).classList.toggle('active', i === currentStep);
            }
        }

        function nextStep() {
            if (currentStep === 1 && slpData) {
                currentStep = 2;
                document.getElementById('model-type-section').classList.remove('hidden');
                document.getElementById('step1').classList.add('completed');
            } else if (currentStep === 2 && selectedModelType) {
                currentStep = 3;
                document.getElementById('parameters-section').classList.remove('hidden');
                document.getElementById('step2').classList.add('completed');
                // Show centered-instance tab only for top-down models, update tab label
                document.querySelector('.tab[data-tab="centered-instance"]').classList.toggle('hidden', !isTopDown);
                document.querySelector('.tab[data-tab="centroid"]').textContent = isTopDown ? 'Centroid Model' : 'Parameters';

                // Show anchor selector for centroid/centered_instance models
                const showAnchor = selectedModelType === 'centroid' || selectedModelType === 'topdown' ||
                                   selectedModelType === 'multi_class_topdown';
                document.getElementById('anchor-selector').classList.toggle('hidden', !showAnchor);
                if (showAnchor) populateAnchorList('anchor-list');

                setTimeout(() => {
                    updateRFVisualization();
                    updateModelInfo();
                    updateEffectiveSize();
                    if (isTopDown) updateCICropPreview();
                }, 100);
            } else if (currentStep === 3) {
                currentStep = 4;
                document.getElementById('export-section').classList.remove('hidden');
                document.getElementById('step3').classList.add('completed');
                generateYaml();
            }

            updateSteps();
            document.getElementById('prev-btn').disabled = currentStep === 1;
            document.getElementById('next-btn').disabled = currentStep === 4;
            document.getElementById('next-btn').textContent = currentStep === 3 ? 'Generate Config' : 'Next';
        }

        function prevStep() {
            if (currentStep > 1) {
                currentStep--;
                updateSteps();
                document.getElementById('prev-btn').disabled = currentStep === 1;
                document.getElementById('next-btn').disabled = false;
                document.getElementById('next-btn').textContent = currentStep === 3 ? 'Generate Config' : 'Next';
            }
        }

        // YAML Generation
        function generateYaml() {
            const scale = parseFloat(document.getElementById('scale').value);
            const valFraction = parseFloat(document.getElementById('val-fraction').value);
            const useAug = document.getElementById('use-augmentation').checked;
            const backbone = document.getElementById('backbone').value;
            const maxStride = parseInt(document.getElementById('max-stride').value);
            const filters = parseInt(document.getElementById('filters').value);
            const sigma = parseFloat(document.getElementById('sigma').value);
            const outputStride = parseInt(document.getElementById('output-stride').value);
            const batchSize = parseInt(document.getElementById('batch-size').value);
            const maxEpochs = parseInt(document.getElementById('max-epochs').value);
            const learningRate = parseFloat(document.getElementById('learning-rate').value);
            const optimizer = document.getElementById('optimizer').value;
            const accelerator = document.getElementById('accelerator').value;
            const earlyStopping = document.getElementById('early-stopping').checked;
            const saveCkpt = document.getElementById('save-ckpt').checked;
            const inputChannels = parseInt(document.getElementById('input-channels').value);

            // Advanced options - use getAdvancedOptions() to include all fields (eval, wandb details, etc.)
            const advancedOptions = getAdvancedOptions();

            // Determine head type
            let headType = selectedModelType;
            if (selectedModelType === 'topdown') headType = 'centroid';
            else if (selectedModelType === 'multi_class_topdown') headType = 'centroid';

            // Generate first config (use loaded centroid config as base if available)
            const config1 = generateConfigYaml({
                headType, scale, valFraction, useAug, backbone, maxStride, filters, sigma, outputStride,
                batchSize, maxEpochs, learningRate, optimizer, accelerator, earlyStopping, saveCkpt,
                anchorPart: selectedAnchor, inputChannels, advancedOptions,
                loadedConfig: loadedCentroidConfig
            });
            document.getElementById('yaml-output-1').textContent = config1;

            // Update UI for top-down
            if (isTopDown) {
                document.getElementById('export-tab-2').classList.remove('hidden');
                document.getElementById('download-all-btn').classList.remove('hidden');
                document.getElementById('export-tab-1').textContent = 'Centroid Config';

                // Get CI-specific parameters (model + training)
                const ciMaxStride = parseInt(document.getElementById('ci-max-stride').value) || 16;
                const cropSize = parseInt(document.getElementById('crop-size').value) || Math.ceil(slpData.maxAnimalSize * 1.5 / ciMaxStride) * ciMaxStride;
                const ciHeadType = selectedModelType === 'multi_class_topdown' ? 'multi_class_topdown' : 'centered_instance';
                const ciScale = parseFloat(document.getElementById('ci-scale').value) || 1.0;
                const ciBackbone = document.getElementById('ci-backbone')?.value || 'unet';
                const ciFilters = parseInt(document.getElementById('ci-filters')?.value) || 32;
                const ciFiltersRate = parseFloat(document.getElementById('ci-filters-rate')?.value) || 1.5;
                const ciSigma = parseFloat(document.getElementById('ci-sigma').value) || 2.5;
                const ciOutputStride = parseInt(document.getElementById('ci-output-stride').value) || 1;
                // CI-specific training parameters
                const ciBatchSize = parseInt(document.getElementById('ci-batch-size')?.value) || 4;
                const ciMaxEpochs = parseInt(document.getElementById('ci-max-epochs')?.value) || 200;
                const ciLearningRate = document.getElementById('ci-learning-rate')?.value || '0.0001';
                const ciOptimizer = document.getElementById('ci-optimizer')?.value || 'Adam';
                const ciAccelerator = document.getElementById('ci-accelerator')?.value || 'auto';
                const ciEarlyStopping = document.getElementById('ci-early-stopping')?.checked ?? true;
                const ciSaveCkpt = document.getElementById('ci-save-ckpt')?.checked ?? true;
                const ciUseAug = document.getElementById('ci-use-augmentation')?.checked || false;
                const ciAdvancedOptions = getCIAdvancedOptions();

                const config2 = generateConfigYaml({
                    headType: ciHeadType, scale: ciScale, valFraction, cropSize, useAug: ciUseAug,
                    backbone: ciBackbone, maxStride: ciMaxStride, filters: ciFilters, filtersRate: ciFiltersRate,
                    sigma: ciSigma, outputStride: ciOutputStride,
                    batchSize: ciBatchSize, maxEpochs: ciMaxEpochs, learningRate: ciLearningRate,
                    optimizer: ciOptimizer, accelerator: ciAccelerator, earlyStopping: ciEarlyStopping, saveCkpt: ciSaveCkpt,
                    isCenteredInstance: true, anchorPart: selectedAnchor, inputChannels, advancedOptions: ciAdvancedOptions,
                    loadedConfig: loadedCIConfig
                });
                document.getElementById('yaml-output-2').textContent = config2;
            } else {
                document.getElementById('export-tab-2').classList.add('hidden');
                document.getElementById('download-all-btn').classList.add('hidden');
                document.getElementById('export-tab-1').textContent = 'Configuration';
            }

            // Update CLI commands
            updateCLICommands();
        }

        function generateConfigYaml(params) {
            const { headType, scale, valFraction, cropSize, useAug, backbone, maxStride, filters,
                    filtersRate, sigma, outputStride, batchSize, maxEpochs, learningRate, optimizer, accelerator,
                    earlyStopping, saveCkpt, isCenteredInstance, anchorPart, inputChannels, advancedOptions, loadedConfig } = params;

            const numChannels = inputChannels || slpData.numChannels;
            const adv = advancedOptions || {};
            const fRate = filtersRate || 1.5;

            // Helper to get value from loaded config or use default
            const lc = loadedConfig || {};
            const lcData = lc.data_config || {};
            const lcTrainer = lc.trainer_config || {};
            const pafSigma = parseFloat(document.getElementById('paf-sigma')?.value) || 15.0;

            // Backbone config - determine channel conversion needs
            const isPretrained = backbone.startsWith('convnext') || backbone.startsWith('swint');
            // Pretrained backbones REQUIRE 3 channels (RGB)
            const backboneChannels = isPretrained ? 3 : numChannels;
            // ensure_rgb: convert 1-ch to 3-ch (needed if pretrained OR user wants RGB, AND original is grayscale)
            const needEnsureRgb = (isPretrained || numChannels === 3) && slpData.numChannels === 1;
            // ensure_grayscale: convert 3-ch to 1-ch (only when user explicitly wants grayscale AND original is RGB)
            const needEnsureGrayscale = numChannels === 1 && slpData.numChannels === 3;

            let backboneConfig = '';
            if (backbone.startsWith('unet')) {
                backboneConfig = `    unet:
      in_channels: ${backboneChannels}
      kernel_size: 3
      filters: ${filters}
      filters_rate: ${fRate}
      max_stride: ${maxStride}
      output_stride: ${outputStride}
    convnext: null
    swint: null`;
            } else if (backbone.startsWith('convnext')) {
                const modelType = backbone.replace('convnext_', '');
                // Map model type to pretrained weights enum (only if enabled)
                const weightsMap = {
                    'tiny': 'ConvNeXt_Tiny_Weights',
                    'small': 'ConvNeXt_Small_Weights',
                    'base': 'ConvNeXt_Base_Weights',
                    'large': 'ConvNeXt_Large_Weights'
                };
                const useImageNet = adv.useImageNetPretrained !== false;
                const pretrainedWeights = useImageNet ? (weightsMap[modelType] || 'ConvNeXt_Tiny_Weights') : null;
                backboneConfig = `    unet: null
    convnext:
      model_type: ${modelType}
      pre_trained_weights: ${pretrainedWeights}
      in_channels: ${backboneChannels}
      max_stride: 32
      output_stride: ${outputStride}
    swint: null`;
            } else {
                const modelType = backbone.replace('swint_', '');
                // Map model type to pretrained weights enum (only if enabled)
                const weightsMap = {
                    'tiny': 'Swin_T_Weights',
                    'small': 'Swin_S_Weights',
                    'base': 'Swin_B_Weights'
                };
                const useImageNet = adv.useImageNetPretrained !== false;
                const pretrainedWeights = useImageNet ? (weightsMap[modelType] || 'Swin_T_Weights') : null;
                backboneConfig = `    unet: null
    convnext: null
    swint:
      model_type: ${modelType}
      pre_trained_weights: ${pretrainedWeights}
      in_channels: ${backboneChannels}
      max_stride: 32
      output_stride: ${outputStride}`;
            }

            // Head config
            const partNames = slpData.skeleton.nodes.map(n => `      - ${n}`).join('\n');
            const anchorLine = anchorPart ? `anchor_part: ${anchorPart}` : 'anchor_part: null';
            let headConfig = '';

            if (headType === 'single_instance') {
                headConfig = `    single_instance:
      confmaps:
        part_names:
${partNames}
        sigma: ${sigma}
        output_stride: ${outputStride}
    centroid: null
    centered_instance: null
    bottomup: null
    multi_class_bottomup: null
    multi_class_topdown: null`;
            } else if (headType === 'centroid') {
                headConfig = `    single_instance: null
    centroid:
      confmaps:
        ${anchorLine}
        sigma: ${sigma}
        output_stride: ${outputStride}
    centered_instance: null
    bottomup: null
    multi_class_bottomup: null
    multi_class_topdown: null`;
            } else if (headType === 'centered_instance') {
                headConfig = `    single_instance: null
    centroid: null
    centered_instance:
      confmaps:
        part_names:
${partNames}
        ${anchorLine}
        sigma: ${sigma}
        output_stride: ${outputStride}
        loss_weight: 1.0
    bottomup: null
    multi_class_bottomup: null
    multi_class_topdown: null`;
            } else if (headType === 'bottomup') {
                const edges = slpData.skeleton.edges.map(e =>
                    `        - [${slpData.skeleton.nodes[e[0]]}, ${slpData.skeleton.nodes[e[1]]}]`).join('\n');
                headConfig = `    single_instance: null
    centroid: null
    centered_instance: null
    bottomup:
      confmaps:
        part_names:
${partNames}
        sigma: ${sigma}
        output_stride: ${outputStride}
        loss_weight: ${adv.confmapsLossWeight || 1.0}
      pafs:
        edges:
${edges}
        sigma: ${pafSigma}
        output_stride: ${adv.pafOutputStride || 2}
        loss_weight: ${adv.pafLossWeight || 1.0}
    multi_class_bottomup: null
    multi_class_topdown: null`;
            } else if (headType === 'multi_class_bottomup') {
                headConfig = `    single_instance: null
    centroid: null
    centered_instance: null
    bottomup: null
    multi_class_bottomup:
      confmaps:
        part_names:
${partNames}
        sigma: ${sigma}
        output_stride: ${outputStride}
        loss_weight: ${adv.mcConfmapsLossWeight || 1.0}
      class_maps:
        classes: null
        sigma: ${sigma}
        output_stride: ${outputStride}
        loss_weight: ${adv.classLossWeight || 1.0}
    multi_class_topdown: null`;
            } else if (headType === 'multi_class_topdown') {
                headConfig = `    single_instance: null
    centroid: null
    centered_instance: null
    bottomup: null
    multi_class_bottomup: null
    multi_class_topdown:
      confmaps:
        part_names:
${partNames}
        ${anchorLine}
        sigma: ${sigma}
        output_stride: ${outputStride}
        loss_weight: ${adv.mcConfmapsLossWeight || 1.0}
      class_vectors:
        classes: null
        num_fc_layers: ${adv.classFcLayers || 1}
        num_fc_units: ${adv.classFcUnits || 64}
        global_pool: true
        output_stride: ${maxStride}
        loss_weight: ${adv.classLossWeight || 1.0}`;
            }

            // Preprocessing - use max_height/max_width from advanced options if set, otherwise use image dimensions
            const maxH = adv.maxHeight || slpData.imgHeight;
            const maxW = adv.maxWidth || slpData.imgWidth;
            const minCropSize = adv.minCropSize || 100;
            const cropPadding = adv.cropPadding;
            let preprocessingConfig = isCenteredInstance
                ? `    crop_size: ${cropSize}\n    min_crop_size: ${minCropSize}\n    crop_padding: ${cropPadding === null ? 'null' : cropPadding}\n    scale: 1.0`
                : `    max_height: ${maxH}\n    max_width: ${maxW}\n    scale: ${scale}\n    crop_size: null`;

            // Augmentation - build from slider values
            let augConfig = 'null';
            if (useAug) {
                // Check which augmentations are enabled (slider > 0)
                const hasRotation = (adv.augRotation || 0) > 0;
                const hasScale = (adv.augScaleRange || 0) > 0;
                const hasTranslate = (adv.augTranslate || 0) > 0;
                const hasBrightness = (adv.augBrightness || 0) > 0;
                const hasContrast = (adv.augContrast || 0) > 0;

                const hasGeometric = hasRotation || hasScale || hasTranslate;
                const hasIntensity = hasContrast || hasBrightness;

                let augParts = [];

                if (hasIntensity) {
                    let intensityParts = ['    intensity:'];
                    if (hasContrast) {
                        const contrastPct = adv.augContrast / 100;
                        intensityParts.push(`      contrast_min: ${(1 - contrastPct).toFixed(2)}`);
                        intensityParts.push(`      contrast_max: ${(1 + contrastPct).toFixed(2)}`);
                        intensityParts.push('      contrast_p: 1.0');
                    }
                    if (hasBrightness) {
                        const brightnessPct = adv.augBrightness / 100;
                        intensityParts.push(`      brightness_min: ${(1 - brightnessPct).toFixed(2)}`);
                        intensityParts.push(`      brightness_max: ${(1 + brightnessPct).toFixed(2)}`);
                        intensityParts.push('      brightness_p: 1.0');
                    }
                    augParts.push(intensityParts.join('\n'));
                }

                if (hasGeometric) {
                    let geoParts = ['    geometric:'];
                    if (hasRotation) {
                        geoParts.push(`      rotation_min: ${-adv.augRotation}`);
                        geoParts.push(`      rotation_max: ${adv.augRotation}`);
                    }
                    if (hasScale) {
                        const scalePct = adv.augScaleRange / 100;
                        geoParts.push(`      scale_min: ${(1 - scalePct).toFixed(2)}`);
                        geoParts.push(`      scale_max: ${(1 + scalePct).toFixed(2)}`);
                    }
                    if (hasTranslate) {
                        geoParts.push(`      translate_width: ${adv.augTranslate.toFixed(2)}`);
                        geoParts.push(`      translate_height: ${adv.augTranslate.toFixed(2)}`);
                    }
                    geoParts.push('      affine_p: 1.0');
                    augParts.push(geoParts.join('\n'));
                }

                augConfig = augParts.length > 0 ? '\n' + augParts.join('\n') : 'null';
            }

            return `# SLEAP-NN Training Configuration
# Generated by Config Picker
# Model type: ${headType}

data_config:
  train_labels_path:
    - ${lcData.train_labels_path?.[0] || '/path/to/your/labels.slp'}  # UPDATE THIS PATH
  val_labels_path: ${lcData.val_labels_path || 'null'}
  validation_fraction: ${valFraction}
  test_file_path: ${lcData.test_file_path || 'null'}
  provider: ${lcData.provider || 'LabelsReader'}
  user_instances_only: ${lcData.user_instances_only ?? true}
  data_pipeline_fw: ${adv.dataPipeline && adv.dataPipeline !== 'torch_dataset' ? adv.dataPipeline : lcData.data_pipeline_fw || 'torch_dataset'}
  parallel_caching: ${lcData.parallel_caching ?? 'null'}
  cache_workers: ${lcData.cache_workers ?? 'null'}
  preprocessing:
    ensure_rgb: ${needEnsureRgb}
    ensure_grayscale: ${needEnsureGrayscale}
${preprocessingConfig}
  use_augmentations_train: ${useAug}
  augmentation_config: ${augConfig}

model_config:
  init_weights: default
  pretrained_backbone_weights: ${adv.pretrainedBackboneWeights ? `"${adv.pretrainedBackboneWeights}"` : 'null'}
  pretrained_head_weights: ${adv.pretrainedHeadWeights ? `"${adv.pretrainedHeadWeights}"` : 'null'}
  backbone_config:
${backboneConfig}
  head_configs:
${headConfig}

trainer_config:
  train_data_loader:
    batch_size: ${batchSize}
    shuffle: true
    num_workers: ${adv.numWorkers || lcTrainer.train_data_loader?.num_workers || 0}
  val_data_loader:
    batch_size: ${batchSize}
    shuffle: false
    num_workers: ${adv.numWorkers || lcTrainer.val_data_loader?.num_workers || 0}
  model_ckpt:
    save_top_k: ${adv.ckptSaveTopK ?? lcTrainer.model_ckpt?.save_top_k ?? 1}
    save_last: ${adv.ckptSaveLast === true ? 'true' : adv.ckptSaveLast === false ? 'false' : lcTrainer.model_ckpt?.save_last ?? 'null'}
  trainer_devices: ${lcTrainer.trainer_devices || 'auto'}
  trainer_accelerator: ${accelerator}
  enable_progress_bar: ${lcTrainer.enable_progress_bar ?? true}
  min_train_steps_per_epoch: ${adv.minSteps || lcTrainer.min_train_steps_per_epoch || 200}
  visualize_preds_during_training: ${adv.enableViz || lcTrainer.visualize_preds_during_training || false}
  keep_viz: ${adv.vizKeepFolder || lcTrainer.keep_viz || false}
  max_epochs: ${maxEpochs}
  seed: ${adv.seed !== null && adv.seed !== undefined ? adv.seed : lcTrainer.seed ?? 'null'}
  use_wandb: ${adv.enableWandb || lcTrainer.use_wandb || false}
  save_ckpt: ${saveCkpt}
  ckpt_dir: ${adv.ckptDir && adv.ckptDir !== './models' ? adv.ckptDir : lcTrainer.ckpt_dir || './models'}
  run_name: ${adv.runName ? `"${adv.runName}"` : lcTrainer.run_name ? `"${lcTrainer.run_name}"` : 'null'}
  resume_ckpt_path: ${adv.resumeCkptPath ? `"${adv.resumeCkptPath}"` : 'null'}
  optimizer_name: ${optimizer}
  optimizer:
    lr: ${learningRate}
    amsgrad: false
  lr_scheduler:
${adv.lrScheduler === 'step_lr' ? `    step_lr:
      step_size: ${adv.stepLrStepSize || 10}
      gamma: ${adv.stepLrGamma || 0.1}
    reduce_lr_on_plateau: null
    cosine_annealing_warmup: null
    linear_warmup_linear_decay: null` : adv.lrScheduler === 'cosine_annealing_warmup' ? `    step_lr: null
    reduce_lr_on_plateau: null
    cosine_annealing_warmup:
      warmup_epochs: ${adv.cosineWarmupEpochs || 5}
      warmup_start_lr: ${adv.cosineWarmupStartLr || 0}
      eta_min: ${adv.cosineEtaMin || 0}
    linear_warmup_linear_decay: null` : adv.lrScheduler === 'linear_warmup_linear_decay' ? `    step_lr: null
    reduce_lr_on_plateau: null
    cosine_annealing_warmup: null
    linear_warmup_linear_decay:
      warmup_epochs: ${adv.linearWarmupEpochs || 5}
      warmup_start_lr: ${adv.linearWarmupStartLr || 0}
      end_lr: ${adv.linearEndLr || 0}` : adv.lrScheduler === 'none' ? `    step_lr: null
    reduce_lr_on_plateau: null
    cosine_annealing_warmup: null
    linear_warmup_linear_decay: null` : `    step_lr: null
    reduce_lr_on_plateau:
      threshold: ${lcTrainer.lr_scheduler?.reduce_lr_on_plateau?.threshold || 1e-6}
      threshold_mode: ${lcTrainer.lr_scheduler?.reduce_lr_on_plateau?.threshold_mode || 'abs'}
      cooldown: ${adv.reduceLrCooldown || 3}
      patience: ${adv.lrPatience || 5}
      factor: ${adv.reduceLrFactor || 0.5}
      min_lr: ${adv.reduceLrMin || 1e-8}
    cosine_annealing_warmup: null
    linear_warmup_linear_decay: null`}
  early_stopping:
    stop_training_on_plateau: ${earlyStopping}
    min_delta: ${adv.esMinDelta || lcTrainer.early_stopping?.min_delta || 1e-8}
    patience: ${adv.esPatience || lcTrainer.early_stopping?.patience || 10}
  online_hard_keypoint_mining:
    online_mining: ${adv.enableOhkm || lcTrainer.online_hard_keypoint_mining?.online_mining || false}
    hard_to_easy_ratio: ${adv.ohkmRatio || lcTrainer.online_hard_keypoint_mining?.hard_to_easy_ratio || 2.0}
    min_hard_keypoints: ${adv.ohkmMinHard || lcTrainer.online_hard_keypoint_mining?.min_hard_keypoints || 2}
    max_hard_keypoints: ${adv.ohkmMaxHard !== null && adv.ohkmMaxHard !== undefined ? adv.ohkmMaxHard : lcTrainer.online_hard_keypoint_mining?.max_hard_keypoints ?? 'null'}
    loss_scale: ${adv.ohkmLossScale || lcTrainer.online_hard_keypoint_mining?.loss_scale || 5.0}${(adv.enableWandb || lcTrainer.use_wandb) ? `
  wandb:
    entity: ${adv.wandbEntity ? `"${adv.wandbEntity}"` : lcTrainer.wandb?.entity ? `"${lcTrainer.wandb.entity}"` : 'null'}
    project: ${adv.wandbProject ? `"${adv.wandbProject}"` : lcTrainer.wandb?.project ? `"${lcTrainer.wandb.project}"` : '"sleap-training"'}
    name: ${adv.wandbName ? `"${adv.wandbName}"` : lcTrainer.wandb?.name ? `"${lcTrainer.wandb.name}"` : 'null'}
    api_key: ${adv.wandbApiKey ? `"${adv.wandbApiKey}"` : lcTrainer.wandb?.api_key ? `"${lcTrainer.wandb.api_key}"` : 'null'}
    wandb_mode: ${adv.wandbMode ? `"${adv.wandbMode}"` : lcTrainer.wandb?.wandb_mode ? `"${lcTrainer.wandb.wandb_mode}"` : 'null'}
    viz_enabled: ${adv.wandbVizEnabled ?? lcTrainer.wandb?.viz_enabled ?? true}
    save_viz_imgs_wandb: ${adv.wandbSaveViz || lcTrainer.wandb?.save_viz_imgs_wandb || false}` : ''}${adv.enableEval ? `
  eval:
    enabled: true
    frequency: ${adv.evalFrequency || 1}
    oks_stddev: ${adv.evalOksStddev || 0.025}` : ''}
`;
        }

        function copyYaml(configNum) {
            const yaml = document.getElementById(`yaml-output-${configNum}`).textContent;
            navigator.clipboard.writeText(yaml)
                .then(() => alert('Copied to clipboard!'))
                .catch(() => {
                    const ta = document.createElement('textarea');
                    ta.value = yaml;
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    alert('Copied to clipboard!');
                });
        }

        function downloadYaml(configNum) {
            const yaml = document.getElementById(`yaml-output-${configNum}`).textContent;
            let filename = 'training_config.yaml';
            if (isTopDown) filename = configNum === 1 ? 'centroid_config.yaml' : 'centered_instance_config.yaml';

            const blob = new Blob([yaml], { type: 'text/yaml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadAllConfigs() {
            downloadYaml(1);
            if (isTopDown) setTimeout(() => downloadYaml(2), 500);
        }

        function copyCLI(elementId) {
            const cmd = document.getElementById(elementId).textContent;
            navigator.clipboard.writeText(cmd)
                .then(() => alert('Command copied!'))
                .catch(() => {
                    const ta = document.createElement('textarea');
                    ta.value = cmd;
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    alert('Command copied!');
                });
        }

        function updateCLICommands() {
            // Determine config filenames
            const configFile1 = isTopDown ? 'centroid_config.yaml' : 'training_config.yaml';
            const configFile2 = 'centered_instance_config.yaml';

            // Basic command
            document.getElementById('cli-basic').textContent = `sleap-nn train ${configFile1}`;

            // With labels path override
            document.getElementById('cli-override').textContent =
                `sleap-nn train ${configFile1} data_config.train_labels_path='["/path/to/your/labels.slp"]'`;

            // Top-down CI command
            if (isTopDown) {
                document.getElementById('cli-topdown-section').classList.remove('hidden');
                document.getElementById('cli-ci').textContent = `sleap-nn train ${configFile2}`;
            } else {
                document.getElementById('cli-topdown-section').classList.add('hidden');
            }
        }
    </script>
</body>
</html>
