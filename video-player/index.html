<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frame-Accurate Video Player</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        h1 { margin-bottom: 0.5rem; color: #fff; }
        .description { color: #aaa; margin-top: 0; }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #5568d3; }
        button:disabled {
            background: #444;
            cursor: not-allowed;
        }
        .canvas-container {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            margin: 20px 0;
            cursor: grab;
        }
        .canvas-container:active { cursor: grabbing; }
        canvas {
            display: block;
            width: 100%;
            height: auto;
            image-rendering: crisp-edges;
        }
        .seekbar-container {
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .seekbar {
            width: 100%;
            height: 8px;
            background: #444;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            margin: 10px 0;
        }
        .seekbar-progress {
            height: 100%;
            background: #667eea;
            border-radius: 4px;
            width: 0%;
            pointer-events: none;
        }
        .seekbar-thumb {
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            left: 0%;
            pointer-events: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .metrics {
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #aaa;
            margin: 20px 0;
        }
        .metrics-row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .metric {
            margin: 5px 0;
        }
        .metric-label {
            color: #667eea;
            font-weight: bold;
        }
        .settings {
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .settings label {
            display: inline-block;
            margin-right: 10px;
            color: #aaa;
        }
        .settings input[type="number"] {
            background: #1a1a1a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 6px 10px;
            border-radius: 4px;
            width: 80px;
            font-size: 14px;
        }
        .hotkeys {
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 14px;
        }
        .hotkeys h3 {
            margin-top: 0;
            color: #fff;
        }
        .hotkeys-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
        }
        .hotkey {
            display: flex;
            justify-content: space-between;
        }
        .hotkey-key {
            color: #667eea;
            font-family: 'Courier New', monospace;
        }
        .hotkey-desc {
            color: #aaa;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #aaa;
        }
        @media (max-width: 600px) {
            body { padding: 10px; }
            .controls, .settings, .metrics { padding: 10px 15px; }
            button { padding: 10px 16px; font-size: 14px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Frame-Accurate Video Player</h1>
        <p class="description">Load local videos with frame-accurate seeking, zoom/pan, and playback controls.</p>

        <div class="controls">
            <button id="loadBtn">Load Video File</button>
            <button id="playBtn" disabled>Play</button>
            <button id="resetZoomBtn" disabled>Reset Zoom</button>
        </div>

        <div class="settings">
            <label>Buffer Size: <input type="number" id="bufferSize" value="30" min="1" max="500"></label>
        </div>

        <div class="canvas-container" id="canvasContainer" style="display: none;">
            <canvas id="canvas"></canvas>
        </div>

        <div class="seekbar-container" id="seekbarContainer" style="display: none;">
            <div class="seekbar" id="seekbar">
                <div class="seekbar-progress" id="seekbarProgress"></div>
                <div class="seekbar-thumb" id="seekbarThumb"></div>
            </div>
        </div>

        <div class="metrics" id="metrics" style="display: none;">
            <div class="metrics-row">
                <div class="metric"><span class="metric-label">File:</span> <span id="metricFile">-</span></div>
                <div class="metric"><span class="metric-label">Frame:</span> <span id="metricFrame">-</span></div>
                <div class="metric"><span class="metric-label">Total Frames:</span> <span id="metricTotal">-</span></div>
                <div class="metric"><span class="metric-label">FPS:</span> <span id="metricFps">-</span></div>
            </div>
            <div class="metrics-row">
                <div class="metric"><span class="metric-label">Load:</span> <span id="metricLoad">-</span></div>
                <div class="metric"><span class="metric-label">Decode:</span> <span id="metricDecode">-</span></div>
                <div class="metric"><span class="metric-label">Render:</span> <span id="metricRender">-</span></div>
                <div class="metric"><span class="metric-label">Cached:</span> <span id="metricCached">-</span></div>
            </div>
        </div>

        <div class="hotkeys">
            <h3>Keyboard Shortcuts</h3>
            <div class="hotkeys-grid">
                <div class="hotkey"><span class="hotkey-key">← / →</span><span class="hotkey-desc">±1 frame</span></div>
                <div class="hotkey"><span class="hotkey-key">↑ / ↓</span><span class="hotkey-desc">±10 frames</span></div>
                <div class="hotkey"><span class="hotkey-key">Ctrl+← / →</span><span class="hotkey-desc">±30 frames</span></div>
                <div class="hotkey"><span class="hotkey-key">Ctrl+↑ / ↓</span><span class="hotkey-desc">±100 frames</span></div>
                <div class="hotkey"><span class="hotkey-key">Space</span><span class="hotkey-desc">Play/Pause</span></div>
                <div class="hotkey"><span class="hotkey-key">Mouse Wheel</span><span class="hotkey-desc">Zoom</span></div>
                <div class="hotkey"><span class="hotkey-key">Click + Drag</span><span class="hotkey-desc">Pan</span></div>
            </div>
        </div>

        <div class="loading" id="loading" style="display: none;">
            <p>Loading ffmpeg.wasm...</p>
        </div>
    </div>

    <script src="lib/ffmpeg.js"></script>
    <script>
        // Global state
        let ffmpeg = null;
        let ffmpegLoaded = false;
        let videoData = null;
        let currentFrame = 0;
        let totalFrames = 0;
        let fps = 0;
        let fileName = '';
        let isPlaying = false;
        let playInterval = null;

        // Frame cache (MRU - Most Recently Used)
        const frameCache = new Map();
        let maxCacheSize = 30;

        // Canvas and zoom/pan state
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        // Request queue management
        let pendingFrameRequest = null;
        let currentFrameRequest = null;

        // Performance metrics
        let lastLoadTime = 0;
        let lastDecodeTime = 0;
        let lastRenderTime = 0;

        // UI Elements
        const loadBtn = document.getElementById('loadBtn');
        const playBtn = document.getElementById('playBtn');
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        const canvasContainer = document.getElementById('canvasContainer');
        const seekbar = document.getElementById('seekbar');
        const seekbarProgress = document.getElementById('seekbarProgress');
        const seekbarThumb = document.getElementById('seekbarThumb');
        const seekbarContainer = document.getElementById('seekbarContainer');
        const metricsDiv = document.getElementById('metrics');
        const loadingDiv = document.getElementById('loading');
        const bufferSizeInput = document.getElementById('bufferSize');

        // Initialize ffmpeg
        async function initFFmpeg() {
            if (ffmpegLoaded) return;

            loadingDiv.style.display = 'block';
            loadBtn.disabled = true;

            const { createFFmpeg, fetchFile } = FFmpeg;

            // Use local single-threaded core to avoid CORS and SharedArrayBuffer issues
            const baseURL = new URL('lib/', window.location.href).href;
            ffmpeg = createFFmpeg({
                log: false,
                corePath: `${baseURL}ffmpeg-core.js`,
            });

            await ffmpeg.load();

            ffmpegLoaded = true;
            loadingDiv.style.display = 'none';
            loadBtn.disabled = false;
            console.log('FFmpeg loaded');
        }

        // Load video file using File System Access API
        async function loadVideoFile() {
            try {
                // Ensure ffmpeg is loaded
                if (!ffmpegLoaded) {
                    await initFFmpeg();
                }

                const [fileHandle] = await window.showOpenFilePicker({
                    types: [{
                        description: 'Video Files',
                        accept: {
                            'video/*': ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.m4v']
                        }
                    }]
                });

                const file = await fileHandle.getFile();
                fileName = file.name;
                videoData = await file.arrayBuffer();

                // Write video to ffmpeg filesystem
                ffmpeg.FS('writeFile', 'input.video', new Uint8Array(videoData));

                // Get video metadata (fps and total frames)
                await getVideoMetadata();

                // Clear cache
                frameCache.clear();

                // Show UI
                canvasContainer.style.display = 'block';
                seekbarContainer.style.display = 'block';
                metricsDiv.style.display = 'block';
                playBtn.disabled = false;
                resetZoomBtn.disabled = false;

                // Load first frame
                currentFrame = 0;
                await seekToFrame(0);

            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Error loading file:', err);
                    alert('Error loading video file: ' + err.message);
                }
            }
        }

        // Get video metadata using ffprobe
        async function getVideoMetadata() {
            let duration = 0;
            fps = 30; // Default fallback

            // Set up log callback to capture ffmpeg output
            const logs = [];
            ffmpeg.setLogger(({ message }) => {
                logs.push(message);
            });

            try {
                // Run ffmpeg to get video info (will fail but produces metadata in logs)
                await ffmpeg.run('-i', 'input.video', '-f', 'null', '-');
            } catch (e) {
                // Expected to fail, we just need the logs
            }

            // Parse logs for duration and fps
            const logText = logs.join('\n');

            // Extract duration: "Duration: HH:MM:SS.ms"
            const durationMatch = logText.match(/Duration: (\d{2}):(\d{2}):(\d{2}\.\d{2})/);
            if (durationMatch) {
                const hours = parseInt(durationMatch[1]);
                const minutes = parseInt(durationMatch[2]);
                const seconds = parseFloat(durationMatch[3]);
                duration = hours * 3600 + minutes * 60 + seconds;
            }

            // Extract FPS: "XX fps" or "XX.XX fps" or "XX tbr"
            const fpsMatch = logText.match(/(\d+\.?\d*)\s*fps/) || logText.match(/(\d+\.?\d*)\s*tbr/);
            if (fpsMatch) {
                fps = parseFloat(fpsMatch[1]);
            }

            // Calculate total frames
            if (duration > 0 && fps > 0) {
                totalFrames = Math.floor(duration * fps);
            } else {
                // Fallback: try to count frames (slow but accurate)
                totalFrames = 1000; // Conservative fallback
            }

            // Clear logger
            ffmpeg.setLogger(({ message }) => {});

            console.log(`Video metadata: ${duration.toFixed(2)}s, ${fps.toFixed(2)} fps, ${totalFrames} frames`);
            updateMetrics();
        }

        // Seek to specific frame
        async function seekToFrame(frameIndex) {
            // Clamp frame index
            frameIndex = Math.max(0, Math.min(frameIndex, totalFrames - 1));

            // Drop any pending request
            if (pendingFrameRequest !== null) {
                pendingFrameRequest = null;
            }

            // Store new request
            pendingFrameRequest = frameIndex;

            // If already processing a request, let it finish and pick up the new one
            if (currentFrameRequest !== null) {
                return;
            }

            // Process request
            await processFrameRequest();
        }

        // Process frame request queue
        async function processFrameRequest() {
            while (pendingFrameRequest !== null) {
                const requestedFrame = pendingFrameRequest;
                pendingFrameRequest = null;
                currentFrameRequest = requestedFrame;

                // Check cache first
                if (frameCache.has(requestedFrame)) {
                    const cachedFrame = frameCache.get(requestedFrame);

                    // Move to end (most recently used)
                    frameCache.delete(requestedFrame);
                    frameCache.set(requestedFrame, cachedFrame);

                    currentFrame = requestedFrame;
                    lastLoadTime = 0;
                    lastDecodeTime = 0;

                    const renderStart = performance.now();
                    renderFrame(cachedFrame);
                    lastRenderTime = performance.now() - renderStart;

                    updateMetrics();
                    updateSeekbar();
                } else {
                    // Load from video
                    await loadFrame(requestedFrame);
                }
            }

            currentFrameRequest = null;
        }

        // Load frame from video
        async function loadFrame(frameIndex) {
            const loadStart = performance.now();

            try {
                // Extract specific frame using ffmpeg
                if (fps <= 0) {
                    throw new Error('Invalid FPS value');
                }
                const frameTime = frameIndex / fps;
                await ffmpeg.run(
                    '-ss', frameTime.toFixed(3),
                    '-i', 'input.video',
                    '-vframes', '1',
                    '-f', 'image2',
                    'frame.png'
                );

                lastLoadTime = performance.now() - loadStart;

                const decodeStart = performance.now();

                // Read frame data
                const frameData = ffmpeg.FS('readFile', 'frame.png');
                const blob = new Blob([frameData.buffer], { type: 'image/png' });
                const img = await createImageBitmap(blob);

                lastDecodeTime = performance.now() - decodeStart;

                // Add to cache
                addToCache(frameIndex, img);

                // Render
                currentFrame = frameIndex;
                const renderStart = performance.now();
                renderFrame(img);
                lastRenderTime = performance.now() - renderStart;

                updateMetrics();
                updateSeekbar();

            } catch (err) {
                console.error('Error loading frame:', err);
            }
        }

        // Add frame to cache with MRU eviction
        function addToCache(frameIndex, imageData) {
            // Remove oldest if cache is full
            if (frameCache.size >= maxCacheSize) {
                const firstKey = frameCache.keys().next().value;
                frameCache.delete(firstKey);
            }

            frameCache.set(frameIndex, imageData);
        }

        // Render frame to canvas
        function renderFrame(imageData) {
            // Set canvas size on first render
            if (canvas.width === 0) {
                canvas.width = imageData.width;
                canvas.height = imageData.height;
            }

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Apply transform
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // Draw image
            ctx.drawImage(imageData, 0, 0);

            ctx.restore();
        }

        // Update metrics display
        function updateMetrics() {
            document.getElementById('metricFile').textContent = fileName;
            document.getElementById('metricFrame').textContent = currentFrame;
            document.getElementById('metricTotal').textContent = totalFrames;
            document.getElementById('metricFps').textContent = fps.toFixed(2);
            document.getElementById('metricLoad').textContent = lastLoadTime.toFixed(1) + 'ms';
            document.getElementById('metricDecode').textContent = lastDecodeTime.toFixed(1) + 'ms';
            document.getElementById('metricRender').textContent = lastRenderTime.toFixed(1) + 'ms';
            document.getElementById('metricCached').textContent = frameCache.size + '/' + maxCacheSize;
        }

        // Update seekbar position
        function updateSeekbar() {
            const progress = totalFrames > 0 ? (currentFrame / totalFrames) * 100 : 0;
            seekbarProgress.style.width = progress + '%';
            seekbarThumb.style.left = progress + '%';
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (!videoData) return;

            let delta = 0;

            if (e.key === 'ArrowLeft') {
                delta = e.ctrlKey ? -30 : -1;
                e.preventDefault();
            } else if (e.key === 'ArrowRight') {
                delta = e.ctrlKey ? 30 : 1;
                e.preventDefault();
            } else if (e.key === 'ArrowUp') {
                delta = e.ctrlKey ? 100 : 10;
                e.preventDefault();
            } else if (e.key === 'ArrowDown') {
                delta = e.ctrlKey ? -100 : -10;
                e.preventDefault();
            } else if (e.key === ' ') {
                togglePlayback();
                e.preventDefault();
            }

            if (delta !== 0) {
                seekToFrame(currentFrame + delta);
            }
        });

        // Seekbar click
        seekbar.addEventListener('click', (e) => {
            const rect = seekbar.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percent = x / rect.width;
            const frame = Math.floor(percent * totalFrames);
            seekToFrame(frame);
        });

        // Zoom with mouse wheel
        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            scale *= delta;
            scale = Math.max(0.1, Math.min(10, scale));

            // Re-render current frame
            if (frameCache.has(currentFrame)) {
                renderFrame(frameCache.get(currentFrame));
            }
        });

        // Pan with mouse drag
        canvasContainer.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStartX = e.clientX - offsetX;
            dragStartY = e.clientY - offsetY;
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                offsetX = e.clientX - dragStartX;
                offsetY = e.clientY - dragStartY;

                // Re-render current frame
                if (frameCache.has(currentFrame)) {
                    renderFrame(frameCache.get(currentFrame));
                }
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Reset zoom
        resetZoomBtn.addEventListener('click', () => {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            if (frameCache.has(currentFrame)) {
                renderFrame(frameCache.get(currentFrame));
            }
        });

        // Playback
        function togglePlayback() {
            if (isPlaying) {
                stopPlayback();
            } else {
                startPlayback();
            }
        }

        function startPlayback() {
            isPlaying = true;
            playBtn.textContent = 'Pause';

            // Preload next frames
            preloadFrames();

            // Play frames
            playInterval = setInterval(() => {
                if (currentFrame < totalFrames - 1) {
                    seekToFrame(currentFrame + 1);
                    preloadFrames();
                } else {
                    stopPlayback();
                }
            }, 1000 / fps);
        }

        function stopPlayback() {
            isPlaying = false;
            playBtn.textContent = 'Play';
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
            }
        }

        // Preload future frames during playback
        async function preloadFrames() {
            const preloadCount = 5;
            for (let i = 1; i <= preloadCount; i++) {
                const futureFrame = currentFrame + i;
                if (futureFrame < totalFrames && !frameCache.has(futureFrame)) {
                    // Load in background (don't await)
                    loadFrame(futureFrame).catch(err => console.error('Preload error:', err));
                    break; // Load one at a time to avoid overwhelming
                }
            }
        }

        // Update buffer size
        bufferSizeInput.addEventListener('change', () => {
            const newSize = parseInt(bufferSizeInput.value);
            if (newSize > 0 && newSize <= 500) {
                maxCacheSize = newSize;

                // Trim cache if needed
                while (frameCache.size > maxCacheSize) {
                    const firstKey = frameCache.keys().next().value;
                    frameCache.delete(firstKey);
                }

                updateMetrics();
            }
        });

        // Button handlers
        loadBtn.addEventListener('click', loadVideoFile);
        playBtn.addEventListener('click', togglePlayback);

        // Initialize on load
        window.addEventListener('load', () => {
            initFFmpeg();
        });
    </script>
</body>
</html>
